# C++ Primer

## 1 开始

### 1.1 编写一个简单的C++程序

每个C++程序都包含一个或多个函数，其中一个必须命名为mian。

一个函数的定义包含四部分：返回类型、函数名、一个括号保卫的形参列表以及函数体。

main函数的返回值必须是int类型。int是一种内置类型，即语言自身定义的类型。

函数定义的最后一部分是函数体，它是一个以左花括号开始，以右花括号结束的语句块。

大多数C++语句以分号表示结束。如果忘记写分号会导致莫名其妙的编译错误。

在大多数系统中，main函数的返回值被用来指示状态。返回值0表示成功，非0的返回值由系统定义，通常用来指出错误类型。

#### 1.1.1 编译、运行程序

编译好程序后，我们就需要编译它。

程序源文件命名约定

​	程序文件通常被称为源文件。在大多数系统中，源文件的名字以一个后缀为结尾，后缀是由一个句点后接一个或多个字符组成的。后缀告诉系统这个文件是一个C++程序。不同的编译器使用不同的后缀命名约定。最常见的包括.cc、.cxx、.cpp、.cp以及.C。

从命令行运行编译器

```shell
$ cc prog1.cc
```

cc是编译器的名字，$是系统提示符。编译器生成一个可执行文件。windows会将这个可执行文件命名为prog1.exe，UNIX系统中的编译器通常会将可执行程序命名为a.out。

windows中查看状态:

```powershell
$ echo %ERRORLEVEL%
```

其他编译器：

GUN编译器的命令是g++：

```shell
$ g++ -o prog1 prog1.cc
```

为方便在机器内编译，编辑了一个脚本用于根据文件编译二进制到指定的文件夹内：

```shell
# /usr/bin/primer
filename=$1
build=$(echo $1 | awk -F'\.' '{print $1}' 2>/dev/null)

g++ -o ../build/$build $filename
```

### 1.2 初识输入输出

C++语言并未定义任何输入输出(IO)语句，取而代之，包含了一个全面的标准库(standard library)来提供IO机制(以及很多其他设施)。

iostream库，包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语 流 想要表达的是，随着时间的推移，字符是顺序生成和消耗的。

标准输入输出对象

​	标准库定义了4个IO对象。为了处理输入，我们采用一个名为cin的istream类型的对象，这个对象也被称为标准输入。对于输出，我们使用一个名为cout的ostream类型的对象，这个对象也被称为标准输出。标准库还定义了其他两个ostream对象，名为cerr和clog。通常用cerr来输出警告和错误消息，也被称为标准错误。而clog被用来输出程序运行时的一般性信息。

系统通常将程序所运行的窗口和这些对象关联起来。因此我们读取cin，数据将从正在运行的窗口读入，当我们向cout、cerr、clog写入数据时，将会写到同一个窗口

一个使用IO库的程序

```c++
// prog2.cc
#include <iostream>

int main()
{
    std::cout << "Enter two numbers: ";
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2
              << " is " << v1 + v2 << "." << std::endl;
    return 0;
}
```

程序的第一行告诉我们想要使用iostream库，尖括号的名字指出了一个头文件。每个使用标准库设施的程序都必须包含相应的头文件。#include指令和头文件的名字必须写在同一行中，通常情况下，#include执行必须出现在所有函数之外。一般将一个程序的所有#include指令放在源文件的开始位置。

向流写入数据

​	C++ 中，一个表达式产生一个计算结果，它由一个或多个运算对象和通常是一个运算符组成。

​	输出运算符(<<)，接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。词运算符将给定的值写入到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。即：计算结果就是我们写入给定值的哪个ostream对象。

我们输出语句使用两次<<运算符，因为此运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。这样我们就可以将输出请求连接起来。

endl，被称为一个操作符的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。

使用标准库中的名字

​	std::cout中std::指出cout是定义在名字为std的命名空间中的。命名空间可以帮助我们避免在不经意的名字定义冲突。::是作用域运算符。

从流中读取数据

​	>> 输入运算符，类似于输出运算符

### 1.3 注释简介

C++中注释的种类

​	C++中有两种注释：单行注释和界定符对注释。单行注释以双斜线(//)开始，以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线

​	另一种注释使用继承自C语言的两个界定符/\*和\*/。这种注释以/\*开始，以\*/结束，可以包含除\*/之外的任意内容，包括换行符。编译器将落在/\*和\*/之间的任意内容都当做注释。、

​	使用注释界定符注释时，建议朱市内的每行都以一个\*号开头，从而指出整个范围都是多行注释的一部分。

注释错误：

![image-20210616170224000](C:\Users\wangqiwei\AppData\Roaming\Typora\typora-user-images\image-20210616170224000.png)

### 1.4 控制流

#### 1.4.1 while语句

while语句反复执行一段代码，直至给定条件为假为止。

```c++
while (condition)
    statement
```

while语句的执行过程是交替的 检测condition条件和执行statement语句，直到condition语句为假时停止。所谓条件(condition)就是一个产生真或假的结果的表达式。只要condition为真，statement就会被执行。

#### 1.4.2 for语句

每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句(init-statement)、一个循环条件(condition)、以及一个表达式(expression)。

```c++
for (init-statement; condition; expression) {
    statement;
}
```



#### 1.4.3 读取数量不定的输入数据

当我们使用一个istream对象作为循环的条件condition时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或遇到一个无效的输入时(如接收一个int类型却收到一个字符串)，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。

从键盘输入文件结束符

​	当从键盘想程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定，windows中输入文件结束符的方法是ctrl + z，然后按Enter或Return键。在UNIX系统中，包括Mac OS X系统中，文件结束符输入是用ctrl + d。

#### 1.4.4 if语句

```c++
if (condition)
    statement;
```

### 1.5 类简介

在C++中，我们通过定义一个类(class)来定义自己的数据结构。一个类定义了一个一个类型，以及与其关联的一组操作，类机制是C++最重要的特性之一。实际上C++最初的一个设计焦点就是能定义使用上像内置类型一样自然的类类型(class type)。

如前所见，为了使用标准库，我们必须包含相关的头文件。类似的，我们也需要使用头文件来访问为自己的应用程序所定义的类。习惯上，头文件根据其中定义的类的名字来命名。我们通常使用.h作为头文件的后缀名。但也有一些程序员习惯.H、.hpp、.hxx。标准库头文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定的要求。

使用文件重定向

```shell
# 从infile读取输入，输出结果到outfile
$ addItems <infile >outfile
```

#### 1.5.2 成员函数

成员函数是定义为类的一部分的函数，有时也被称为方法。我们常用一个类对象的名义来调用成员函数。如：`item.isbn()`。使用`.`点运算符来表达我们需要“名为item的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。

当用点运算符访问一个成员函数时，通常我们是想(效果也确实是)调用该函数。我们使用调用运算符(())来调用一个函数。调用运算符是一对圆括号，里面放置实参列表(可能为空)。

## 2 变量和基本类型

### 2.1 基本内置类型

C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如当函数不返回任何值时使用空类型作为返回类型。

#### 2.1.1 算术类型

算术类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。

算术型的尺寸(也就是该类型数据所占的比特数)在不同机器上有所差别。

<table>
    <tr>
        <th colspan="3" style="text-align:center;">表2.1：C++：算术类型</th>
    </tr>
    <tr>
        <th>类型</th>
        <th>含义</th>
        <th>最小尺寸</th>
    </tr>
    <tr>
        <td>bool</td>
        <td>布尔类型</td>
        <td>未定义</td>
    </tr>
    <tr>
        <td>char</td>
        <td>字符</td>
        <td>8位</td>
    </tr>
    <tr>
        <td>wchar_t</td>
        <td>宽字符</td>
        <td>16位</td>
    </tr>
    <tr>
        <td>char16_t</td>
        <td>Unicode字符</td>
        <td>16位</td></td>
    </tr>
    <tr>
        <td>char32_t</td>
        <td>Unicode字符</td>
        <td>32位</td>
    </tr>
    <tr>
        <td>short</td>
        <td>短整型</td>
        <td>16位</td>
    </tr>
    <tr>
        <td>int</td>
        <td>整型</td>
        <td>16位</td>
    </tr>
    <tr>
        <td>long</td>
        <td>长整型</td>
        <td>32位</td>
    </tr>
    <tr>
        <td>long long</td>
        <td>长整型</td>
        <td>64位</td>
    </tr>
    <tr>
        <td>float</td>
        <td>单精度浮点数</td>
        <td>6位有效数字</td>
    </tr>
    <tr>
        <td>double</td>
        <td>双精度浮点数</td>
        <td>10位有效数字</td>
    </tr>
    <tr>
        <td>long double</td>
        <td>拓展精度浮点数</td>
        <td>10位有效数字</td>
    </tr>
</table>



布尔类型(bool)类型的取值是真(true)或假(false)。

C++提供了几种字符类型，其中大多数支持国际化。基本字符类型是char，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样。

其他字符类型用于拓展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大拓展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务(Unicode是用于表示所有自然语言中字符的标准)。

除字符和布尔类型之外，其他整型用于表示(可能)不同尺寸的整数。C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中心定义的。

>内置类型的机器实现
>
>------
>
>计算机以比特序列存储数据，每个bit非0即1，例如101010101...
>
>大多数计算机以2的整数次幂个bit作为块处理，可寻址的最小内存块称为“字节(byte)”，存储的基本单位称为”字(word)“，它通常由几个字节组成。C++中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64bit构成，也就是4或8字节。
>
>大多数计算机将内存中的每个字节与一个数字(被称为“地址(address)”)关联起来，在一个字节为8比特，字为32比特的机器上，我们可能看到一个字的内存区域如下：
>
>736424	00111011
>
>736425	00011000
>
>736426	01110001
>
>736427	01100100
>
>其中，左侧是字节的地址，右侧是字节中8比特的具体内容。
>
>我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可能会说地址736424的那个字或者地址736427的那个字节，为了赋予内存中某个地址明确的含义，必须首先知道存储在改地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。
>
>如果736424处的数据类型是float，并且该机器中float以32比特存储，那么我们就可以知道这个对象的内容占满了整个字。这个float数的实际值是依赖于该机器是如何存储浮点数的。

浮点数可以表示单精度、双精度和拓展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字(32bit)来表示，double以2个字(64bit)来表示，long double以3或4个字(即96或128bit)来表示。一般来说，类型float和double分别有7或16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

带符号类型和无符号类型

除去布尔值和拓展的字符型之外，其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种。带符号类型可以表示正数、负数和0，无符号类型则仅能表示大于等于0的值。

类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long。类型unsigned int可以缩写为unsigned。

与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要主义的是：类型char和类型signed char并不一样。尽管字符型有三中，但是字符的表现形式却只有两种：带符号的和无符号的，类型char实际上会表现为上述两种形式的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值，例如8bit的unsigned char可以表示0-255区间内的值。C++标准并没有规定带符号类型的应如何表示，但是约定了在表示范围内正值和负值的量应平衡。因此，8bit的signed char理论上可以表示-127至127区间内的值，大多数现代计算机将十几秒的表示范围定位-128至127.

#### 2.1.2 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换(convert)为另一种相关类型。

这里说明一些当给某种类型的对象强行服了另一种类型的值时，到底会发生什么。

```c++
bool b = 42;			// b的值是1
int i = b;				// i的值是1
i = 3.14;				// i的值是3
double pi = i;			// pi的值是3.0
unsigned char c = -1;	// 假设char占8bit，c的值为255
signed char c2 = 256;	// 假设char占8bit，c的值是未定义的
```

类型所能表述的值的范围决定了转换的过程：

- 当我们把一个非布尔类型的算术值赋给布尔类型，初始值为0则结果为false，其他为true
- 当我们把一个布尔类型的算术值赋给非布尔类型，初始值为false则结果为0，true为1
- 浮点型赋给整数类型，进行了近似处理。结果将仅保留浮点数中小数点之前的部分
- 整数型赋给浮点型，小数部分记为0。如果改正数所占空间超过了浮点类型的容量，精度可能会有损失
- 当我们赋给无符号类型一个超出他范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如8bit大小的unsigned char表示0-255之间，那么-1就是对256取模后的余数255
- 当我们赋值给带符号类型一个超过它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能会产生垃圾数据。

含有无符号类型的表达式

当一个算术表达式中既有无符号数又有int值时，那个int值会被转换成无符号数。把int转换成无符号的过程和把int直接赋值给无符号变量一样。

```c++
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出-84
std::cout << u + i << std::endl; // 如果int占32位，输出4294967264
```

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

```c++
unsigned u1 = 42, u2 =10;
std::cout << u1 - u2 << std::endl; // 32
std::cout << u2 - u1 << std::endl; // 4294967264
int a = 1, b = -1;
std::cout << u1 - a << std::endl; // 41
std::cout << u1 - b << std::endl; // 43
```

> 提示：切勿混用带符号类型和无符号类型

#### 2.1.3 字面值常量

一个形如42的值被称作字面值常量(literal)，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数。以0开头的整数代表八进制数，以0x或0X开头的代表16进制数。例如：

> 20 /\*十进制\*/			024  /\*八进制\*/			0x14  /\*十六进制\*/

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个符号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识:

> 3.14159	3.14159E0	0.	0e0	.001

字符和指腹从字面值

由单引号括起来的一个字符称为char型字面值，双括号括起来的零个或者多个字符则构成字符串型字面值

```c++
char a = 'a';	// 'a' 字符字面值
char b[] = "a";	// "a" 字符串字面值
```

字符串字面值的类型实际上是由常量字符构成的数组(array)。编译器在每个字符串结尾处添加一个空字符('\\0')，因此，字符串字面值的实际长度比它的内容多1。

如果一个字符串字面值过长，写成一行不太合适时，就可以采取分开书写的方式：

```c++
std::cout << "a really, really long string literalm "
          << "that spans two lines" << std::endl;
```

转义序列

有两类字符程序员不能直接使用：一类是不可打印(nonprintable)的字符，如退格或其他控制字符，因为他们没有可视的图符；另一类是C++语言中有特殊含义的字符(单引号、双引号、问号、反斜线)。这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

> 换行符			\n	横向制表符	\t	报警(响铃)符	  \a
>
> 纵向制表符	\v	退格符			\b	双引号				\\"
>
> 反斜线			\\\	问号				\?	单引号				 \\'
>
> 回车符			\r	进纸符			\f

也可以用泛化的转义字符，其形式是\x后紧跟一个或多个十六进制数字，或者\后紧跟1-3个八进制数字，其中数字部分表示的是字符对应的数值。八进制后只能跟3个数字，超过的算作字符，\x后用到所有紧跟的数字。

指定字面值的类型

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型

```c++
wchar_t a = L'a';				// 宽字符型字面值
char b[] = u8"hi！";				// utf-8字符串字面值(utf-8用8位编码一个Unicode字符)
unsigned long long c = 42ULL;	// 无符号整型字面值
float d = 1E-3F;				// 单精度浮点型字面值
long double e = 3.14159L;		// 扩展精度浮点型字面值
```

<table>
    <tr style="text-align: center;">
        <th colspan="4">表2.2：指定字面值的类型</th>
    </tr>
    <tr style="text-align: center;">
        <th colspan="4">字符和字符串字面值</th>
    </tr>
    <tr>
        <th>前缀</th>
        <th colspan="2">含义</th>
        <th>类型</th>
    </tr>
    <tr>
        <td>u</td>
        <td colspan="2">Unicode 16字符</td>
        <td>char16_t</td>
    </tr>
    <tr>
        <td>U</td>
        <td colspan="2">Unicode 32字符</td>
        <td>char32_t</td>
    </tr>
    <tr>
        <td>L</td>
        <td colspan="2">宽字符</td>
        <td>wchar_t</td>
    </tr>
    <tr>
        <td>u8</td>
        <td colspan="2">UTF-8(仅用于字符串字面常量)</td>
        <td>char</td>
    </tr>
    <tr style="text-align: center;">
        <th colspan="2">整型字面值</th>
        <th colspan="2">浮点型字面值</th>
    </tr>
    <tr>
        <th>后缀</th>
        <th>最小匹配类型</th>
        <th>后缀</th>
        <th>类型</th>
    </tr>
    <tr>
        <td>u or U</td>
        <td>unsigned</td>
        <td>f or F</td>
        <td>float</td>
    </tr>
    <tr>
        <td>l or L</td>
        <td>long</td>
        <td>l or L</td>
        <td>long double</td>
    </tr>
    <tr>
        <td>ll or LL</td>
        <td>long long</td>
        <td colspan="2"></td>
    </tr>
</table>



如果后缀有U，则该字面值为无符号类型，那么根据字面值的大小按能匹配类型空间最小的一个作为其数据类型。

布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针字面值

### 2.2 变量

#### 2.2.1 变量定义

变量定义的基本形式是：首先是类型说明符(type specifier)，随后紧跟一个或多个变量名组成的列表，其中变量名以逗号分开，最后以分号结束。列表中每个变量名的类型都有类型说明符指定，定义式还可以为一个或多个变量赋初值。

```c++
int sum = 0, value, //sum,value和units_sold都是int
	units_sold=0;	//sum和units_sold初值为0
Sales_item item;	//item的类型是Sales_item
//string是一种库类型，表示一个可变长的字符序列
std::string boox("0-201-78345-X"); //book通过一个sting字面值初始化
```

初始值

当对象在创建时获得了一个特定的值，我们说这个对象被初始化了；

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，赋值的含义是把对象的当前值擦除，而以一个新值来替代

列表初始化

初始化一个变量：

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，这种初始化的形式被称为列表初始化。现在，无论是初始化对象还是某些时候为对象赋新值，都可以用这样一组由花括号括起来的初始值。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器会报错：

```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在精度丢失
int c{ld}, d = ld; // 正确：转换执行，丢失了精度
```

默认初始化

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了"默认值"。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

如果是内置类型的变量未被显示初始化他，它的值由定义的位置决定。定义于函数体外的变量被初始化为0，但定义在函数体内部的内置类型变量**不被初始化**。一个未初始化的内置类型变量的值是未定义的，如果试图拷贝或者以其他形式访问此类值将引发错误。

每个类各自决定其初始化对象的方式，而且，是否允许不经过初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。

#### 2.2.2 变量声明和定义的关系

为了允许程序拆分成多个逻辑部分来写，C++支持分离式编译机制，该机制允许程序分割为若干个文件，每个文件可被独立编译。

为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明，而定义负责创建于名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：

```c++
extern int i; //声明i而非定义i
int j; //声明并定义j	
extern double pi = 3.14159;	//定义
```

任何包含了显示初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但这么做也就抵消了extern的作用。extern语句如果包含初始值就不是声明而是定义了。

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

变量能且只能被定义一次，但是可以被多次声明

#### 2.2.3 标识符

C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但对大小写字母敏感：

```c++
//定义4个不同的int变量
int somename, someName, SomeNmae, SOMENAME;
```

C++保留了一些名字供语言本身使用，这些名字不能用作标识符。同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下划线，同时也不能以下划线紧连大写字母开头。此外，定义在函数体之外的标识符不能以下划线开头。

变量命名规范

- 标识符要能体现实际含义
- 变量名一般用小写字母，如index，不要使用Index或INDEX
- 用户自定义的类名一般以大写字母开头，如Sales_items.
- 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan，不要使用studentloan。

<table>
  <tr>
    <th colspan="5" style="text-align: center;">表 2.3: C++关键字</th>
  </tr>
  <tr>
    <td>alignas</td>
    <td>continue</td>
    <td>fruebd</td>
    <td>register</td>
    <td>true</td>
  </tr>
  <tr>
    <td>alignof</td>
    <td>decltype</td>
    <td>goto</td>
    <td>reinterpret_case</td>
    <td>try</td>
  </tr>
  <tr>
    <td>asm</td>
    <td>default</td>
    <td>if</td>
    <td>return</td>
    <td>typedef</td>
  </tr>
  <tr>
    <td>auto</td>
    <td>delete</td>
    <td>inline</td>
    <td>short</td>
    <td>typeid</td>
  </tr>
  <tr>
    <td>bool</td>
    <td>do</td>
    <td>int</td>
    <td>signed</td>
    <td>typename</td>
  </tr>
  <tr>
    <td>break</td>
    <td>double</td>
    <td>long</td>
    <td>sizeof</td>
    <td>union</td>
  </tr>
  <tr>
    <td>case</td>
    <td>dynamic_cast</td>
    <td>mutable</td>
    <td>static</td>
    <td>unsigned</td>
  </tr>
  <tr>
    <td>catch</td>
    <td>else</td>
    <td>namespace</td>
    <td>static_assert</td>
    <td>using</td>
  </tr>
  <tr>
    <td>char</td>
    <td>enum</td>
    <td>new</td>
    <td>static_cast</td>
    <td>virtual</td>
  </tr>
  <tr>
    <td>char16_t</td>
    <td>explicit</td>
    <td>noexcept</td>
    <td>struct</td>
    <td>void</td>
  </tr>
  <tr>
    <td>char32_t</td>
    <td>export</td>
    <td>nullptr</td>
    <td>switch</td>
    <td>volatile</td>
  </tr>
  <tr>
    <td>class</td>
    <td>extern</td>
    <td>operator</td>
    <td>template</td>
    <td>wchar_t</td>
  </tr>
  <tr>
    <td>const</td>
    <td>false</td>
    <td>private</td>
    <td>this</td>
    <td>while</td>
  </tr>
  <tr>
    <td>constexpr</td>
    <td>float</td>
    <td>protected</td>
    <td>thread_local</td>
    <td></td>
  </tr>
  <tr>
    <td>const_cast</td>
    <td>for</td>
    <td>public</td>
    <td>throw</td>
    <td></td>
  </tr>
</table>



<table>
  <tr>
    <th style="text-align: center;" colspan=6>表 2.6: C++操作符替代名</th>
  </tr>
  <tr>
    <td>and</td>
    <td>bitand</td>
    <td>compl</td>
    <td>not_eq</td>
    <td>or_eq</td>
    <td>xor_eq</td>
  </tr>
  <tr>
    <td>and_eq</td>
    <td>bitor</td>
    <td>not</td>
    <td>or</td>
    <td>xor</td>
    <td></td>
  </tr>
</table>



#### 2.2.4 名字的作用域

不论是在程序的什么位置，使用到的名字都会指向一个特定的实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义。C++大多数作用域都以或括号分隔。同一个名字在不同作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

名字main定义于所有花括号之外，它和其他大多数定义在函数体之内的名字一样拥有全局作用域(global scope)。一旦声明之后，全局作用域内的名字在整个程序范围内都可使用。

嵌套的作用域

作用域能彼此包含，被包含(或者说被嵌套)的作用域叫内层作用域(inner scope)，包含着别的作用域的作用域被称为外层作用域(outer scope)。

作用域一旦声明了某个名字，它所嵌套的所有作用域中都可以访问该名字，同时，允许在内层作用域中重新定义外层作用域中已有的名字。

```c++
#include <iostream>

// 该程序仅用于说明：函数内部不宜定义于全局变量同名的新变量
int reused = 42;
int main()
{
    int unique = 0; // unique拥有块作用域
    // 输出#1: 使用全局变量reused；输出42 0
    std::cout << reused << " " << unique << std::endl;
    int reused = 0; // 新建局部变量reused，覆盖了全局变量reused
    // 输出#2: 使用局部便令reused， 输出0 0
    std::cout << reused << " " << unique << std::endl;
    // 输出#3: 显示的访问全局变量reused；输出42 0
    std::cout << ::reused << " " << unique << std::endl;
    return 0;
}
```

由于全局作用域本身没有名字，所以当作用域操作符左侧为空时，向全局作用域请求获取作用域操作符右侧名字对应的变量。

### 2.3 复合类型

复合类型是指基于其他类型定义的类型。C++有几种复合类型，本章介绍两种：指针和引用。

前面提到，一条简单的声明语句是有一个数据类型和紧跟其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由一个基本数据类型(basic type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量与基本数据类型有关的某种类型。

目前为止我们接触到的声明符就是变量名，此时变量的类型也就是声明的基本数据类型。其实还有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

#### 2.3.1 引用

> C++11 新增了一种引用：所谓的右值引用(rvalue reference)，这种引用主要用于内置类。严格来说，我们使用术语引用时，值的其实是左值引用(lvalue reference)

引用(reference)为对象起了另一个名字，引用类型引用(refers to)另外一种类型，通过将声明符携程&d的形式来定义引用类型，其中d是声明的变量。

```c++
int ival = 1024;
int &refVal = ival; // refVal指向ival，是ival的另一个名字
int &refVal2; // 报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序吧引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

引用即别名

> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

定义引用之后，对引用进行的所有操作都是在与之绑定的对象上进行的。

```c++
refVal = 2; // 把2赋值给refVal绑定的对象上，即赋给了ival
int ii = refVal; //与ii = ival指定结果一样
```

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作初值，实际上是以与引用绑定的对象作为初始值。

```c++
int &refVal3 = refVal; //正确，refVal3绑定到了与refVal绑定的对象上，而不是对引用做引用
```

因为引用本身不是一个对象，所以不能定义引用的引用。

引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以&符开头。

除了两种例外情况意外，其他所有引用的类型必须和与之绑定的对象严格匹配。而且引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

#### 2.3.2 指针

指针(pointer)是指向(point to)另外一种类型的复合类型。与引用相似，指针也是实现了对其他对象的间接访问。然而指针和引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无需再定义时赋初值，和其他类型一样，在块作用域定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成\*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号\*。

获取对象的地址

指针存放某个对象的地址，想要获取该地址，需要使用取地址符(操作符&)。

```c++
int ival = 42;
int *p = &ival;//p存放ival的地址 或者说p是指向变量ival的指针
```

第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象，因为引用不是对象， 没有实际地址，所以不能定义指向引用的指针。

除了两种例外情况意外，其他所有指针的类型必须和与它指向的对象匹配。否则会发生错误。

指针值

指针的值（即地址）应属下列4种状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值

试图拷贝或以其他方式访问无效指针的值都将引发错误、编译器并不负责检查此类错误，这一点和试图使用未初始化的变量是一样的。访问无效指针的后果无法预计，因此必须清楚任意给定的指针是否有效。

尽管第2、3种形式的指针是有效的，但其使用同样收到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针(假定的)对象的行为不被允许。

利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象：

```c++
int ival = 42;
int *p = &ival;
cout << *p; // 由符号*得到指针p所指向的对象 输出42
```

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

```c++
*p = 0; //由*得到指针p所指向的对象，即可由p为变量ival赋值
cout << *p;//输出0
```

空指针

空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。列出几个生成空指针的方法：

```c++
int *p1 = nullptr;	//等价于int *p1 = 0;
int *p2 = 0; // 直接将p2初始化为字面常量0
//首先需要#include cstdlib
int *p3 = NULL;//等价于int *p3 = 0;
```

得到空指针最直接的方法就是用字面值nullptr来初始化指针，这也是C++11新标准引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种就是和对p2的定义一样，直接将指针初始化为字面值0来生成空指针。

过去的程序还会用到一个名为NULL的预处理变量(preprocessor variable)来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。

预处理变量不属于std命名空间，它直接由预处理器负责管理，因此我们可以直接使用预处理变量而无需在前面加上std::。

当用到一个预处理变量时，预处理器会自动地将其替换成实际值，因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好用nullptr，同时应尽量避免用NULL。

把int变量直接赋给指针是错误的操作，即使int变量的值恰好是0页不行。

建议：**初始化所有指针，如果不知道该指向哪儿就初始化为空指针**

赋值与指针

指针和引用都能提供对其他对象的简介访问，然而在具体实现细节上二者有很大不同，其中最重要的一点是引用本身非一个对象。一旦定义了引用，就无法再令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：

```c++
int i = 42;
int *pi = 0;	// pi被初始化为空指针
int *pi2 = &i;	// pi2被初始化，存有i的地址
int *pi3;		// 如果pi3被定义与块内，无法确定值

pi3 = pi2;		// pi3指向pi2指向的对象
pi2 = 0;		// pi2指向空
```

有时候想要搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左边对象。

```c++
pi = &val; // pi的值被改变，现在pi指向了val
*pi = 0; // 由*得到指针pi所指向的对象,所以val的值变为0
```

其他指针操作

只要指针拥有一个合法值，就可以将它用在条件表达式中 。和采用算术值作为条件遵循的规则类似。如果指针的值是0，条件取false：

```c++
int ival = 1024;
int *p = 0;			// pi合法 是一个空指针
int *pi2 = &ival;	// pi2合法，存放这ival的地址
if (pi)		// 空指针， 条件值为false
    // ... 
if (pi2)	// pi2指向ival，值非0，为true
    // ...
```

任何非0指针对应的条件值都是true

对于两个类型相同的合法指针，可以用相等操作符(==)或不相等操作符(!=)来比较他们，比较的结果是布尔值。如果两个指针存放的地址值相同(两个指针相等)，有三种可能：它们都为空、都指向同一个对象、或者指向了同一个对象的下一个地址。需要注意的是，一个指针指向某对象，另一个指针指向另外对象的下一地址，此时也可能出现两个指针相等。

因为上述操作需要用到指针的值，因此所有指针必须是合法指针。

void\* 指针

void\*指针是一种特殊的指针类型，可用于存放任意对象的地址。一个void\*指针存放着一个地址，这一点和其他指针相似。不同的是，我们对这个指针存放对象是什么类型并不了解：

```c++
double obj = 3.14, *pd = &obj;
void *PV = &obj; // 正确，void*可以存放任何类型的对象地址
pv = pd; // pv可以存放任何类型的指针
```

利用void\*指针能做的事儿比较有限：拿他和别的指针做比较、作为函数的输入或输出、或者赋给另外一个指针。不能直接操作void\*所指的对象，因为我们并不知道这是个什么类型的对象，也就无法确定能在这个对象上做些什么操作。

概括来说，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

#### 2.3.3 理解复合类型的声明

如前所述，变量的定义包括一个基本数据类型和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是说一条定义语句可能定义出不同类型的变量：

```c++
//i是一个int型证书，p是一个int型指针，r是一个int型引用
int i = 1024, *p = &i; &r = i;
```

指向指针的指针

一般来说，声明符中的修饰符的个数没有限制。当有多个修饰符连写在一起时，按照其逻辑关系解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再放入另一个指针当中。

通过\*的个数可以区分指针的级别。也就是说\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```c++
int ival = 1;
int *pi = &ival;	// pi指向int类型整数
int **ppi = &pi;	// ppi指向int类型指针
```

使用指针的指针同样的，也需要解两次引用

```c++
std::cout << **ppi << std::endl; // 相当于ival
```

指向指针的引用

引用本身不是对象，因此不能定义指向引用的指针，但指针是一个对象，所以存在对指针的引用。

```c++
int i = 11;
int *p;			// 指针
int *&r = p;	// 指针的引用

r = &i;	// 赋值给引用指向的指针，即p指向i
*r = 0;	// 解引用，*p=0, 即i=0
```

要理解r的类型是什么，最简单的办法是从右往左阅读r的定义。离变量名最近的符号，本例中为&，对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，本例*&r表示r引用的是一个指针。

### 2.4 const 限定符

const对变量的类型加以限定之后，就定义了一个常量，可以随时警惕防止程序对变量的类型加以限定：

```c++
const int bufSize = 512;
bufSize = 111; // 错误，试图向const对象写值
```

任何试图向const对象赋值的行为都将引发错误，因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化，初始值可以是任意复杂的表达式、

初始化和const

const主要的限制就是只能在const类型的对象上执行不改变其内容的操作。

默认状态下，const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样。编译器将在编译过程中将用到该变量的地方全部换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须能访问到它的初始值才行，要做到这一点，就必须在每个用到变量的文件中都有对他的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象设定为仅在文件内有效。当多个文件中出现了同名的const对象时，其实等同于不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但有确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的const变量，相反，我们想让这类const对象像其他(非常量)对象一样工作，也就是说，只在一个文件中定义const，而在多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就够了：

```c++
// file1.cc定义并初始化了一个常量，该常量能够被其他文件访问
extern const int bufSize = fcn();
// file1.h头文件
extern const int bufSize;
```

如上述程序所示，file1.cc定义并初始化了bufSize。因为这条语句包含了初始值，因此它显然是一次定义，然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用

file1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件独有，它的定义也将在别处出现。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

#### 2.4.1 const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对常量的引用不能被用作修改它所绑定的对象。

> 引用的对象是常量还是非常量可以决定其所能参与的操作，却不会影响引用和对象的绑定关系本身。

初始化和对const的引用

2.3.1提到，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式。

```c++
int i = 23;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上
const int &r2 = 23;// 正确
const int &r3 = r1 * 2’;// 正确
int &r4 = r1 * 2;//错误，r4是一个普通的非常量引用
```

要想理解这种情况的原因，最简单的办法就是弄清楚当一个常量引用被绑定到另外一种类型上时发生了什么：

```c++
double dval = 3.14;
const int &ri = dval;
```

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式：

```c++
const int temp = deval;//由双精度浮点数生成一个临时的整型常量
const int &ri = temp; // 让ri绑定这个临时常量
```

在这种情况下，ri绑定了一个临时量对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。C++程序员常常把临时量对象简称为临时量。

接下来探讨ri不是常量时，如果执行了类似于上述初始化的过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值，注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则为什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。

对const的引用可能引用一个并未const的对象

必须认识到，**常量引用仅对引用可参与的操作做出了限定**，对于引用对象本身是不是一个常量未做限定。因为这个对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 23;
int &r1 = i;
const int &r2 = i; // r2也绑定i，但不允许通过r2修改i的值
r1 = 0; // 正确  r1非常量
r2 = 0; // 错误，常量引用
```

#### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：

```c++
const double pi = 3.14;
double *ptr = &pi; // 错误，ptr是一个普通指针
const double *ptr2 = &pi; // 正确，ptr2可以指向一个双精度常量
*ptr2 = 23; // 错误，不能给*ptr2赋值
```

2.3.2节提到，指针的类型必须与其所指对象的类型一致，但是有个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

```c++
double dval = 3.14;
prt2 = &dval; // 正确 但是不能通过ptr2改变dval的值
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓**指向常量的指针仅仅要求不能通过该指针改变对象的值**，而没有规定那个对象的值不能通过其他途径改变。

const指针

指针是对象而引用不是，因此就想其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值，即存放在指针中的那个地址就不能再改变了。把\*放到const之前用以说明指针是一个常量，这样的书写形式隐含这一层意味，即不变的是指针本身而非指向的那个值：

```c++
int errNumb = 0;
int *const curErr = &errNumb; // curErr将一直指向errNumb
const double pi = 3.14;
const double *const pip = &pi; // pip是一个指向常量对象的常量指针
```

要想弄清楚这些声明的含义罪行之有效的方法就是从右向左读。此例中，例curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由其他部分决定，下一个符号是\*，意思是一个常量指针。最后，该声明语句的基础数据类型部分确定了常量指针指的是一个int对象。与之相似，pip是一个常量指针，它指向的对象时一个双精度浮点型常量。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于对象的类型，例如pip是一个指向常量的常量指针，则不论pip所指的对象的值还是自己本身存储的地址都不能改变。相反的，curErr指向的一个一般的非常量整数，那么久完全可以用curErr去修改errNumb的值。

#### 2.4.3 顶层const

如前所述，指针本身是一个对象，它又可以指向另一个对象。因此指针本身是不是常量以及指针所指的对象是不是常量就是两个独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。

更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是指针类型既可以是顶层const，也可以是底层const，这一点和其他类型相比区别明显：

```c++
int i = 0;
int *const p1 = &i;// 不能改变p1的值，这是一个顶层const(指针常量
const int ci = 1; // 不能改变ci的值，这是一个顶层const(int常量
const int *p2 = &ci;// 允许改变p2的值，这是一个底层const(常量指针
const int *const p3 = p2; // 右边const为顶层，左边const为底层
const int &r = ci; // const引用 都是底层
```

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响：

```c++
i = ci; // 正确，拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3; //正确，p2、p3指向对象类型相同，p3顶层const的部分不影响
```

执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。

另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

```c++
int *p = p3; //错误，p3包含底层const的定义，p没有
p2 = p3;// 正确，p2和p3都是底层const
p2 = &i;// 正确int*可以转换成const int*
int &r = ci; // 错误，普通的int&不能绑定到int常量上
const int &r2 = i;// 正确，const int& 可以绑定到一个普通int上
```

p3既是顶层const又是底层const，拷贝p3是可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量，因此不能用p3去初始化p，因为p指向的是一个普通的非常量整数。另一方面，p3的值可以赋给p2，因为这两个指针都是底层const，尽管p3同时也是一个常量指针(顶层const)，仅就这次赋值而言不会有什么影响。

> 个人总结：
>
> 常量指针表示  指针自己是个常量  顶层const
>
> 指针常量表示  指针指向常量 底层const
>
> 指针常量要被赋给其他某变量【底层const的拷贝操作】，这个变量本身也得是个指针常量或引用常量【该对象也得具有底层const的资格】，或者两个对象的数据类型必须能够转换【int i = 1;conts int \*p2 = &i; 这里就是**将指针变量赋给指针常量**，没问题】

#### 2.4.4 constexpr和常量表达式

常量表达式是指值不会改变并在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```c++
const int max_files = 20; // max_files是常量表达式
const int limit = max_files + 1; // limit是常量表达式
int staff_size = 27; // staff_size不是常量表达式
const int sz = get_size(); // sz不是常量表达式
```

尽管staff_size的初始值是个字面值表达式，但由于它的数据类型只是一个普通变量而非const int，所以它不是个常量表达式。尽管sz是一个常量，但它的具体指知道运行时才能获取到所以它也不是常量表达式。

constexpr变量

在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在这种情况下，对象的定义和使用根本就是两回事儿。

C++11新标准规定，允许将变量生命为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```c++
constexpr int mf = 20; // 20是常量表达式
constexpr int limit = mf + 1;// mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一个正确的声明语句
```

尽管不能使用普通函数作为constexpr变量的初始值，但是正如6.2.5将要介绍的，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量到了。

一般来说，如果你认定变量是一个常量表达式，那么就把它声明成constexpr类型。

字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见，容易得到，就把他们称为“字面值类型“

到目前为止接触过的数据类型汇总，算数类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。其他的一些字面值类型将在7.5.6节和19.3节介绍

尽管指针和引用都能定义成constexpr，但他们的初始值却受到严格的限制。一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。

6.1.1节将要提到，函数体内定义的变量一般来说并未存放在固定地址中，因此constexpr指针不能指向这样的变量。相反，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。同样在6.1.1节中害将提到，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量

指针和constexpr

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针指向的对象无关。

```c++
const int *p = nullptr;// p是一个指向整型常量的指针 (底层const
constexpr int *q = nullpr;// q是一个指向整型的常量指针(顶层const
```

p和q的类型相差甚远，p是一个指向常量的指针，q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。

与其他常量指针相似，constexpr指针既可以指向常量也可以指向一个非常量。

```c++
constexpr int *np = nullptr; // np是一个常量指针
int j = 0;
constexpr int i = 23;
// i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向常量i
constexpr int *p1 = &j; // p1是常量指针，指向i
```

### 2.5 处理类型

#### 2.5.1 类型别名

类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚的知道使用该类型的真实目的

有两种方法可用于定义类型别名。传统的方法是使用关键字typedef。

```c++
typedef double wages; //wages是double的同义词
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```

其中，关键字typedef作为声明语句中的基本数据类型的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。

新标准规定了一种新的方法，使用别名名称来定义类型的别名：

```c++
using SI = Sales_item;
```

这种方法用关键字using作为别名的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：

```c++
wages hourly, weekly; // 等价于doubel hourly, weekly;
SI item; // 等价于Sales_item item;
```

指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char*的别名：

```c++
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; // ps是一个指针，它的对象是指向char的常量指针
```

上述两条声明语句基本数据类型都是const pstring ，和过去一样，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring 就是指向char的常量指针，而非指向常量字符的指针

遇到一条使用了类型别名的声明语句是，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义。

```c++
const char *cstr = 0； // 是对const pstring cstr的错误理解
```

再强调一遍，这种理解是错误的。声明语句中用到pstring时，该基本数据类型是指针。可是char\*重写了声明语句后，数据类型就变成了char，*称为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

#### 2.5.2 auto类型说明符

C++新标准引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来哪些只对应一种特定类型的说明符(比如double)不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值。

```c++
// 由val1和val2相加的结果可以推断出item的类型
auto item = val1 + val2;
```

此处编译器将根据val1和val2相加的结果来推断item的类型。如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item；如果这两个对的类型都是double，则item的类型就是double，以此类推

使用auto也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。

```c++
auto i = 0; *p = &i; // 正确，i是整型。p是整型指针
auto sz = 0; pi = 3.14// 错误，sz和pi类型不一致
```

复合类型、常量和auto

编译器推断出来的auto类型有时候和初始值类型并不完全一样，编译器会适当的改变结果类型使其更符合初始化规则。

首先，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的起始是引用对象的值。此时编译器以引用对象的类型作为auto的类型：

```c++
int i = 0, &r = i;
auto a = r; // a是一个整数 r是i的别名，而i是一个整数
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数(ci的顶层const特性被忽略)
auto c = cr; // c是一个整数(cr是ci的别名，ci本身是一个顶层const)
auto d = &i; // d是一个整型指针
auto e = &ci;// e时一个指向整型常量的指针，属于底层const
```

如果希望推断出的auto是一个顶层const，需要明确指出

```c++
const auto f = ci;
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用

```c++
auto &g = ci; // g是一个常量引用，绑定到ci
auto &h = 23; // 错误，不能为非常量引用绑定字面值
const auto &j = 23; //正确 可以为常量引用绑定字面值
```

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。

要在一条语句中定义多个变量，切记，符号&和符号\*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：

```c++
auto k = ci , &l = i; //k是整数，l只是整型引用
auto &m = ci, *p = &ci;// m是引用，p是指向常量的指针
// 错误 i的类型是int而&ci的类型是const int
auto &n = i, *p2 = &ci;
```

#### 2.5.3 decltype类型指示符

有时候 遇到这种情况：希望从表达式的类型判断出想要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并获取到它的类型，却不实际计算它的值：

```c++
decltype(f()) sum = x; // sum的类型就是函数f的返回类型
```

编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的哪个类型。

decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)：

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;// x的类型是const int(ci的类型
decltype(cj) j = x; // y的类型是const int&(cj的类型
decltype(cj) z; // 错误，const int&，引用类型必须初始化
```

需要指出的是，引用从来都作为其所指对象的同义词出现，只有在decltype处是一个例外。

decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节将要介绍的，有些表达式将想decltype返回一个引用类型。一般来说这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值。

```c++
// decltype的结果可以是引用类型
int i = 23, *p = &i, &r = i;
decltype(r+0) b; // 正确，加法的结果是int，所以b是int类型(未初始化)
decltype(*p) c; // 错误: *p即解引用的结果是&i，即int&，必须初始化
```

decltype与auto的另一重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况应当注意对于decltype所用的表达式来说，如果变量名加了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果类型就是改变量的类型；如果给变量加上了一层或多层括号，编译器会把它当成一个表达式。变量时一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：

```c++
// decltype的表达式如果是加上了括号的变量，结果将是引用、
decltype((i)) d; // 错误，d是引用类型，必须初始化
decltype(i) e; // 正确，e是一个int类型
```

切记：decltype((variable))双层括号的结果永远是引用，而decltype(variable)单层括号只有当variable本身是一个引用的时候结果才是引用。

赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。如果i是int类型，则 i=x 的类型是int&。

#### 2.6 自定义数据结构

从最基本的层面理解，数据结构是把一组相关的数据元素组织起来，然后使用他们的策略和方法。举一个例子，我们的Sales_item类把书本的ISBN编号、售出量及销售收入等数据组织在了一起，并提供诸如isbn函数、>>、<<、+、+=等运算在内的一系列操作，Sales_item类就是一个数据结构。

C++允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就想第1张的Sales_item类型一样。C++语言对类的支持甚多，事实上本书的第III部分和第IV部分都将大篇幅地介绍与类有关的知识。尽管Sales_item类非常简单，但是要想给出它的完整定义可在第14章介绍自定义运算符之后。

#### 2.6.1 定义Sales_data类型

尽管我们还写不出玩完整的Sales_item类，但是可以尝试着把那些数据元素组织到一起行程一个简单点儿的类。初步的想法是用户能直接访问其中的数据元素，也能实现一些基本的操作。

既然我们筹划的这个数据结构不带有任何运算功能，不妨把它命名为Sales_data类以示与Sales_item的区别。Sales_data初步定义如下：

```c++
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
```

我们的类以struct关键字开始，紧跟着类名和类体(其中类体部分可以为空)。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。

类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。

```c++
struct Sales_data { /** */ } accum, trans, *salesptr;
// 与上一语句等价，但可能更好一些
struct Sales_data { /** */ };
Sales_data accum, trans, *salesptr;
```

分号表示声明符的结束。一般来说，最好不要把对象的定义和类的定义放在一起，这么做无异于把两种不同的实体定义混在了一条语句里，一会儿定义类，一会儿又定义变量，显然这是一种不被建议的行为。

类数据成员

类体定义类的成员，我们的类只有数据成员。类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他Sales_data的对象。

定义数据成员的方法和定义普通变量一样：首先说明一个基本类型，然后紧跟一个或多个声明符。我们的类有3个数据成员：一个名为bookNo的string成员，一个名为units_sold的unsigned成员和一个名为revenue的double成员。每个Sales_data的对象都将包含着3个数据成员。

C++11新标准规定，可以为数据成员提供一个类内初始值。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。因此当定义Sales_data的对象时，units_sold和revenue都将初始化为0，bookNo将初始化为空字符串。

对类内初始值的限制与之前介绍的类似：或放在或括号里，或者放在等号右边，记住不能使用圆括号。

#### 2.6.2 使用Sales_item类

和Sales_item类不同的是，我们自定义的Sales_data类没有提供任何操作，Sales_data的使用者如果想执行什么操作必须自己手动实现。

```c++
// 两个相加
void add_same()
{
    Sales_data data_all, data;
    if (std::cin >> data.bookNo >> data.units_sold >> data.revenue) {
        data_all = data;
        while (std::cin >> data.bookNo >> data.units_sold >> data.revenue){
            if (data.bookNo == data_all.bookNo) {
                data_all.units_sold += data.units_sold;
                data_all.revenue += data.revenue;
            } else {
                std::cout << "两个不一样" << std::endl;
                return;
            }

        }
    }
    std::cout << "BookNo: " << data_all.bookNo
              << "\nUnits Sold: " << data_all.units_sold
              << "\nRevenue: " << data_all.revenue
              << std::endl;
}
// 多个相加
void add_all()
{
    Sales_data data_all, data;
    if (std::cin >> data.bookNo >> data.units_sold >> data.revenue) {
        data_all = data;
        while (std::cin >> data.bookNo >> data.units_sold >> data.revenue){
            if (data.bookNo == data_all.bookNo) {
                data_all.units_sold += data.units_sold;
                data_all.revenue += data.revenue;
            } else {
                std::cout << "BookNo: " << data_all.bookNo
                          << "\tUnits Sold: " << data_all.units_sold
                          << "\tRevenue: " << data_all.revenue
                          << "\tAvg: " << data_all.revenue / data_all.units_sold
                          << std::endl;
                data_all.bookNo = data.bookNo;
                data_all.units_sold = data.units_sold;
                data_all.revenue = data.revenue;
            }

        }
    }
    std::cout << "BookNo: " << data_all.bookNo
              << "\tUnits Sold: " << data_all.units_sold
              << "\tRevenue: " << data_all.revenue
              << "\tAvg: " << data_all.revenue / data_all.units_sold
              << std::endl;
}
```

#### 2.6.3 编写自己的头文件

尽管如19.7所讲可以在函数体内定义类，但是这样的类毕竟受到了一些限制。所以，类一般都不定义在函数体内。当在函数体外部定义类时，在各个指定的源文件中可能只有一处该类的定义。而且，如果要在不同文件中使用同一个类，类的定义就必须保持一致。

为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如库类型string在名为string的头文件中定义。又如，我们应该把Sales_data定义在名为Sales_data.h的头文件中。

头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。头文件也经常用到其他头文件的功能，例如我们的Sales_data类包含一个string成员，所以Sales_data.h必须包含string.h头文件。同时，使用Sales_data类的程序为了能操作bookNo成员需要再一次包含string,h头文件。

这样，事实上使用Sales_data类的程序就先后包含了两次string.h头文件：一次是直接包含的，另有一次是随着包含Sales_data.h被隐式地包含进来的。有必要在书写头文件时做适当处理，使其遇到多次包含的情况下也能安全和正常的工作。

> 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明

预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分的改变我们所写的程序。之前已经用到一项预处理器的功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。

C++程序还会用到的一项预处理功能是头文件保护符，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指令的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**#ifndef**当且仅当变量未定义时为真。一旦结果检查为真，则执行后续操作直至遇到**#endif**为止。

使用这些功能就能有效的防止重复包含的发生：

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```

第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到endif为止。此时预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，则ifndef的结果为假，编译器将忽略ifndef到endif之间的部分

> 预处理器变量无视C++语言中关于作用域的规则

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中其他实体发生名字冲突，一般把预处理变量的名字全部大写。

> 头文件及时(目前还)没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只需要习惯性的加上就可以了，没必要太在乎你的程序到底需不需要

## 3 字符串、向量和数组

第2章介绍的内置类型是由C++语言直接定义的。这些类型，比如数字或字符，体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，他们尚未直接实现到计算机硬件中。

本章将介绍两种最重要的标准库类型：string和vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型，和其他内置类型一样，数组的实现与硬件密切相关，因此相较于标准库类型string和vector，数组在灵活性上稍显不足。

在开始介绍标准库类型之前，先来学习一种访问库中名字的简单方法。

### 3.1 命名空间的using声明

std::cin中是用作用域操作符::的含义是：编译器从左侧名字所示的作用域中寻找右侧那个名字。因此，std::cin的意思就是要使用命名空间std中的名字cin。更简单的最安全办法就是使用using。

有了using声明就无需专门的前缀(形如命名空间::)也能使用所需的名字了。using声明具有如下的形式:

```c++
using namespace::name;
```

一旦声明了上述语句，就可以直接访问命名空间终端名字

```c++
#include <iostream>
// using声明，当我们使用名字cin时，从std命名空间中获取它
using std::cin;
int main()
{
    int i;
    cin >> i; // 正确
    cout << i; // 错误
    std::cout >> i; //正确
    return 0;
}
```

每个名字都需要独立的using声明

按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using声明的形式表示出来：

```
#include <iostream>
using std::cin;
using std::cout; using std::endl;
int main()
{
    int i;
    cin >> i;
    cout << i << endl; 
    return 0;
}
```

C++的形式比较自由，因此既可以一行只放一条声明语句，也可以一行放多条。不过要注意，用到的每个名字都必须要有自己的声明语句，而且每个名字都得以分号结束。

头文件不应包含using声明

位于头文件的代码，一般来说不用管使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件中有某个using声明，那么每个使用了该头文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能会产生始料未及的名字冲突。

### 3.2 标准库类型string

标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例都假定已包含了以下代码：

```c++
#include <string>
using std:;string;
```

本节描述最常用的string操作，9.5节还有将介绍另外一些

C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。

#### 3.2.1 定义和初始化string对象

如何初始化类的对象是由类本身决定的。一个类可以定义很多初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。表3.1列出了初始化string对象最常用的一些方式，下面是几个例子。

```c++
string s1;// 默认初始化，是个空字符串
string s2 = s1;	// s2是s1的副本
string s3 = "helloworld"; // s3是字符串字面值的副本
string s4(10, 'c');// s4的内容是cccccccccc
```

可以通过默认的方式初始化一个string对象，这样就会得到一个空的string，也就是说，该string对象没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去。如果提供的是一个数字和一个字符，则string对象的内容是给定字符连续重复若干次后得到的序列。

表3.1 初始化string对象的方式

```c++
string s1;				// 默认初始化，s1是个空串
string s2(s1);			// s2是s1的副本
string s3 = s1;			// 等价于s2(s1),s3是s1的副本
string s4("value");		// s4是字面值value的副本，除最后的空字符
string s5 = "value";	// 同上一行，s5是字面值value的副本
string s6(n, 'c');		// 把s6初始化为由连续n个字符c组成的字符串
```

直接初始化和拷贝初始化

C++语言有几种不同的初始化方式，通过string我们可以看到这些初始化方式之间有什么区别和联系。如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把右侧的初始值拷贝到右侧新创建的对象中区。与之相反，如果不使用等号，则执行的是直接初始化。

当初始值只有一个时，使用直接初始化或者拷贝初始化都行，如果像s6那样初始化要用到的值由多个，一般来说只能使用直接初始化的方式。

```c++
string s7 = "hello"; // 拷贝初始化
string s8("hello"); // 直接初始化
string s9(10, 'c'); // 直接初始化
```

对于用多个值初始化的情况，非要用拷贝初始化的方式处理也不是不可以，不过需要显示的创建一个(临时)对象用于拷贝：

```c++
string s10 = string(10, 'c'); // 拷贝初始化, ’cccccccccc‘
```

这里实际上是先创建了一个string对象，然后拷贝给s10。本质上等于下面的两条语句：

```c++
string temp(10, 'c');
string s10 = temp;
```

其实我们可以看到，尽管初始化s10的语句合法，但和初始化s9的方式比起来可读性较差，也没有任何补偿优势。

#### 3.2.2 string对象上的操作

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，就像Sales_item类的isbn函数那样，也能定义<<、+等各种运算符在该类对象上的新含义。表3.2中列举了string上的大多数操作。

表3.2 string的操作

```c++
os << s;		// 将s写到输出流os中，返回os
is >> s;		// 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s);	// 从is中读取一行赋给s，返回is
s.empty();		// s为空返回true，否则false
s.size();		// 返回s中字符的个数
s[n];			// 返回s中第n个字符的引用，位置n从0计起
s1+s2;			// 返回s1和s2连接后的结果
s1=s2;			// 用s2的副本代替s1中原来的字符
s1==s2;			// 如果s1和s2字符完全一样，则相等，对字母大小写敏感
s1!=s2;			// 字符不完全一样，则不相等
<,<=,>,>=		// 利用字符在字典中的顺序进行比较，且对大小写字符敏感
```

读写string对象

使用标准库中的iostream来读写int、double等内置类型的值，同样，也可以使用IO操作来读取string对象。

```c++
int main()
{
    string s1, s2;
    cin >> s1 >> s2;
    cout << s1 << s2 << endl;
    return 0;
}
```

在执行读取操作时，string对象会自动忽略开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符读起，知道遇见下一处空白为止。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写到一起。

读取未知数量的string对象

```c++
string s;
while(cin >> s)
    cout << s << endl;
```

使用getline读取一整行

有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数替代原来的>>运算符。getline函数的参数是一个输入流合一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存在换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕一开始就是换行符也是如此，那么所得的结果是个空string

和输入运算一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline作为条件。例如，我们可以通过改写之前的程序让他一次输出一整行，而不是每行输出一个词了：

```c++
string s;
while(getline(cin, s))
    cout << s << endl;
```

因为s中不包含换行符，所以我们手动的加上换行操作符。和往常一样，使用endl结束当前行并刷新显示缓冲区。

触发getline函数返回的哪个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。

string的empty和size操作

顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值。和Sales_item类的isbn成员一样，empty也是string的一个成员函数。调用该函数的方法很简单。只需要使用点操作符指明是哪个对象执行了empty函数就可以了。

通过改写之前的程序，可以做到只输出非空的行：

```c++
string s;
while(getline(cin, s))
    if (!s.empty())
        cout << s.size() << "\t" << s << endl;
```

在上面的程序中，if语句的条件部分使用了逻辑非运算符(!)，它返回与其运算对象相反的结果。此例中，如果str不为空则返回真。

size函数返回string对象的长度(即string对象中字符的个数。)

string::size_type类型

对于size函数来说，返回一个int或者如前面2.1.1节所述的那也返回一个unsigned似乎都是合情合理的。但其实size函数返回的是一个string::size_type类型的值，下面就对这种新的类型稍作解释。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性。类型size_type即是其中一种。具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。

尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的：它是一个无符号类型的值而且能够放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的。

过去，string::size_type这种类型有点儿神秘，不太容易理解和使用。在C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型:

```c++
auto len = line.size();
```

由于size函数返回的是一个无符号整形数，切记如果表达式中混用了带符号数和无符号数将可能产生意想不到的后果。例如，假设n是一个具有负值的int，则表达式s.size()<n的判断几乎肯定是true。这是因为负值n会自动转换成一个比较大的无符号值。

> 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。

比较string对象

string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感，也就是说，在比较时同一个字母的大小写是不同的。

相等性运算符(==和!=)分别检验两个string对象相等或不相等。string对象相等意味着它们的长度相等而且包含的字符也完全相同。关系运算符<，<=，>，>=分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个对象。上述这些运算符都依照大小写敏感的字典顺序：

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象
2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一队相异字符比较的结果

```c++
string str = "Hello";
string phrase = "Hello world";
string slang = "Hiya";
```

根据规则1判断，对象str小于对象phrase，根据规则2判断，slang大于phrase也大于str。

为string对象赋值

一般来说，在设计标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类型都支持赋值操作。对于string而言，允许把一个对象的值赋给另一个对象：

```c++
string st1(10, 'c'), st2;
st1 = st2; // 赋值，用st2的副本替换st1的内容，此时，两者皆为空
```

两个string对象相加

两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象拼接而成。也就是说，对string对象使用加法运算符(+)的结果是一个新的string对象，它所包含的字符是由两部分组成：前半部分是加号左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。另外，复合赋值运算符(+=)负责把右侧string对象的内容追加到左侧string对象的后面：

```c++
string s1 = "hello, ", s2 = "wirld\n";
string s3 = s1 + s2; // s3的内容是hello, world\n
s1 += s2; // s1的内容同s3
```

字面值和string对象相加

及时一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。利用这一点将之前的形式改写为以下形式：

```c++
string s1 = "hello", s2 = "world"; // s1,s2都没有标点符号
strinfg s3 = s1 + ", " + s2 + "\n";
```

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须缺包每个加法运算符(+)的两侧的运算对象至少有一个是string:

```c++
string s4 = s1 + ", "; // 正确
string s5 = "hello" + ", "; // 错误，两个运算对象都不是string
// 正确，每个加法运算符都有一个运算对象是string
string s6 = s1 + ", " + "world";
string s7 = "hello" + ", " + s2; // 错误，不能将字面值直接相加
```

s6的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出是一样的。

> 由于历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。

#### 3.2.3 处理string对象中的字符

表3.3 cctype头文件中的函数

```c++
isalnum(c);		// c是字母或数字时为真
isalpha(c);		// c是字母时为真
iscntrl(c);		// c是控制字符时为真
isdigit(c);		// c是数字时为真
isgraph(c);		// c不是空格但可打印时为真
islower(c);		// c是小写字母时为真
isprint(c);		// c是可打印字符时为真(c是空格或可视形式)
ispunct(c);		// c是标点符号时为真(c不是控制字符、数字、字母、可打印空白中的一种)
isspace(c);		// c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)
isupper(c);		// c是大写字母时为真
isxdigit(c);	// c是十六进制数字时为真
tolower(c);		// 如果c是大写字母，输出对应的小写字母，否则原样输出
toupper(c);		// 如果c是小写字母，输出对应的大写字母，否则原样输出
```

> 建议：使用c++版本的c标准库头文件
>
> ------
>
> C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，c++则将这些文件命名为cname，也就是去掉了.h后缀，而在name前面添加了字母c，这里的c表示这是一个属于C语言标准库的头文件
>
> 因此cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合c++语言的要求，特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然
>
> 一般来说C++程序应该使用cname的头文件而不使用name.h形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记那些是从c语言来的，那些是c++所独有的。

处理每个字符？使用基于范围的for语句

如果想对string的每个字符做点儿什么操作，目前最好的办法是使用c++11新标准提供的范围for语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：

```c++
for (declaration : expression)
    statement
```

其中expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量都会被初始化为expression部分的下一个元素值。

一个string对象表示一个字符的序列，所以string对象可以作为范围for语句的expression部分。举一个简单的例子，我们可以吧string对象中每一个字符按行输出出来。

```c++
string str("Hello, world!");
for (auto c : str)
    cout << c << endl;
```

auto关键字自动推断c的类型，这里c是char。该循环可以读做对于字符串str中的每个字符c，执行某某操作。

```c++
string s;
getline(cin, s);
decltype(s.size()) punct_count = 0;
for (auto c : s){
    if (ispunct(c))
        punct_count++;
}
cout << "标点符号数量：" << punct_count << endl;
```

使用范围for语句改变字符串中的字符

想要改变string对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变他绑定的字符。

新的例子，将字符串改写为大写字母的形式。为了做到这一点，我们使用库函数toupper，该函数接受一个字符，输出其大写形式。这样，为了把整个string对象全部转换成大写，只要对其中每个字符调用toupper函数并将结果赋给原字符即可。

```c++
string str("Hello, world!");
for (auto &c : str)
    c = toupper(c);
```

只处理一部分字符？

如果要处理string对象中的每一个字符，使用范围for是个好主意。然而，有时我们需要访问的只是其中一个字符，或者访问多个字符但遇到某个条件就要停下来。例如，同样是将字符改为大写，不过新的要求不再是对整个字符串都这样做，而仅仅是把string对象中第一个字母或单词大写。

要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是迭代器，其中关于迭代器的内容将在3.4节和第9章介绍。

下标运算符\[\]接收的参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。

string对象的下标从0计起，最后一个是string.size()-1。string对象的下标必须大于等于0而小于string.size()。使用超出范围的下标会引发不可预知的结果。

下标的值乘坐下标或索引，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。

下面的程序使用下标运算符输出string对象的第一个字符：

```c++
if (!s.empty)
    cout << s[0] << endl;
```

在访问指定字符前，首先检查s是否为空。其实不管什么时候只要对string对象使用了下标，都要确定那个位置上有值。如果s为空，则s[0]的结果是未定义的。

只要字符串不是常量，就能为下标运算符返回的字符赋新值。

使用下标执行迭代

```c++
for (decltype(s.size()) index = 0;
     index != s.size() && !isspace(s[index]);
     ++index)
    s[index] = toupper(s[index]);
```

逻辑与运算符：最重要的一点是,C++语言规定只有当左侧为真时才会检测右侧运算对象的情况。

> 注意下标的合法性
>
> 使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的size()的值。一种简便易行的办法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。

使用下标执行随机访问

一段程序将0-15转换成16进制：

```c++
string hex="0123456789abcdef";
decltype(hex.size()) index;
while (cin >> index) {
    if (index >=0 && index < 16)
        cout << hex[index];
    else
        cout << "Error, number(0-15)."
}
cout << endl;
```

### 3.3 标准库类型vector

标准库类型表示对象的集合，其中所有对象的类型都相同。集合中对每个对象都有一个与之相对于的索引，索引用于访问对象。因为vector容纳着其他对象，所以它常被称作容器。

要想使用vector，必须包含合适的头文件，在后续的例子中都将假设做了如下using声明：

```c++
#include <vector>
using std::vector;
```

C++语言既有类模板，也有函数模板，其中vector是一个类模板。只有对C++有了相当深入的理解才能写出模板。事实上，我们到第16章菜户学习如何自定义模板。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一堆尖括号，在括号内放上信息。

以vector为例，提供的额外信息是vector内存放对象的类型：

```c++
vector<int> ivec; // ivec保存int类型的对象
vector<Sales_item> Sales_ivec; // 保存Sales_item类型的对象
vector<vector<string>> file; // 该向量保存的是vector对象
```

> vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector对象，甚至组成vector的元素也可以是vector。

需要指出的是，在早期版本的C++标准中如果vector的元素还是vector(或者是其他模板类型)，需要在外层vector对象的右尖括号与其元素之间添加一个空格。如vector\<vector\<string\>\>应写成vector\<vector\<string\> \>。

#### 3.3.1 定义和初始化vector对象

和任意类型一样，vector模板控制着定义和初始化向量的方法。

表3.4：初始化vector对象的方法

```c++
vector<T> v1;			// 空vector，元素T类型，默认初始化
vector<T> v2(v1);		// 包含有v1所有元素的副本
vector<T> v2 = v1;		// 等价于v2(v1)
vector<T> v3(n, val);	// 包含n个T类型元素，值都为val
vector<T> v4(n);		// 包含n个T类型元素，元素值初始化
vector<T> v5{a,b,c};	// 包含了初始值个数的元素，每个元素赋初值
vector<T> v5 = {a,b,c};	// 等价于v5{a,b,c}
```

可以默认初始化vector对象，这样可以创建一个指定类型的空vector。最长间的办法即是如此，然后再逐一添加需要的元素。

```c++
vector<T> v1; // 默认初始化，svec不含任何元素
```

当然也可以在定义vector对象时指定元素的初始值。例如把一个vector对象的元素拷贝给另一个vector对象。此时，新vector对象的元素就是原vector对象的副本。注意两个副本的对象必须相同。

```c++
vector<int> ivec; // 初始状态为空
// 在此处给ivec添加一些值
vactor<int> ivec2(ivec);//把ivec的元素拷贝给ivec2
vector<int> ivec3 = ivec;//把ivec的元素拷贝给ivec3
vector<string> svec(ivec);//错误，类型不同
```

列表初始化vector对象

C++11新标准提供列表初始化。此用花括号括起来的0个或多个初始元素值被赋给vector对象。（必须是花括号

```c++
vector<T> v5 = {a,b,c};
```

在大多数情况下C++初始化vector对象的方法可以相互等价的使用，不过也并非一直如此。目前已经介绍的两种例外情况是：其一，使用拷贝初始化时(即使用=时)，只能提供一个初始值。其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值放在花括号里进行列表初始化，不能放在圆括号里。如

```c++
vector<int> v1{1,2,3};//正确 列表初始化
vector<int> v1(1,2,3);//错误
```

创建指定数量的元素

```c++
vector<T> v3(n, val);
```

值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

如果vector对象的元素是内置类型，如int，则元素初始值为0，如果元素是某种类类型，比如string，则元素由类默认初始化。

```c++
vector<T> v4(n);
```

对这种初始化的方式有两个特殊限制，其一，有些类要求必须明确的提供初始值。其二，如果值提供了元素的数量而没有设定初始值，只能使用直接初始化，而不是拷贝初始化。

列表初始值还是元素数量？

在某些情况下，初始值的真实含义依赖于传递初始值时用的是花括号还是圆括号。例如

```c++
vector<int> v1(10);		// 初始化10个元素，每个元素都是0
vector<int> v1{10};		// 初始化1个元素，值为10

vector<int> v2(10, 11);	// 初始化10个元素，每个元素都是11
vector<int> v2{10, 11};	// 初始化2个元素，值为10和11
```

如果是用的是圆括号，可以说提供的值是用来构造vector对象的。如果用的是花括号，可以表述成我们想列表初始化该vector对象。

另一方面，如果初始化时使用了花括号的形式但提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。

```c++
vector<string> v5{"hi"}; //列表初始化，1个元素
vector<string> v6("hi"); //错误，字符串字面值不能初始化vector
vector<string> v7{10};	 //v7有10个默认初始化的元素
vector<string> v8{10, "hi"};//v8有10个初始值为hi的元素
```

#### 3.3.2 向vector对象中添加元素

对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个vector对象的副本、所有元素的初始值都一样。然而更常见的情况是，创建一个vector对象时并不清楚实际所需元素个数，元素的值也经常无法确定。还有些时候即使元素初值已知，但如果这些值总量较大而且各不相同，那么在创建vector对象的时候执行初始化操作也会咸的过于繁琐。

可以创建一个空vector，然后再使用vector的成员函数push_back向其中天机暗元素。push_back负责把一个值当成vector对象的尾元素push到vector对象的尾端back。

```c++
vector<int> ivec;
for (int i=0; i< 100;++i)
    ivec.push_back(i);
// 结束后ivec内存在100个值，0-99
```

> 关键概念：vector对象能高效增长
>
> C++标准要求vector应该能在运行时高效的快速添加元素。因此既然vector对象能高效的增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实上如果这么做可能性能会更差。只有一张例外情况，就是所有元素的值都一样。一旦元素的值有所不同，更有效的办法就是先定义一个空的vector对象，在运行时向其中添加具体值。此外，9.4节还将介绍，vector害提供了方法，允许我们进一步提升动态添加元素的可能

向vector对象添加元素蕴含的编程假定

必须要保证确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。

如果循环体内部包含有vector对象添加元素的语句，则不能使用范围for循环，今天原因在5.4.3详细解释。

> 范围for循环语句体内不应该改变其所遍历序列的大小

#### 3.3.3 其他vector操作

除了push_back外，vector还提供了其他几种操作，大多数都和string的相关操作类似，表3.5列出了部分重要的一些。

表3.5：vector支持的操作

```c++
v.empty();	// 如果v不含有任何元素，返回真，否则返回假
v.size();	// 返回v中元素的个数
v.push_back(t);// 向v的尾端添加一个值为t的元素
v[n];		// 返回v中第n个位置上元素的引用
v1 = v2;	// 用v2中元素的拷贝替换v1的元素
v1 = {a,b,c...};// 用列表的元素的拷贝替换v1的元素
v1 == v2;	// v1和v2相等当且仅当他们元素数量相同且对应位置的元素相同
v1 != v2;	// 
<,<=,>,>=	// 顾名思义，以字典顺序进行比较
```

访问vector对象中元素的方法和访问string对象中字符的方法差不多，也是通过元素在vector对象中的位置。例如，可以使用范围for语句处理vector对象中的所有元素：

```c++
vector<int> ivec{1,2,3,4,5};
for(auto &i:ivec)
    i *= i
```

vector的empty和size两个成员与string的同名成员功能完全一致：empty返回vector对象是否包含元素然后返回一个布尔值；size则返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型

> 要是用size_type，需首先指定它是由那种类型定义的。vector对象的类型总是包含着元素的类型
>
> vector\<int\>::size_type //正确
>
> vector::size_type //错误

各个相等性运算符和关系运算符也与string的相应运算符功能一致。只有当元素的值可比较时，vector对象才能被比较。

计算vector内对象的索引

使用下标运算符可以获取到指定的元素。和string一样，vector的下标也是从0开始，下标的类型是相应的size_type类型。只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。也能通过计算得到vector内对象的索引，然后直接获取到索引位置上的元素。

```c++
// 以10分为一个分数段统计成绩的数量：0-9,10-19,...,90-99,100
vector<unsigned> score(11,0);//11个分数段，全部初始化为0
unsigned grade;
while(cin >> grade)
    if (grade <= 100)	//只处理有效的成绩
        ++score[grade/10];//将计数值+1
```

需要注意的是，我们要确认下标计算后在范围之内。

不能用下标形式添加元素。只能使用push_back。

> vector对象(以及string对象)的下标运算符可用于访问已存在的元素，而不能用于添加元素

> 切记，只能对确切已存在的元素执行下标操作
>
> 试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。这个也叫缓冲区移除(buffer overflow)，这也是导致PC以及其他设备上应用出现安全问题的一个重要原因。
>
> 规避的一种有效手段就是尽可能使用范围for语句

### 3.4 迭代器介绍

我们已经知道可以使用下标运算符来访问string和vector对象的字符或元素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器。在第II部分将要介绍，除了vector之外，标准库还定义了其他几种容器。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。严格来说，string对象不属于容器类型，但是string指出很多和容器类型类似的操作。vector支持下标运算符，这点和string一样；string支持迭代器，这也和vector是一样的。

类似于真类型，迭代器也提供了对对象的间接访问。就是迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也可以从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器组尾元素的下一位置；其他情况都属于无效。

#### 3.4.1 使用迭代器

 和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素(或第一个字符)的迭代器，如有下述语句：

```c++
// 由编译器决定b和e的类型
// b表示v的第一个元素，e表示v尾元素的下一位置
auto b = v.begin(), e = v.end();// b和e的类型相同
```

end成员则负责返回指向容器(或string对象)尾元素的下一位置的迭代器，也就是说，该迭代器指示的是容器一个本不存在的尾后元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称为尾后迭代器或者简称为尾迭代器。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。

一般来说，我们不清楚(不在意)迭代器准确的类型是什么。例子就是用auto定义关键字b和e。

迭代器运算符

表3.6列举了迭代器支持的一些运算，使用==和!=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等，反之不等。

表3.6：标准容器迭代器的运算符

```c++
*iter; // 返回迭代器iter所指元素的引用
item->mem; // 解引用iter并获取该元素名为mem的成员=(*item).men
++iter;	// 令iter指向容器中下一个元素
--iter;	// 令iter指向容器中上一个元素 
iter1 == iter2;// 如果两个迭代器指向的元素相同或者都是同一个容器的尾
iter1 != iter2;// 后迭代器，则他们相等，反之不等。
```

和指针相似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指向某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。

将迭代器从一个元素移动到另一个元素

迭代器使用++递增运算符来从一个元素一动都爱下一个元素，从逻辑上来说，迭代器的递增和整数的递增类型，整数的递增是在整数值上加1，迭代器的递增则是将迭代器向前移动一个位置。

> 因为尾迭代器并不指向某个元素，所以不能对齐进行递增或解引用的操作，
>
> 泛型编程：**for循环中更适用!=，因为!=运算符在所有容器中都适用。**

迭代器类型

就想不知道string和vector的size_type成员到底是什么类型一样，一般来说我们也不知道(其实是无需知道)迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：

```c++
vector<int>::iterator it; // it能读写vector<int>的元素
string::iterator it2; // it2能读写string对象中的字符

vector<int>::const_iterator it3; // it3只能读元素，不能写元素
string::const_iterator it4; // it4只能读字符，不能写字符
```

const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既可以使用iterator也能使用const_iterator。

> 迭代器和迭代器类型
>
> 迭代器这个名字有三个不同的含义：可能是迭代器概念本身，也可能指容器定义的迭代器类型，还可能指某个迭代器对象
>
> 重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另一个元素。
>
> 每个容器类定义了一个名叫iterator的类型，该类型支持迭代器概念所规定的一套操作。

begin和end运算符

begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，那么返回const_iterator；如果不是常量则返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto iv1 = v.begin();//it1的类型是vector<int>::iterator
auto iv2 = cv.begin();//it2的类型是vector<int>::const_iterator
```

有时候这种默认的行为并非我们所要，在6.2.3节中将会看到，如果对象只需读操作而无需写操作的话最好使用常量类型const_iterator，为了便于专门得到const_iterator类型的返回值，c++11引入了两个新函数，cbegin和cend：

```c++
auto it3 = v.cbegin();
```

类似begin和end，新函数也是返回指示容器的第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector或string对象本身是否是常量，返回值都是const_iterator。

结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，想要检查其元素是否为空，令it是该对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下所示：

```c++
(*it).empty()
```

其中\*it的圆括号必不可少。该表达式先对it进行解引用，再访问解引用后的对象的成员。如果不加圆括号，则点运算符由it来执行，迭代器没有empty成员，则报错。

为了简化上述表达式，C++定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说`it->mem`和`(*it).mem`是一个意思。

某些对vector对象的操作会使迭代器失效

3.3.2节曾经介绍过，虽然vector对象可以动态增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，不如push_back，都会使该vector对象的迭代器失效。9.3.6节将详细解释迭代器是如何失效的。

#### 3.4.2 迭代器运算

迭代器的递增运算令迭代器每次移动一个元素。所有标准库容器都有支持递增运算的迭代器。类似的，也能用==和!=对任意标准库类型的两个有效迭代器进行比较。

string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算。

表3.7: vector和string迭代器支持的运算

```c++
iter + n; // 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的元素，或者指示容器尾元素的下一位置
iter - n; // 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的元素，或者指示容器尾元素的下一位置
iter1 += n; // 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1
iter1 -= n; // 迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1
iter1 - iter2; // 两个迭代器相减的结果是他们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须是指向同一个容器中的元素或者尾元素的下一位置
>、>=、<、<=; // 迭代器的关系运算符，如果某迭代器指向的容器位置在另一迭代器所指的位置之前，则说前者小于后者。参与运算的两个迭代器必须是指向同一个容器中的元素或者尾元素的下一位置
```

迭代器的算术运算

计算最接近vi中间位置的一个迭代器

```c++
auto mid = vi.begin() + vi.size() / 2
```

两个迭代器之间的所谓距离，指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可负可正，所以difference_type是带符号的。

使用迭代器运算

使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。

```c++
// 二分搜索(二分查找法
int two_search(vector<int> *v, int number)
{
    auto beg = v->cbegin(), end = v->cend();
    auto mid = beg + v->size()/2;
    while (mid != end && *mid != number) {
        if (*mid > number)
            end = mid; // 正常思维是mid-1，但end本身指向下一个元素，所以正确应该是mid-1+1即mid
        else
            beg = mid + 1;
        mid = beg + (end - beg)/2;//因为是迭代器，所以不能beg+end,这样就超过vector容量了
    }
    if (mid == end) {
        cout << "没有该元素" << endl;
        return -1;
    }
    return mid - v->cbegin();
}
```

### 3.5 数组

数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但也相应的损失了一些灵活性。

> 如无法确定元素的个数，请使用vector

#### 3.5.1 定义和初始化内置数组

数组是一种复合类型。数组的声明形如a[d]，其中a是数组名字，d是数组的维度，维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也是属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式：

```c++
unsigned cnt = 23;
constexpr unsigned sz = 34;
int arr[10]; // 含有10个整数的数组
int *parr[sz]; // 含有23和整型指针的数组；
string bad[cnt]; // 错误，cnt不是常量表达式
string strs[get_size()]; // 当get_size()是constexpr时正确
```

默认情况下，数组的元素会被初始化

> 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

显示的初始化数组元素

可以对数组元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，初始值的总数量不能超过。如果维度比提供的元素数量大，则提供的初始值初始化靠前的元素，后面的元素还是采用默认初始化。

```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; // 含有3个元素的数组,初始值为0,1,2
int a2[] = {0,1,2}; // 含有3个元素的数组,初始值为0,1,2
int a3[5] = {0,1,2}; // 等价于a3={0,1,2,0,0}
string a4[3] = {"hi", "bye"}; // 等价于a4={"hi", "bye", ""}
int a5[2] = {0, 1, 2};//错误，初始值过多
```

字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以使用字符串字面值对此类数组进行初始化。当使用这种形式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

```c++
char a1[] = {'C','+','+'}; //列表初始化，没有空字符
char a2[] = {'C','+','+','\0'}; //列表初始化，含有显式的空字符
char a3[] = "C++"; // 自动添加表示字符串结束的空字符
const char a4[4] = "ahan"; // 错误，没有空间存放空字符
```

不允许拷贝和负值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] = {0, 1, 2}; // 含有3个整数的数组
int a2[] = a; //错误：不允许使用一个数组初始化另一个数组
a2 = a;//错误，不允许把一个数组直接赋值给另一个数组
```

> 一些编译器支持数组的赋值，这就是所谓的编译器拓展。但一般来说，最好避免使用非标准特性，因为有非标准特性的程序很可能在其他编译器上无法工作

理解复杂的数组声明

和vector一样，数组能存放大多数类型的对象。例如可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：

```c++
int *ptrs[10]; // ptrs数组含有10个整型指针
int &refs[10] = /* ? */; // 错误，不存在引用的数组
int (*parray)[10] = &arr; // 指向一个含有10个整型元素的数组
int (&arrRef)[10] = arr; // 引用一个含有10个整型元素的数组
```

默认情况下，类型修饰符从右到左依次绑定。对于ptrs来说，从右到左理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字时ptrs，然后知道数组中存放的是指针。

但是对于parray来说，从右往左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读比从右向左阅读要合理多了。从内向外的顺序可帮助我们更好的理解parray的含义：首先是圆括号括起来的部分，*parray意味着parray是一个指针，接下来看右边，可知parray是个指向大小为10的数组的指针，最后看左边，可知数组的元素是int。

当然，对修饰符的数量没有限制：

```c++
int *(&array)[10] = ptrs; // array是数组的引用，引用10个指针元素的数组
```

#### 3.5.2 访问数组元素

与标准库类型vector和string一样，数组的远古三也能使用范围for语句或下标运算符来访问。数组的索引从0开始。

使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计的足够大一遍能表示内存中任意对象的大小，在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的c++语言版本。

数组除了大小固定这一特点外，其他用法与vector基本类似。

与vector和string一样，当需要便利数组的所有元素时，最好的办法也是使用范围for语句。因为维度是数组类型的一部分，所以系统知道数组中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担

检查下标的值

数组的下标是否在合理范围之内由程序员负责检查，合理即下标应该大于等于0且小于数组的大小。

#### 3.5.3 指针和数组

在C++语言中，指针和数组有非常紧密的关系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。

通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：

```c++
string nums[] = {"one", "two", "three"};//数组的元素是string
string *p = &nums[0];//p指向nums的第一个元素
```

然而，数组还有一个特性，在个很多用到数组名字的地方，编译器会自动将其特换为一个指向数组首元素的指针：

```c++
string *p2 = nums; // 等价于&nums[0]
```

> 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐藏的意义。其中一层是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是指向第一个元素的指针
ia2 = 23;//错误，ia2是一个指针
```

使用数组作为初始值时，编译器实际上执行的初始化过程类似：

```c++
auto ia2(&ia[0]);// 即ia2是一个int *类型
```

必须要指出的是，当使用decltype关键字时不会发生上述过程，该是数组就还是数组。

```c++
decltype(ia) ia3 = {0,1,2,3,4};//ia3是一个int数组
```

指针也是迭代器

与2.3.2节介绍的内容相比，指向数组元素的指针拥有更多功能。vector和string的迭代器支持的运算，数组的指针全部支持。例如。允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```c++
int arr[] = {0,1,2,3,4,5};
int *p = arr;
++p;// 将指针从arr[0]指向arr[1]
```

就像迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先获取到指向数组第一个元素的指针和数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针，不过获取尾后指针就需要用到数组的另外一个特殊性质了。我们可以设法获取到数组尾元素之后的哪个并不存在的地址：

```c++
int *e = &arr[5];
```

arr一共5个元素，尾元素索引为4，往后一个不存在的元素就是提供其地址用于初始化e。就想尾后迭代器一样，尾后指针也不指向具体的元素。因此不能对尾后指针进行解引用或递增的操作。

```c++
for(int p = arr; p != e; ++p)
    cout << *p << endl;
```

标准库函数begin和end

尽管能计算得到尾后指针。为了让指针的使用更简单、更安全，c++11引用了两个名为begin和end的函数。这两个函数与容器中的两个同名成员函数功能类似，但数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数。

```c++
int ia[] = {1,2,3,4,5};
int *beg = begin(ia);
int *last = end(ia); // 尾后指针
```

循环例子，找出数组中的负数

```c++
int *pbeg = begin(arr), *plast = end(arr);
while (pbeg != plast && *plast >= 0)
    ++pbeg;
```

指针运算

指向数组元素的指针可以执行表3.6和表3.7列出的所有迭代器运算。这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。

两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。

只要两个指针指向同一个数组的元素，或者是该数组的尾后指针，就能利用关系运算符进行比较：

```c++
int *b = arr, *e = arr + sz;
while (b < e)
    ++b
```

如果两个指针分别指向不同对象，则不能比较他们。

必须说明：上述指针运算同样适用于空指针和所指对象并非数组的指针。在后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。俩个空指针也允许彼此相减，结果当然是0.

解引用和指针运算的交互

指针加上一个整数所得的结果还是指针。假设结果指针指向了一个元素，则允许解引用这个结果指针。

```c++
int ia[] = {0,2,4,6,8};
int last = *(ia+4); // 正确，ia+4 即ia[4]=8
```

3.4.1节介绍过，如果表达式含有解引用运算符和点运算符，最好在必要的地方加上圆括号。类似的，此例中加法的括号也不可缺少。

```c++
int last2 = *ia + 4;// 那么*ia=0，结果last2就是0+4=8
```

下标和指针

如前所述，在很多情况下使用数组的名字只是使用数组首元素的指针。一个典型的例子是当对数组使用下标运算时，编译器会自动执行上述转换操作，给定

```c++
int ia[] = {0,2,,4,6,8};
```

此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算实际上是对指向数组元素的指针执行下标运算。

```c++
ing i = ia[2]; // ia转换为首元素指针，ia[2]得到(ia+2)所指的元素
int *p = ia;// p指向ia的首元素
i = *(p+2);// i=4，即ia[2]
```

只要指针指向的是数组中的元素(或数组尾元素的下一位置)，都可以执行下标运算。

```c++
int *p = &ia[2];//p指向索引为2的元素
int j = p[1]; // p[1]等价于*(p+1),即ia[2+1].ia[3]
int k = p[-2]; // p[-2]是ia[2-1]即ia[0]的元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组和他们相比还是有所不同。标准库类型限定使用下标必须是无符号类型，而内置的下标运算无此要求，可以是负数。当然，结果的地址必须指向原来的同一数组的同一元素或同一数组的尾元素的下一指针。

### 3.5.4 C 风格字符串

> 尽管c++支持C风格字符串，但在C++程序中最好还是不要使用他们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

字符串字面值是一种通用结构的实例，这种结构是C++由C继承而来的C风格字符串。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串放在字符数组中并以空字符结束。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符'\0'。一般利用指针来操作这些字符串。

C标准库String函数

表3.8列举了C语言标准库提供的一组函数，这些函数可以操作C封哥字符串，它们定义在cstring头文件中，cstring是c语言头文件string.h的C++版本。

表3.8: C风格字符串的函数

```c++
strlen(p);		// 返回p的长度，空字符不计算在内
strcmp(p1, p2);	// 比较p1和p2的相等性，p1==p2，返回0，大于返回正值，小于返回负值
strcat(p1, p2);	// 将p2附加到p1之后，返回p1
strcpy(p1, p2);	// 将p2拷贝给p1在，返回p2
```

> 表3.8所列的函数不负责验证其字符串参数

传入此类函数的指针必须包含以空字符作为结束的数组

```c++
char ca[] = {'C', '+', '+'};
cout << strlen(ca) << endl; // 错误，没有空字符结束
```

此例中，ca虽然也是一个字符数组，但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下来。

比较字符串

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符：

```c++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 > s1
```

如果把这些运算用在两个c风格字符串上，实际比较的将是指针而非字符串本身：

```c++
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (s1 < s2) // 未定义的：试图比较两个无关地址
```

当使用数组的时候实际真真使用的是指向数组首元素的指针。因此上述的if条件比较的实际上是两个const char\*的值，这两个指针指向的非同一个对象，所以将得到未定义的结果。

想要比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。如果两个字符串相等，则返回0，如果前面的字符串比较大，则返回正值，否则返回负值。

```c++
if (strcmp(s1, s2) < 0) // 和两个string对象的比较s1 < s2的效果一样
```

目标字符串的大小由调用者指定

连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大。例如，要想把刚刚定义的两个string对象s1和s2连接起来，可以直接写成如下的形式：

```c++
string largeStr = s1 + " " + s2;
```

同样的操作放在ca1和ca2这两个数组身上就会产生错误了。表达式ca1+ca2的意思是两个指针相加，显然这样的操作没什么意义也肯定是非法的。

正确的方法是使用strcat函数和strcpy函数。不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾空字符。下面的代码虽然很常见，但充满了安全风险，极易引发严重错误:

```c++
// 如果计算largestr的大小将引发严重错误
strcpy(largeStr, ca1); // 将ca1拷贝给largeStr
strcat(largeStr, " "); // 空格追加给largeStr
strcat(largeStr, ca2); // ca2追加给largeStr
```

一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr所存的内容一旦改变，就必须检查其空间是否足够，不幸的是，这样的代码到处都是，程序员没法儿照顾周全。这类代码充满了风险而且经常导致严重的安全泄露。

> 对大多数应用来说，使用标准库string要比C风格字符串更安全，更高效

#### 3.5.5 与旧代码的接口

很多C++程序在标准库出现之前就已经写成了，他们肯定没用到string和vector类型。而且，有一些程序实际上是与C语言或其他语言的程序接口，当然也无法使用C++标准库。因此，现代的c++程序不得不与那些充满了数组和C风格字符串的代码衔接，为了使这一工作的简单易行，C++专门提供了一组功能。

混用string对象和C风格字符串

3.2.1节介绍过允许使用字符串字面值来初始化string对象：

```c++
string s("ahanwhite");
```

更一般的情况是，任何出现字符串字面值的地方都可以用空字符结束的字符串数组来替代：

- 允许使用以空字符结束的字符数组来初始化，string对象或为string对象赋值
- 在string对象的加法运算中允许以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是)；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象

上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法使用string对象来替代它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数。

```c++
char *str = s;//错误，不能用string对象初始化char*
const char *str = s.c_str();//正确
```

顾名思义，c_str函数的返回值是一个c风格的字符串，所以说，函数的返回值又是一个指针，该指针指向一个以空字符结尾的字符数组，而这个数组所存的数据恰好与那个string对象的一样，结果指针的类型是const char*，从而确保我们不会改变字符数组的内容。我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失效

> 如果执行完c_str函数后程序像一直都能使用其返回的数组，最好将该数组重新拷贝一份

使用数组初始化vector对象

3.5.1节介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要实现这一目的，只需要指明要拷贝区域的首元素地址和尾后地址就可以了：

```c++
int int_arr[] = {0,1,2,3,4,5,6};
// ivec有7个元素，分别是int_arr中对应元素的副本
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向带拷贝区域尾元素的下一位置。此例中，使用标准库函数begin和end来分别计算int_arr的首指针和尾后指针。在最终的结果中ivec将包含7个元素，他们的次序都和int_arr完全一样

用于初始化vector对象的值也可仅是数组的一部分

```c++
// 3个元素，int_arr[1],int_arr[2],int_arr[3]
vector<int> subVec(int_arr+1, int_arr+4);
```

这条初始化语句用3个元素创建了对象subVec，3个元素的值分别来自int_arr[1],int_arr[2],int_arr[3]

> 建议：尽量使用标准库类型而非数组
>
> 使用指针和数组很容易出错，一方面是概念上的问题：指针常用于底层操作，因此容易引发一些与繁琐细节相关的错误。其他问题则源于语法错误，特别是声明指针时的语法错误。

### 3.6 多维数组

严格来说，C++中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点。

当一个数组的元素仍然是数组时，通过使用两个维度来定义它，一个表示数组本身大小，另一个维度表示其元素大小。

```c++
int ia[3][4];//大小为3，每个元素有4个整数的数组
int arr[10][20][30] = {0};// 所有元素初始化为0
```

按照由内而外的顺序阅读此类定义有助于理解其真实含义。

对于二维数组来说，常把第一个元素称作行，第二个元素称为列。

多维数组的初始化

允许使用花括号括起来的一组值初始化多为数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括起来：

```c++
int ia[3][4] = { // 3个元素，每个元素都是大小为4的数组
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
}
```

其中内层嵌套的花括号并非必须的，例如下面的初始化语句，形式上更为简洁，完成的功能与上面代码一样

```c++
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表中，如果仅仅想初始化每一行的第一个元素：

```c++
int ia[3][4] = {{0},{4},{8}};
```

其他未列出的元素执行默认初始化，这个过程和一维数组一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了

```c++
int ia[3][4] = {0,1,2,3};
```

这里初始化的是第一行的四个元素。

多维数组的下标引用

可以使用下标来访问多维数组的元素，此时数组的每个维度都对应一个下标运算符。

如果表达式含有的下标预算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：

```c++
ia[2][3] = arr[0][0][0];// 用arr的首元素为ia最后一行的最后一个元素赋值
int (&row)[4] = ia[1];// 把row绑定到ia的第二个4元素的数组上
```

再举一个例子，程序中经常会用到两层嵌套的for循环来处理多维数组的元素：

```c++
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rawCnt][colCnt];// 12个未初始化的元素
for (size_t i = 0; i != rowCnt; ++i) {
    for (size_t j = 0; j != colCnt; ++j) {
        ia[i][j] = i * colCnt + j;
    }
}
```

使用范围for语句处理多维数组

```c++
size_t cnt = 0;
for (auto &row : ia) {
    for (auto &col : row) {
        col = cnt;
        ++cnt;
    }
}
```

在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子：

```c++
for (const auto &row: ia) {
    for (auto col : row) {
        cout << col << endl;
    }
}
```

这个循环中没有任何写操作，我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转换指针。假设不用引用类型，则循环如下形式：

```c++
for (auto row : ia)
    for (auto col : row)
```

程序无法通过编译，因为row不是引用类型，系统在初始化row时会自动讲这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row类型就是int *，显然内层的循环就不合法了，编译器试图在int *内遍历，这显然与程序的初衷相去甚远

> 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针

> 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：

```c++
int ia[3][4];
int (*p)[4] = ia; // p指向有4个整数的数组
p = &ia[2]; // p指向ia尾元素
```

首先明群*p是一个指针，再看右边是一个4元素的数组，在看左边，是一个int类型，所以p是一个指向含有4个元素的整型数组的指针

> 在上述声明中，圆括号必不可少
>
> ```c++
> int *p[4];		// 整型指针的数组(右->左)
> int (*p)[4];	// 指向含有4个整数的数组(内—>外->右->左)
> ```

使用auto或decltype就能尽可能的避免数组前面加上一个指针类型了

```c++
// 输出ia中每个元素的值，每个内层数组各占一行
// p指向含有你4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
    // q指向4个整数数组的首元素买也就是说 q指向一个整数
    for (auto q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```

类型别名简化多维数组的指针

读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名能让这一工作简单点儿。

```c++
using int_array = int[4];
typedef int int_array[4]; // 等价于上一行
// 输出ia中每个元素的值，每个内层数组各占一行
for (int_array *p = ia; p != ia + 3; ++p) {
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```

## 4 表达式

表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式

### 4.1 基础

有些基础概念对表达式求值过程有影响，本节先简要介绍

### 4.1.1 基本概念

C++定义了一元运算符和二元运算符。作用于一个运算对象的是一元运算符，如取地址符&和解引用福\*；作用于两个运算对象的运算符是二元运算符，如相等运算符==和乘法运算符*。除此之外，还有一个作用于三个运算符的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

一些符号既可以作为一元运算符又可以作为二元运算符。以\*号为例，作为一元运算符时执行解引用操作，作为二元运算符时执行乘法操作。一个符号到底是一元还是二元运算符由它的上下文决定。对于这类符号来说，它的两种用法毫不相干，完全可以当成两种不同的符号。

组合运算符和运算对象

对于含有多个运算符的复杂表达式来说，想要理解它的含义首先要理解运算符的优先级、结合律以及运算对象的求值顺序，例如，下面这条表达式的求值结果依赖于表达式中运算符和运算对象的组合方式

```c++
5 + 10 * 20/2
```

 乘法运算符是一个二元运算符，它由四种可能，10和20,10和20/2,15和20,20/2，下一节将介绍如何理解这样一条表达式

运算对象转换

在表达式求值的过程中，运算对象常常由一种类型转换成另外一种类型。例如，尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候及时运算对象的类型不同也没有关系，只要他们能够被转换成同一种类型即可。

类型转换的规则虽然有些复杂，但大多数都合乎情理，容易理解。例如，整数能转换成浮点数，浮点数也能转换成整数，但是指针不能转换成浮点数。让人稍微有点意外的是小整数类型(如bool、char、short等)通常会被提升成较大的整数类型，主要是int。4.11节将详细介绍类型转换的细节。

重载运算符

C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作，当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以被称之为重载运算符。IO库的>>和<<运算符以及string对象、vector对象和迭代器使用的运算符都是重载的运算符。

我们使用重载运算符是，其包括运算对象的类型和返回值的类型，都是由该运算符定义的，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。

左值和右值

C++的表达式要不然是右值，要不然就是左值。这两个名词都是从C语言继承而来，原本是为了帮助记忆：左值可以位于赋值语句的左侧，右值则不能。

在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但他们是右值而非左值。可以做一个简单的归纳：**当一个对象被用作右值的时候，用的是对象的值(内容)，当对象被用作左值的时候，用的是对象的身份(在内存中的位置)**。

不同的运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。一个重要的原则(参考13.6节，将介绍一种例外情况)是在需要右值的地方可以用左值代替。但是不能把右值当做左值来用。【意思是位置可以当做对象来用，对象不能当做位置用】当一个左值被当成右值用，，实际上使用的是它的内容。到目前位置，已经有几种我们熟悉的运算符是要用到左值的。

- 赋值运算符需要一个非常量的左值作为其左侧运算对象，得到的结果也依然是一个左值
- 取地址符作用域一个左值运算对象，返回一个指向该运算对象的指针，该指针是一个右值
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
- 内置类型和迭代器的递增递减运算符作用于左值对象，其前置版本所得的结果也是左值。

接下来介绍运算符的时候，也会注明该运算符的运算对象是否必须是左值以及其返回结果是否是左值。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值decltype作用域该表达式(不是变量)得到一个引用类型。举个例子，假定p的类型是int\*，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址符生成右值，所以decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针

#### 4.1.2 优先级与结合律

复合表达式是指含有两个或多个运算符的表达式，求复合表达式的值需要首先将运算符和运算对象合理的组合在一起，优先级与结合律决定了运算对象组合的方式。也就是说，他们决定了表达式中每个运算符对应的运算对象来自表达式的那一部分。表达式中的括号无视上述规则，程序员可以使用括号将表达式某个局部括起来使其得到优先运算。

一般来说，表达式最终的值依赖于其子表达式的组合方式。高优先级运算符的运算对象要比低优先级运算符更为紧密的组合在一起。如果优先级相同，则其组合规则由结合律决定。例如，乘法和除法的优先级相同且高于加法的优先级。因此，成啊和除法的运算对象会首先组合到一起，然后才轮到加法和减法的运算对象。算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从左至右的顺序组合运算对象

- 根据运算符的优先级，表达式3+4*5的值是23不是35
- 根据运算符的结合律，表达式20-15-3的值是2不是8

举一个稍微复杂一点的例子，如果完全按照从左至右的顺序求值，下面的表达式将得到20：

```c++
6 + 3 * 4 / 2 + 2
```

也有一些人会计算得到9、14或者36，然而在C++语言中真实的计算结果应该是14。这是因为这条表达式事实上与下述表达式等价：

```c++
((6 + ((3 * 4) / 2)) + 2)
```

括号无视优先级与结合律

括号无视普通的组合规则，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。

优先级和结合律有何影响

优先级会影响程序的正确性。结合律对表达式产生影响

#### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但没有说明运算对象按什么顺序求值，多数情况下，不会明确求值顺序，对于如下的表达式：

```c++
int i = f1() + f2();
```

我们知道f1和f2一定会执行乘法之前被调用，因为毕竟相乘的是两个函数的返回值，但是我们无法知道是f1在f2之前被调用还是f2在f1之前被调用，

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个简单的例子，<<运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的。

```c++
int i = 0;
cout << i << " " << ++i << endl; //未定义的
```

因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求++i的值再求i的值，此时输出的结果是1 1；也可能先求i的值再求++i的值，这时候输出0 1；甚至编译器还可能做出完全不同的操作。因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。

有4种运算符明确规定了运算对象的求职顺序，第一种是逻辑与(&&)运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧对象的值。另外三种是逻辑或(||)运算符、条件(?:)运算符和逗号(,)运算符

求值顺序、优先级、结合律

运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：

- 优先级规定，g的返回值和h的返回值相乘
- 结合律规定，f的返回值先与g和h的返回值的乘积相加，所得结果与j的返回值相加
- 对于这些函数的调用顺序没有明确规定

如果f、g、h和j是无关函数，他们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。

> 建议：处理复合表达式
>
> 1. 拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求
> 2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象
>
> 第2点有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。比如，在表达式*++iter中，递增运算符改变iter的值，iter(已经改变)的值又是解引用运算符的运算对象。此时或者类似情况下，求值的顺序不会成为问题，因为递增运算(即改变运算对象的子表达式)必须先求值，然后才轮到解引用运算。

### 4.2 算术运算符

<table>
  <tr>
    <th style="text-align: center;" colspan=6>表 4.1: 算术运算符（左结合律）</th>
  </tr>
  <tr>
    <th>运算符</th>
    <th>功能</th>
    <th>用法</th>
  </tr>
  <tr>
    <td>+</td>
    <td>一元正号</td>
    <td>+ expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>-</td>
    <td>一元负号</td>
    <td>- expr</td>
  </tr>
  <tr>
    <td>*</td>
    <td>乘法</td>
    <td>expr / expr</td>
  </tr>
  <tr>
    <td>/</td>
    <td>除法</td>
    <td>expr * expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>%</td>
    <td>求余</td>
    <td>expr % expr</td>
  </tr>
  <tr>
    <td>+</td>
    <td>加法</td>
    <td>expr + expr</td>
  </tr>
  <tr>
    <td>-</td>
    <td>减法</td>
    <td>expr - expr</td>
  </tr>
</table>

表4.1以及后面章节的运算符表，按照运算符的优先级将其分组。一元运算符的优先级最高，接下来是乘法和除法，优先级最低的是加法和减法。优先级高的比优先级低的运算符组合得更紧密。上面的所有运算符都满足左结合律，意味着当优先级相同时按照从左向右的顺序进行组合。

除非另做特殊说明，算符运算符都能用于任意算术类型以及任意能转换成算术类型的类型。算术运算符的运算对象和求值结果都是右值。在表达式求职之前，小整数类型的运算对象被提升成较大类型的整数，所有运算对象最终会转换成同一类型

一元正号运算符、加法运算符、减法运算符都能作用域指针。3.5.3节已经介绍过二元加法和减法运算符作用于指针的情况。当一元正号运算符作用于一个指针或者算术值时，返回运算对象值的一个提升后的副本。

一个负号运算符对运算对象值取负后，返回其(提升后)的副本：

```c++
int i = 1024;
int k = -i; // k是-1024
bool b = true;
bool b2 = -b; // b2是 true！
```

在2.1.1节，我们指出布尔值不应该参与运算，-b就是一个很好的例子。

对大多数运算符来说，布尔类型的运算对象被提升为int类型。如上所示，布尔变量b的值为真，参与运算时被提升成整数值1，对他求负后的结果为-1。再将其转换成布尔值并将其作为b2的初始值，显然这个初始值不为0，转换成布尔值后应该为1，所以b2的值为真！(注意：布尔值只有0和非零)。

> 提示：溢出和其他算术运算异常
>
> 算术表达式可能产生未定义的结果。一部分是数学性质本身：例如除数是0的情况；另一部分则源于计算机的特点：例如溢出，当计算结果超出该类型能表示的范围时就会产生溢出。
>
> 假设某个机器的short类型占16位，则最大的short数值是32767。这样一台机器上，下述复合赋值语句将产生溢出
>
> ```c++
> short short_value = 32767;
> short_value += 1; // 该计算导致溢出
> cout << short_value << endl;
> ```
>
> 给short_value赋值的语句是未定义的，这是因为表示一个带符号数32768需要17位，但是short类型只有16位。很多系统在编译和运行时都不报溢出错误，像其他未定义的行为一样，溢出的结果是不可预知的。在我们的系统中，该程序的输出是
>
> ```c+=
> -32768
> ```
>
> 该值发生了环绕，符号位本来是0，由于溢出被改成了1，于是结果变成了赋值。在别的系统也许会有其他结果，程序的行为可能不同甚至直接崩溃。

当作用于算术类型的对象时，算术运算符+\-\*/的含义分别是加减乘除,整数相除结果还是整数，也就是说，如果商含有小数部分，直接舍弃

```c++
int ival1 = 21/6; // ival1 = 3，结果进行了删节，余数被抛弃掉了
int ival2 = 21/7; // ival2 = 3, 没有余数，结果是整数
```

运算符%俗称取余或取模运算符，负责计算两个整数相处所得的余数，参与取余运算的运算对象必须是整数类型：

```c++
int ival = 42;
double dval = 3.14;
ival % 12; // 正确，结果为6(3*12+6=42，余数为6)
dval % 12; // 错误，运算对象是浮点类型
```

C++11标准规定商一律向0取整，即直接舍弃小数部分。

根据取余的定义，如果m和n是整数且n非0，则表达式(m/n) * n + m % n的求值与m相等。隐含的含义是，如果m%n不等于0，则它的符号和m相同。除了-m导致溢出的特殊情况，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。具体示例如下：

```c++
 21 %  6; /* 结果是 3 */         21 /  6; /* 结果是 3 */
 21 %  7; /* 结果是 0 */         21 /  7; /* 结果是 3 */
-21 % -8; /* 结果是-5 */	     -21 / -8; /* 结果是 2 */
 21 % -5; /* 结果是 1 */         21 / -5; /* 结果是-4 */
```

> 个人理解为除法带有负负得正的概念，而取余的结果正负只与被除数相关且正负一致。

 ### 4.3 逻辑和关系运算符

关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和股韩系运算符的返回值都是布尔类型。值为0的运算对象(算术类型或指针类型)表示假，否则表示为真。对于这两类运算符来说，运算对象和求值结果都是右值。

<table>
  <tr>
    <th style="text-align: center;" colspan=6>表 4.2: 逻辑运算符和关系运算符</th>
  </tr>
  <tr style="border-bottom: double;">
    <th>结合律</th>
    <th>运算符</th>
    <th>功能</th>
    <th>用法</th>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>!</td>
    <td>逻辑非</td>
    <td>!expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td><</td>
    <td>小于</td>
    <td>expr < expr </td>
  </tr>
  <tr>
    <td>左</td>
    <td><=</td>
    <td>小于等于</td>
    <td>expr <= expr </td>
  </tr>
  <tr>
    <td>左</td>
    <td>></td>
    <td>大于</td>
    <td>expr > expr </td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>>=</td>
    <td>大于等于</td>
    <td>expr >= expr </td>
  </tr>
  <tr>
    <td>左</td>
    <td>==</td>
    <td>相等</td>
    <td>expr == expr </td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>!=</td>
    <td>不相等</td>
    <td>expr != expr </td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>&&</td>
    <td>逻辑与</td>
    <td>expr && expr </td>
  </tr>
  <tr>
    <td>左</td>
    <td>||</td>
    <td>逻辑或</td>
    <td>expr || expr </td>
  </tr>
</table>

逻辑与和逻辑或运算符

对于逻辑与运算符(&&)来说，当且仅当两个运算对象都为真时结果为真；对于逻辑或运算符(||)来说，只要两个运算对象中一个为真结果就为真。

逻辑与运算符和逻辑或运算符都是先求左侧运算对象再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为短路求值。

- 对于逻辑与运算符来说，当且仅当左侧对象为真时才对右侧对象求值。
- 对于逻辑或运算符来说，当且仅当左侧对象为假时才对右侧对象求值。

第3章的几个程序用到了逻辑与运算符，他们的左侧运算对象是为了确保右侧运算对象求值过程的正确性和安全性，例如：

```c++
index != s.size() && !isspace(s[index])
```

首先检查index是否到达string的末尾，以此确保只有当index在合理范围之内才会计算右侧对象的值。

举一个使用逻辑或运算符的例子，假定有一个存储着若干string对象的vector对象，要求输出string对象的内容并且遇到空字符串或者以句号结束的字符串时进行换行。使用基于范围的for循环处理string对象的 每个元素：

```c++
// s是对常量的引用，元素既没有被拷贝也不会被改变
for (const auto &s : text) {
    cout << s;
    // 遇到空字符串或以句号结束的字符串进行换行
    if (s.empty() || s[s.size()-1] == '.') // 注意这里string索引取出来是char类型，用单引号
        cout << endl;
    else
        cout << " "; // 否则以空格隔开
}
```

值得注意的是，s被声明成了对常量的引用，因为text的元素是string对象，可能非常大，所以将s声明成引用类型以避免对元素的拷贝，又因为不需要对string对象做写操作，所以s被声明成对常量的引用。

逻辑非运算符

逻辑非运算符(!)将运算对象的值取反后返回。下面举个例子，假设vec是一个整数类型的vector对象，可以使用逻辑非欲奴安抚将empty的函数返回值取反从而检查vec是否含有元素

```c++
// 输出vec的首元素(如果有的话)
if (!vec.empty())
    cout << vec[0];
```

关系运算符

顾名思义，关系运算符比较运算对象的大小关系并返回布尔值。关系运算符都满足左结合律。

因为关系运算符的求值结果是布尔值，所以将几个关系运算符连写在一起会产生意想不到的结果：

```c++
if (i < j < k) //  i < j的结果是0或1，只要k大于1即为true
// 正确写法
if (i < j && j < k)
```

相等性测试与布尔字面值

如果想测试一个算术对象或指针对象的真值，最直接的办法就是将其作为if语句的条件

```c++
if (val) {} // 如果val是非0任意值，条件为真
if (!val) {} // 如果val是0，条件为真
```

在上面两个条件中，编译器将val转换成布尔值。有时会试图将上面的真值测试写成如下形式：

```c++
if (val == true) {} // 只有当val等于1时条件才为真
```

这样写存在两个问题：一，写法相较第一种更长且不太直接，，更重要的一点是如果val不是布尔值，这样比较就失去了原来的意义。

如果val不是布尔值，那么进行比较之前会首先把true改成val的类型，也就是说，如果val不是布尔值，则代码可以改写成一下形式：

```c++
if (val == 1) {}
```

正如我们熟悉的那也，当布尔值转换成其他算术类型时，false转成0而true转成1。如果真想知道val的值是否为1，应该直接写出1来，而不是与true作比较

> 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象

### 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个可以修改的左值。如果给定

```c++
int i = 0, j = 0, k = 0; // 初始化而非赋值
const int ci = i; // 初始化而非赋值
```

则下面的赋值语句都是非法的：

```c++
1024 = k; // 错 字面值是右值
i + j = k;// 错 算术表达式是右值
ci = k;// 错 ci是常量左值(不可修改)
```

赋值运算的结果是它的左侧运算对象，并且是一个左值，相应的，结果的类型就是左侧运算对象的类型。如果赋值

运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型

```c++
k = 0;
k = 3.14159; // k = 3，int类型
```

C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象

```c++
k = {3.14}; //错误 窄化转换
vector<int> vi;
vi = {0,1,2,3,4,5,6,7,8,9}
```

如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值及时转换的话其所占空间也不应该大于目标类型的空间。

对于类类型来说，赋值运算的细节由类本身决定。对于vector来说，vector模板重载了赋值运算并且可以接收初始值列表，当赋值发生时用右侧运算对象的元素替换左侧运算对象的元素

无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量赋给左侧运算对象。

赋值运算满足右结合律

赋值运算满足右结合律，这一点和其他二元运算符又有点不大一样

```c++
int ival, jval;
ival = jval = 0; //正确，都被赋值为0
```

因为赋值运算满足右结合律，所以靠右的赋值jval=0作为靠左的赋值运算符的右侧运算对象。又因为赋值运算返回的是其左侧运算对象，所以靠右赋值运算的结果即jval又被赋给了ival。

对于多重赋值语句中的每一个对象，它的类型或者和右边对象的类型相同，或者可由右边对象的类型转换得到

```c++
int ival, *pval; // ival的类型是int，pval是指向int的指针
ival = pval = 0; // 错误，不能把指针的值赋给int类型
string s1, s2;
s1 = s2 = "OK"; // 字符串字面值OK转换成string对象
```

因为ival和pval的类型不同，而且pval的类型int\*无法转换成ival的类型int，所以尽管0这个值可以赋给任何对象，但第一条赋值语句仍是非法的。

赋值运算优先级较低

赋值语句经常会出现在条件中，因为负值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其复合我们的原意。下面这个玄幻说明了把赋值语句放在条件中有什么用处，它的目的是反复调用一个函数直到返回期望的值

```c++
int i = get_value(); // 得到第一个值
while (i != 23) {
    // 其他处理...
    i = get_value(); // 得到剩下的值
}

int i;
while ((i = get_value()) != 23) {
    // 其他处理...
}
```

切勿混淆相等运算符和负值运算符

C++语言允许用负值运算作为条件，但是这一特性可能会带来预想不到的后果：

```c++
if ( i = j )
```

此时，if语句的条件部分把j的值赋给i，然后检查赋值的结果是否为真。如果j不为0，条件为真，然而这段代码的初衷可能是想判断i与j是否能相等

```c++
if ( i == j)
```

复合赋值运算符

我们经常要对对象施以某种运算，然后把计算的结果在赋给该对象。举个例子

```c++
int sum = 0;
// 计算1到10的和
for (int val = 1l val <= 10; ++val)
    sum += val; //等价于 sum = sum + val
```

这种复合操作不仅对加法来说很常见，而且也常常应用于其他算术运算符或者4.8节将要介绍的位运算符。每种运算符都有相应的复合赋值形式

```c++
+=	-=	*=	/=	%=	// 算术运算符
<<=	>>=	&=	^=	|=	// 位运算符
```

任意一种复合运算符都完全等价于`a = a op b;` 。

唯一的区别是左侧运算对象的求值次数：使用复合运算符只求值一次，使用普通的运算符则求值两次。这两次包括：一次是作为右边子表达式的一部分求值，一次是作为赋值运算的左侧运算对象求值。其实在很多地方，这种区别除了对程序性能有些许影响外几乎可以忽略不计。

### 4.5 递增和递减运算符

递增运算符(++)和递减运算符(--)为队形的加一和减一操作提供了一种简介的书写形式。这两个运算符还可应用于迭代器，因为很多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁外还是必须的。

递增和递减运算符由两种形式，前置版本和后置版本。到目前为止，本书用的都是前置版本，这种形式的运算符首先将运算对象加一或减一，然后将改变后的对象作为求值结果。后置版本也会将运算加一或减一，但是求值结果是运算对象改变之前那个值的副本。

```c++
int i = 0, j;
j = ++i;	// j = 1, i = 1; 前置版本得到递增之后的值
j = i++;	// j = 1, i = 2; 后置版本得到递增之前的值
```

这两种运算符必须用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本返回。

> 除非必须，否则不适用递增递减运算符的后置版本
>
> 前置版本的递增运算符避免了不必要的工作，他把值加1后直接返回改变了的运算对象。与之相比，后置版本的操作需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费
>
> 对于指针和整数类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。

在一条语句中混用解引用和递增运算符

如果我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增或递减运算符的后置版本。

举个例子，可以使用后置的递增运算符来控制循环输出一个vector对象内容直至遇到(但不包括)第一个负值位置：

```c++
auto pbeg = v.begin();
// 输出元素直至遇到第一个负值位置
while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl; //输出当前值并向前移动一个元素
```

后置递增运算符的优先级高于解引用运算符，因此\*pbeg++等价于\*(pbeg++)。pbeg递增后返回初始值的副本做解引用，因此输出的是当前的值，pbeg指向下一个元素。

> 简介可以称为一种美德
>
> ```c++
> // 使用如下写法
> cout << *iter++ << endl;
> // 比下面好
> cout << *iter << endl;
> ++iter;
> ```

运算对象可按任意顺序求值

大多数运算符没有规定运算对象的求值顺序，这在一般情况下不会有什么影响。然而如果一个子表达式改变了某个运算对象的值，另一条子表达式又要用这个值的话，运算对象的求值顺序就很关键了，因为递增和递减运算符会改变运算对象的值，所以要提防复合表达式中错用这两个运算符。

为了说明这一问题，我们将重写3.4.1节的程序，该程序使用for循环将输入的第一个单词改成大写形式：

```c++
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it); // 把当前字符改成大写形式
```

上述程序中，我们把解引用和递增it两个任务分开来完成。如果用一个看似等价的while循环来代替

```c++
// 该循环的行为是未定义的
while (beg !=s.end() && isspace(*beg))
    *beg = toupper(*beg++); // 错误，该赋值语句未定义
```

将产生未定义的行为，问题在于：赋值运算符左右两端的运算对象都用到了beg并且右侧运算对象还改变了beg的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理该表达式

```c++
*beg = toupper(*beg);//如果先求左侧的值
*(beg + 1) = toupper(*beg);// 如果先求右侧的值
```

也可能采取被的什么方式处理它。

### 4.6 成员访问运算符

点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式`ptr->mem`等价于`(*ptr).men`

```c++
string s1 = "a string", *p = &s1;
auto n = s1.size(); // 运行string对象s1的size成员
n = (*p).size(); // 运行p所指对象的size成员
n = p->size(); // 等价于(*p).size()
```

因为解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没有括号，意思就大不相同。

箭头运算符作为一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值那么结果是左值，反之成员所属的对象是右值，那么结果是右值。

### 4.7 条件运算符

条件运算符(?:)允许我们把简单的if-else逻辑嵌入到单个表达式中，条件运算符按照如下形式使用

```c++
cond ? expr1 : expr2
```

其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式、条件运算符的执行过程是：首先球cond的值，如果条件为真对expr1求值，并返回该值，否则对expr2求值并返回该值，举个例子：

```c++
string finalgrade = (grade < 60) ? "fail" : "pass";
```

条件判断成绩是否小于60，如果小于，表达式的结果是fail，否则是pass。有点类似于逻辑与运算符和逻辑或运算符(&&和||)，条件运算符只对expr1和expr2中的一个求值。

当条件运算符的另两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则是右值。

嵌套条件运算符

允许在条件运算符的内部嵌套另外一个条件运算符。也就是说，条件表达式可以作为另一个条件运算符的cond或expr。举个例子：

```c++
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```

条件运算符满足右结合律，意味着运算对象一般按照从右至左的顺序组合。因此在上面的代码中，靠右边的条件运算构成了靠左边调减运算的:分支。

> 随着条件运算嵌套成熟的增加，代码可阅读性急剧下降。因此条件运算的嵌套最好别超过两到三层

在输出表达式中使用条件运算符

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。例如，有时根据条件输出两个对象中的一个：

```c++
cout << ((grade < 60) ? "fail" : "pass"); // 输出pass或fail
cout << (grade < 60) ? "fail" : "pass"; // 输出0或1
cout << grade < 60 ? "fail" : "pass"; //错误：试图比较cout和60
```

在第二条表达式中，grade和60的比较结果是<<运算符的运算对象，因此如果grade<60为真则输出1，反之输出0。<<运算符的返回值是cout，接下来cout作为条件运算符的条件。也就是说，第二条表达式等价于

```c++
cout << (grade < 60); //输出0或1
cout ? "fail" : "pass"; // 根据cout的值是true还是false产生对应的字面值
```

因为第三条的表达式等价于下面的语句，所以他是错误的

```c++
cout << grade; // 小于运算符的优先级低于移位运算符，所以先输出grade
cout < 60 ? "fail" : "pass"; // 然后比较cout和60 
```

### 4.8 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能，如17.2节要介绍的，一种名为bitset的标准库类型可以表示任意大小的二进制位集合，所以位运算同样能够用于bitset类型。

<table>
  <tr>
    <th style="text-align: center;" colspan=6>表 4.3: 位运算符(左结合律)</th>
  </tr>
  <tr style="border-bottom: double;">
    <th>运算符</th>
    <th>功能</th>
    <th>用法</th>
  </tr>
  <tr style="border-bottom: double;">
    <td>~</td>
    <td>位求反</td>
    <td>~ expr</td>
  </tr>
  <tr>
    <td><<</td>
    <td>左移</td>
    <td>expr1 << expr2</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>>></td>
    <td>右移</td>
    <td>expr1 >> expr2</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>&</td>
    <td>位与</td>
    <td>expr & expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>^</td>
    <td>位异或</td>
    <td>expr ^ expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>|</td>
    <td>位或</td>
    <td>expr | expr</td>
  </tr>
</table>

一般来说，如果运算对象是小整型，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的，如果运算对象是带符号的且它的值为负，那么位运算如何处理对象的”符号位“依赖于机器。而且此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。

> 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算用于处理无符号类型

移位运算符

之前在处理输入和出处操作时，我们已经使用过标准IO库定义的<<运算符和>>运算符的重载版本。这两种运算符的内置含义是对其运算对象执行基于二进制的移动操作，首先令左侧运算对象按照右侧运算对象的要求移动指定位数，然后将经过移动的(可能还进行了提升)左侧运算对象的拷贝作为求值结果，其中，右侧的运算对象一定不能为负，而且值严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移(<<)或者向右移(>>)，移除边界之外的位就被舍弃掉了：

<table>
    <tr style="text-align: center;">
        <td colspan=4 >在下面的图例中右侧为最低位并且假定char占8位、int占32位</td>
    </tr>
    <tr style="text-align: center;">
        <td colspan=4 >// 0233是八进制的字面值，参见2.1.3节</td>
    </tr>
    <tr>
        <td colspan="3" >unsigned char bits = 0233;</td>
        <td>1 0 0 1 1 0 1 1</td>
    </tr>
    <tr>
        <td colspan=4 >bits << 8; // bits提升成int型，然后往左移动8位</td>
    </tr>
    <tr>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 0 0 0 0 0</td>
        <td>1 0 0 1 1 0 1 1</td>
        <td>0 0 0 0 0 0 0 0</td>
    </tr>
    <tr>
        <td colspan=4 >bits << 31; // 向左移动31位，左边超出边界的位丢弃掉了</td>
    </tr>
    <tr>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 0 0 0 0 0</td>
    </tr>
    <tr>
        <td colspan=4 >bits >> 3; // 向右移动3位，右边超出边界的位丢弃掉了</td>
    </tr>
    <tr>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 0 0 0 0 0</td>
        <td>0 0 0 1 0 0 1 1</td>
    </tr>
</table>

左移运算符在右侧插入值为0的二进制位，右移运算符的行为则依赖于其左侧运算对象的类型：如果是无符号类型，则在左侧插入0，如果该运算对象是有符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择视环境而定。

位求反运算符

位求反运算符(~)将运算对象逐位求反后生成一个新值，将1置为0,0置为1：

<table>
    <tr>
        <td colspan="3" >unsigned char bits = 0227;</td>
        <td>1 0 0 1 0 1 1 1</td>
    </tr>
    <tr>
        <td colspan=4 >~ bits</td>
    </tr>
    <tr>
        <td>1 1 1 1 1 1 1 1</td>
        <td>1 1 1 1 1 1 1 1</td>
        <td>1 1 1 1 1 1 1 1</td>
        <td>0 1 1 0 1 0 0 0</td>
    </tr>
</table>

char类型的运算对象首先提升成int类型，提升时运算对象原来的位保持不变，往高位添加0即可。

位与、位或、位异或运算符

与&、或|、异或^运算符在两个运算对象上逐位执行相应的逻辑操作：

<table>
    <tr>
        <td colspan="3" >unsigned char b1 = 0145;</td>
        <td>0 1 1 0 0 1 0 1</td>
    </tr>
    <tr>
        <td colspan="3" >unsigned char b2 = 0257;</td>
        <td>1 0 1 0 1 1 1 1</td>
    </tr>
    <tr>
        <td>b1 & b2</td>
        <td colspan="2" >24个高位都是0</td>
        <td>0 0 1 0 0 1 0 1</td>
    </tr>
    <tr>
        <td>b1 | b2</td>
        <td colspan="2" >24个高位都是0</td>
        <td>1 1 1 0 1 1 1 1</td>
    </tr>
    <tr>
        <td>b1 ^ b2</td>
        <td colspan="2" >24个高位都是0</td>
        <td>1 1 0 0 1 0 1 0</td>
    </tr>
</table>

对于位与运算符&来说，两个运算对象的对应位置**都是1**则运算结果中该位为1，否则为0

对于位或运算符|来说，两个运算对象的对应位置**至少有一个是1**则运算结果中该位为1，否则为0

对于位异或运算符^来说，两个运算对象的对应位置**有且仅有一个1**则运算结果中该位为1，否则为0

> 有一种常见的错误是把位运算符与逻辑运算符搞混

使用位运算符

我们举一个使用位运算符的小例子：假设班级中有30个学生，老师每周都会对学生进行一次小测验，测验的结果只有通过和不通过两种。为了更好地追踪测验的结果，我们用一个二进制表示某个学生在一次测验中是否通过，显然全班的测验结果可以用一个无符号整数来表示：

```c++
unsigned long quiz1 = 0; // 把这个值当成是位的集合来使用
```

定义quiz1的类型是unsigned long，这样，在任何机器上都将至少用有32位，给quiz1赋一个明确的初始值，使得它的每一位在开始时都有统一且固定的值。

教师必须有权设置并检查每一个二进制位。例如我们需要对序号27的学生对应的位进行设置，以表示他通过了测验。为了达到这一目的，首先创建一个值，该值只有第27位上是1其他位都是0，然后将这个值与quiz1进行位或运算，这样就能强行将quiz1的第27位设置为1，其他位都保持不变

为了实现本例的目的，我们将quiz1的低阶位赋值为0，下一位赋值为1，以此类推，最后统计quiz1各个位的情况。

使用左移运算符和一个unsigned long类型的整数字面值1就能得到一个表示学生27通过了测验的数值：

```c++
1UL << 27 //生成一个值，该值只有第27位为1
```

1UL的低阶位上只有一个1，除此之外(至少)还有31个值为0的位。之所以使用unsigned long类型，是因为int类型只能确保占用16位，而我们至少需要27位。上面这个表达式通过在值为1的那个二进制位后面添加0，使其想做移动了27位。

接下来将所得的值与quiz1进行位或运算。为了同时更新quiz1的值，使用一条复合赋值语句

```c++
quiz1 |= 1UL << 27; // 表示学生27通过了测验
```

假定教师在重新核对测验结果时发现学生27实际上并没有通过测验，他必须把第二十七为设置为0、其他位保持不变。此时我们需要使用一个特殊的整数，它的27位是0，其他都是1，将这个值与quiz1进行位与运算就能实现目的了

```c++
quiz1 &= ~(1UL << 27); // 学生27没有提供测验
```

最后我们试图检查学生27测验的情况到底怎么样

```c++
bool status = quiz1 & (1UL << 27);
```

我们将quiz1与一个只有27位是1其他都是0的值按位与。27位是1则结果非0，否则是0

移位运算符(又叫IO运算符)满足左结合律

尽管很多程序员从未使用过位运算符，但是几乎所有人都使用过他们的重载版本来进行IO操作。重载运算符的优先级和结合律都和它的内置版本一样，因此即使程序员用不到位运算符的内置含义，也有必要理解其优先级和结合律

因为移位运算符满足左结合律，所以表达式

```c++
cout << "hi" << "there" << endl;
```

的执行过程实际上等同于

```c++
((cout << "hi") << "there") << endl;
```

移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算的优先级高。因此在一次使用多个运算符时，有必要适当的地方加上括号满足我们的需求

```c++
cout << 42 + 10; // 正确
cout << (10 < 42); // 正确 输出1
cout << 10 < 42; // 错误 试图比较cout和42
```

### 4.9 sizeof运算符

sizeof运算符返回一个表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：

```c++
sizeof (type)
sizeof expr
```

在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：

```c++
Sales_data data, *p;
sizeof(Sales_data); // 存储Sales_data类型的对象所占的空间大小
sizeof data; // data的类型的大小，即sizeof(Sales_data)
sizeof p; // 指针所占的空间大小
sizeof *p; // p所指类型的空间大小，即sizeof(Sales_data)
sizeof data.revenue; // Sales_data的revenue成员对应类型的大小
sizeof Sales_data::revenue; // 另一种获取revenue大小的方式
```

最有趣的是`sizeof *p;`。因为sizeof满足右结合律并且与*运算符的优先级一样。所以表达式按照从右到左的顺序组合。也就是说等效于`sizeof(*p);`。其次，因为sizeof不会实际求运算对象的值，即使p是一个无效(即未初始化的)指针也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍是一个安全的行为，因为指针实际上没有被真正使用。sizeof不需要真的解引用指针也能知道它所指的对象的类型。

C++11允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员但是sizeof运算符无需我们提供一个具体的对象，因为要想知道类成员的大小无需真的获取该成员。

sizeof运算符的结果部分的依赖于其作用的类型

- 对于char或者类型为char的表达式执行sizeof运算，结果得1
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小
- 对指针执行sizeof运算得到指针本身所占空间的大小
- 对解引用指针执行sizeof运算得到指针所指对象所占空间的大小，指针不需要有效
- 对数组执行sizeof运算得到整个数组所占空间的大小，等价于把数组中所有的元素各执行一次sizeof运算并将所有的结果求和。注意，sizeof运算不会把数组转换成指针来处理
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象的元素占了多少空间

因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组元素的个数：

```c++
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; //正确，sizeof返回一个常量表达水
```

因为sizeof返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。

### 4.10 逗号运算符

逗号运算符由两个运算对象，按照从左向右的顺序依次求值。和逻辑与逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序。

对于逗号运算符来说，首先对左侧的表达式求职，然后把求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值，如果右侧运算对象是左值，那么最终的求值结果也是左值。

逗号运算符经常被用在for循环当中

```c++
vector<int>::size_type cnt = ivec.size();
// 将把从size到1的值赋给ivec的元素
for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
    ivec[ix] = cnt;
```

这个循环在for语句的表达式中递增ix，递减cnt，每次循环迭代xi和cnt相应改变。只要ix满足条件，我们就把当前元素设成cnt的当前值。

### 4.11 类型转换

在C++语言中，某些类型之间有关联。如果两种类型之间有关联，那么当程序中需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。换句话说，如果两种类型可以相互转换，那么他们就是关联的。

举个例子，考虑一下这条表达式，它的目的是将ival初始值初始化为6

```c++
int ival = 3.351 + 3; // 编译器可能会警告该运算丢失了精度
```

加法的两个运算对象不同，3.351是double类型，3的类型是int。C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型同一后再求值。上述的类型转换是自动执行的，无需程序员的介入，有时甚至无需程序员去了解。因此它们被称为隐式转换。

算术类型之间的隐式转换被设计的尽可能避免损失精度。很多时候，如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型。上面的例子中3转换成double，然后浮点数相加，所得结果是double类型。

接下来就要完成初始化的任务了，在初始化过程中，因为被初始化的对象的类型无法改变，所以初始值被转换成该对象的类型。仍以这个例子说明，加法运算得到的double类型的结果被转换成int类型的值，这个值被用来初始化ival。由double向int转换时忽略掉了小数部分。上面的表达式中，数值6倍赋给了ival。

何时发生隐式类型转换

在下面这些情况下，编译器会自动的转换运算对象的类型：

- 在大多数情况下，比int类型小的整型值首先提升为较大的整数类型
- 在条件中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
- 如第6章将要介绍的，函数调用时也将发生类型转换。

#### 4.11.1 算术转换

算术转换的含义就是把一种算术类型转换成了另一种算术类型。算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。例如，如果一个运算对象的类型是long double，那么不论另外一个运算对象是什么类型都会被转换成long double。还有一中更普遍的情况，当表达式中既有浮点型也有整数类型时，整数值将转换成相应的浮点类型。

整型提升

整型提升负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就我们熟知的，布尔值会提升成0或1.

较大的char类型(wchar_t、char16_t、char32_t)提升成int、unsigned int、long、unsigned long、long long、unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。

无符号类型的运算对象

如果某个运算符的运算对象不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。

像往常一样，首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。如果两个(提升后的)运算对象的类型要么都是带符号的，要么都是无符号的，则小类型的运算对象转换成较大的类型。

如果一个运算对象是无符号类型，另外一个是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转换成unsigned int类型。需要注意的是，如果int型的值刚好是负值，其结果将以2.1.2节介绍的方法转换，并带来该节描述的所有副作用。

剩下的情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存储在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是long和unsigned int，并且int和long的大小相同，则long类型的运算对象转换成unsigned int类型；如果long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long型。

理解算术转换

要理解算术转换，办法之一就是研究大量的例子：

```c++
bool	flag;	char			cval;
short	sval;	unsigned short	usval;
int		ival;	unsigned int	uival;
long	lval;	unsigned long	ulval;
float	fval;	double			dval;
3.14159L + 'a';	// double：'a'转成int后，再从int转成long double
dval + ival;	// double：ival转成double
dval + fval;	// double：float转成double
ival = dval;	// int: double转成int
flag = dval;	// float：dval为0则转为false，其他转为true
cval + fval;	// float：char转int，再从int转到float  *
sval + cval;	// int：char转int，short转int *
cval + lval;	// long：char转int，再从int转到long
ival + ulval;	// unsigned long：int转成unsigned long（无符号ul不小于带符号i
usval + ival;	// 根据unsigned short和int所占空间的大小进行提升
uival + lval;	// 根据unsigned int和long所占空间的大小进行提升
```

#### 4.11.2 其他隐式类型转换

除了算术转换之外还有几种隐式类型转换，包括一下几种：

**数组转成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：

```c++
int ia[10]; // 含有10个整数的数组
int *ip = ia; // ia转换成指向数组首元素的指针
```

当数组被用作decltype关键字的参数，或者作为取地址符(&)、sizeof及typeid等运算符的运算对象时，上述转换不会发生。同样的，用一个引用来初始化数组，上述转换也不会发生。6.7节将提到，当在表达式中使用函数类型时会发生类似的指针转换。

**指针的转换**：C++还规定了几种其他的指针转换方式，包括常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void\*；指向任意对象的指针能转换成const void\*。15.2.2节 将介绍，在有几成关系的类型间还有另外一种指针转换的方式

**转换成布尔类型值**：存在一种从算数类型或指针类型自动转换成布尔类型的机制。如果指针类型或算术类型的值为0，转换结果是false，否则结果是true

```c++
char *cp = get_string();
if (cp) {} // 如果指针cp不是0，条件为真
while (*cp) {} // 如果*cp不是空字符，条件为真
```

**转换成常量**：允许将指向非常量类型的指针转换成指向相应对常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用

```c++
int i;
const int &j = i;	// 非常量转换成你const int的引用
const int *p = &i;	// 非常量的地址转换成const的地址
int &r = j, *q = p;	// 错误：不允许const转换成非常量
```

相反的转换并不存在，因为他试图删除掉底层const

**类类型定义的转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。在7.5.4节中我们将看到一个例子，如果同时提出多个转换请求，这些请求将被拒绝。

我们之前的程序已经使用过类类型转换。一处是在需要标准库string类型的地方使用C风格字符串；另一处是在条件部分读入istream：

```c++
string s, t = "a value"; // 字符串字面值转换成string类型
while (cin >> s) {} // while条件部分把cin转换成布尔值
```

条件(cin >> s)读入cin的内容并将cin作为其求值结果。条件部分本来需要一个布尔类型的值，但这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值类型的规则，根据这一规则，cin自动的转换成布尔值。所得的布尔值到底是什么由输入流的状态决定，如果最后一次读入成功，转换得到的不二虎子是true；相反，如果最后一次读取不成功，转换得到的布尔值是false。

#### 4.11.3 显示转换

有时候我们希望显示的将对象强制转换成另外一种类型。例如，如果想在下面的代码中执行浮点数除法：

```c++
int i, j;
double sloape = i/j;
```

就要使用某种方法将i和/或j显示的转换成double，这种方法称作强制类型转换。

> 虽然有时候不得不使用强制类型转换，但这种方法本质上是非常危险的

命名的强制类型转换

一个命名的强制类型转换具有如下形式：

```c++
cast-name<type>(expression)
```

其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是**static_cast**、**dynamic_cast**、**const_cast**和**reinterpret_cast**中的一种。dynamic_cast支持运行时类型识别，我们将在19.2节对其做更详细的介绍。cast-name指定了执行的是哪种转换。

**static_cast**

任何具有明确意义的类型转换，只要不包含底层const，都可以使用static_cast。例如，通过将一个运算对象强制转换成double类型就可以使表达式执行浮点数除法：

```c++
double slope = static_cast<double>(j) / i;
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度丢失。一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息；但是当我们执行了显示的类型转换之后，警告信息就会被关闭了。

static_cast对于编译器无法自动执行的类型转化也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：

```c++
void *p = &d; // 正确，任何非常量对象的地址都可以存入void*
// 正确，将void*转换回初始的指针类型
double *dp = static_cast<double>(p);
```

当我们把指针存放在void*中，并且使用static_cast将其强制转换回原来的类型时，应确保指针的值保持不变。也就是说，强制转换的结果与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。

**const_cast**

const_cast只能改变对象的底层const

```c++
const char *pc;
char *p = const_cast<char*>(pc); // 正确，但是通过p写值是未定义的行为
```

对于将常量对象转换成非常量对象的行为，我们一般称其为"去掉const性质"。一旦我们去掉了某个对象的const性质，编译器就不在阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，在使用const_cast执行写操作就会产生未定义的后果。

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性会引发编译器错误。同样的，也不能使用const_cast改变表达式的类型：

```c++
const char *cp;
// 错误，static_cast不能转换掉const性质
char *q = static_cast<char*>(cp);
static_cast<string>(cp); // 正确，字符串字面值转换成string类型
const_cast<string>(cp);// 错误，const_cast只能改变常量属性
```

const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4节进行详细介绍。

**reinterpret_cast**

reinterpret_cast通常为运算对象的位模式提供较低层次的重新解释。举个例子，假设有如下的转换：

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

我们必须牢记pc所指的对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时引发错误。如

```c++
string str(pc);
```

可能导致异常的运行时行为

使用reinterpret_cast是非常危险的，用pc初始化str的例子很好的证明了这一点。其中的关键问题是类型改变了，但编译器没有给出任何错误的提示信息。当我们用一个int的地址初始化pc时，由于显示的声称这种转换合法，所以编译器不会发出任何警告或错误信息。接下来再使用pc时就会认定他的值是char*类型，编译器没法知道它实际存放的是int的指针。最终的结果是，在上面的例子中虽然用pc初始化str没什么意义，甚至还可能引发更糟糕的后果，但仅从语法上而言这种才做无可指摘。查找这类问题的原因非常困难，如果将ip强制转换成pc的语句和用pc初始化string对象的语句分数不同文件就更是如此。

> reinterpret_cast本质上就依赖于机器。想要安全的使用reinterpret_cast必须对设计的类型和编译器实现转换的过程都非常了解。

> 避免强制类型转换
>
> 强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员笔面试使用强制类型转换。这个建议对于reinterpret_cast尤为适用，因为此类类型转换总是充满了风险。在有重构函数的上下文中使用const_cast无可厚非，关于这一点在6.4中详细介绍，但是在其他情况下使用const_cast也就意味着程序存在某种设计缺陷。其他强制类型转换，比如static_cast和dynamic_cast。都不应该频繁使用。每次书写强制类型转换语句，都应该反复的斟酌能否以其他方式实现相同的目标。就算是在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。

旧式的类型转换

在早起的C++语言中，显示的强制类型转换包含两种形式：

```c++
type (expr); // 函数形式的强制类型转换
(type) expr; // C风格的强制类型转换
```

根据所涉及类型的不同，旧式的强制类型转换分别具有与const_cast、static_cast和reinterpret_cast相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成const_cast和static_cast也合法，其行为与对于的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与reinterpret_cast类似的功能：

```c++
char *pc = (char*) ip; // ip是指向整数的指针
```

的效果与使用reinterpret_cast一样

> 与命名的强制类型转换相比，旧式的强制类型转换从表现形式上来说不是那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难

### 4.12 运算符优先级表

<table>
  <tr>
    <th style="text-align: center;" colspan=6>表 4.4: 运算符优先级</th>
  </tr>
  <tr style="border-bottom: double;">
    <th>结合律</th>
    <th>运算符</th>
    <th>功能</th>
    <th>用法</th>
  </tr>
  <tr>
    <td>左</td>
    <td>::</td>
    <td>全局作用域</td>
    <td>::name</td>
  </tr>
  <tr>
    <td>左</td>
    <td>::</td>
    <td>类作用域</td>
    <td>class::name</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>::</td>
    <td>命名空间作用域</td>
    <td>namspace::name</td>
  </tr>
  <tr>
    <td>左</td>
    <td>.</td>
    <td>成员选择</td>
    <td>object.member</td>
  </tr>
  <tr>
    <td>左</td>
    <td>-></td>
    <td>成员选择</td>
    <td>pointer->member</td>
  </tr>
  <tr>
    <td>左</td>
    <td>[]</td>
    <td>下标</td>
    <td>expr[expr]</td>
  </tr>
  <tr>
    <td>左</td>
    <td>()</td>
    <td>函数调用</td>
    <td>name(expr_list)</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>()</td>
    <td>类型构造</td>
    <td>type(expr_list)</td>
  </tr>
  <tr>
    <td>右</td>
    <td>++</td>
    <td>后置递增运算</td>
    <td>lvalue++</td>
  </tr>
  <tr>
    <td>右</td>
    <td>--</td>
    <td>后置递减运算</td>
    <td>lvalue--</td>
  </tr>
  <tr>
    <td>右</td>
    <td>typeid</td>
    <td>类型ID</td>
    <td>typeid(type)</td>
  </tr>
  <tr>
    <td>右</td>
    <td>typeid</td>
    <td>运行时类型ID</td>
    <td>typeid(expr)</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>explicit cast</td>
    <td>类型转换</td>
    <td>cast_name&lt;type&gt;(expr)</td>
  </tr>
  <tr>
    <td>右</td>
    <td>++</td>
    <td>前置递增运算</td>
    <td>++lvalue</td>
  </tr>
  <tr>
    <td>右</td>
    <td>--</td>
    <td>前置递减运算</td>
    <td>--lvalue</td>
  </tr>
  <tr>
    <td>右</td>
    <td>~</td>
    <td>位取反</td>
    <td>~expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>逻辑非</td>
    <td>!</td>
    <td>!expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>-</td>
    <td>一元负号</td>
    <td>-expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>+</td>
    <td>一元正号</td>
    <td>+expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>*</td>
    <td>解引用</td>
    <td>*expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>&</td>
    <td>取地址</td>
    <td>&lvalue</td>
  </tr>
  <tr>
    <td>右</td>
    <td>()</td>
    <td>类型转换</td>
    <td>(type) expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>sizeof</td>
    <td>对象的大小</td>
    <td>sizeof expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>sizeof</td>
    <td>类型的大小</td>
    <td>sizeof(type)</td>
  </tr>
  <tr>
    <td>右</td>
    <td>sizeof</td>
    <td>参数包的大小</td>
    <td>sizeof...(name)</td>
  </tr>
  <tr>
    <td>右</td>
    <td>new</td>
    <td>创建对象</td>
    <td>new type</td>
  </tr>
  <tr>
    <td>右</td>
    <td>new[]</td>
    <td>创建数组</td>
    <td>new type[]</td>
  </tr>
  <tr>
    <td>右</td>
    <td>delete</td>
    <td>释放对象</td>
    <td>delete expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>delete[]</td>
    <td>释放数组</td>
    <td>delete[] expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>noexcept</td>
    <td>能否抛出异常</td>
    <td>noexcept(expr)</td>
  </tr>
  <tr>
    <td>右</td>
    <td>->*</td>
    <td>指向成员选择的指针</td>
    <td>ptr->*ptr_to_member</td>
  </tr>
  <tr>
    <td>右</td>
    <td>.*</td>
    <td>指向成员选择的指针</td>
    <td>obj.*ptr_to_member</td>
  </tr>
  <tr>
    <td>右</td>
    <td>*</td>
    <td>乘法</td>
    <td>expr * expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>/</td>
    <td>除法</td>
    <td>expr / expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>%</td>
    <td>取模</td>
    <td>expr % expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>+</td>
    <td>加法</td>
    <td>expr + expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>-</td>
    <td>减法</td>
    <td>expr - expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td><<</td>
    <td>左移</td>
    <td>expr << expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>>></td>
    <td>右移</td>
    <td>expr >> expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td><</td>
    <td>小于</td>
    <td>expr < expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td><=</td>
    <td>小于等于</td>
    <td>expr <= expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td>></td>
    <td>大于</td>
    <td>expr > expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>>=</td>
    <td>大于等于</td>
    <td>expr >= expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td>==</td>
    <td>相等</td>
    <td>expr == expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>!=</td>
    <td>不相等</td>
    <td>expr != expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>&</td>
    <td>位与</td>
    <td>expr & expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>^</td>
    <td>位异或</td>
    <td>expr ^ expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>|</td>
    <td>位或</td>
    <td>expr | expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>&&</td>
    <td>逻辑与</td>
    <td>expr && expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>左</td>
    <td>||</td>
    <td>逻辑或</td>
    <td>expr || expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>? :</td>
    <td>条件</td>
    <td>expr ? expr : expr</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>=</td>
    <td>赋值</td>
    <td>lvalue = expr</td>
  </tr>
  <tr>
    <td>右</td>
    <td>*=, /=, %=</td>
    <td rowspan=4 style="border-bottom: double;">复合赋值</td>
    <td rowspan=4 style="border-bottom: double;">lvalue += expr等</td>
  </tr>
  <tr>
    <td>右</td>
    <td>+=, -=</td>
  </tr>
  <tr>
    <td>右</td>
    <td><<=, >>=</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>&=, |=, ^=</td>
  </tr>
  <tr style="border-bottom: double;">
    <td>右</td>
    <td>throw</td>
    <td>抛出异常</td>
    <td>throw expr</td>
  </tr>
  <tr>
    <td>左</td>
    <td>,</td>
    <td>逗号</td>
    <td>expr, expr</td>
  </tr>
</table>

## 5 语句

通常情况下，语句是顺序执行的。但除非是最简单的程序，斗则仅有顺序执行远远不够。因此，C++语言提供了一组控制流语句以支持更复杂的执行路径

### 5.1 简单语句

C++语言中的大多数语句都以分号结束，一个表达式，比如ival + 6，末尾加上分号，就变成了表达式语句。表达式语句的作用是执行表达式并丢掉求值结果。

```C++
ival + 5; // 一条没什实际用处的表达式语句
cout << ival; // 一条有用的表达式语句
```

第一条语句没什么用处，因为虽然执行了加法，但是相加的结果却没有被使用。比较普遍的情况是，表达式语句中的表达式在求值时附带有其他效果，比如给变量赋了新值或者或者输出了结果。

空语句

最简单的语句是空语句，空语句只含有一个单独的分号：

```c++
; // 空语句
```

如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。一种常见的情况是，当循环的全部工作在条件部分就可以完成时，我们通常会用到空语句。例如，我们想读取输入流的内容直到遇到一个特定值时为止，除此之外什么事情也不做

```c++
// 重复读入数据直至达到文件末尾或某次输入的值等于sought
while (cin >> s && s != sought)
    ; // 空语句
```

while循环的条件部分首先从标准输入读取一个值并隐式的检查cin，判断读取是否成功。假定读取成功，条件的后半部分检查读进来的值是否等于sought的值。如果发现了想要的值，循环终止；否则从cin中继续读取另一个值，再一次判断循环的条件。

> 使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的

别漏写分号，也别多写分号

因为空语句时一条语句，所以可以用在任何使用语句的地方。由于这个原因，某系而看起来非法的分号往往只是一条空语句而已，从语法上说得过去。下面的片段包含两条语句：表达式语句和空语句。

```c++
ival = v1 + v2;// 正确，第二个分号表示一条多余的空语句
```

多余的空语句一般来说是无害的，但是如果在if或者while的条件后面跟了一个额外的分号就可能完全改变程序员的初衷。例如，下面的代码将无休止的循环下去：

```c++
// 出现了糟糕的情况：额外的分号，循环体是那条空语句
while (iter != svec.end()) ; // while循环体是这条空语句
	++iter; // 递增运算不属于循环的一部分
```

虽然从形式上来看执行递增语句的前面有缩进，但它并不是循环的一部分，循环条件后面跟着的分号构成了一条空语句，它才是真正的循环体。

> 多余的空语句并非总是乌海的

复合语句(块)

复合语句是指被花括号括起来的(可能为空)的语句和声明的序列，复合语句也被称作块。一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问，通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的(最内层)块你的结尾为止。

如果在程序的某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句。例如，while或for的循环体必须是一条语句，但是我们常常需要在循环体内做很多事情，这是就需要将多条语句用花括号括起来，从而把语句序列转变成块。

> 块不以分号为结束

所谓空块，是指内部没有任何语句的一堆花括号。空块的作用等价于空语句:

```c++
while (cin >> s && s != sought)
{} // 空块
```

### 5.2 语句作用域

可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了

```c++
while (int i = get_num()) // 每次迭代创建并初始化i
    cout << i << endl;
i = 0; //错误，在循环外无法访问i
```

如果其他代码也需要访问控制变量，则变量必须定义在语句的外部

```c++
// 寻找第一个负值元素
auto beg = v.begin();
while (beg != v.end() && *beg >= 0)
    ++beg;
if (beg == v.end())
    // 此时我们知道v中的所有元素都大于等于0
```

因为控制结构定义的对象马上要由结构本身使用，所以这些变量必须初始化

### 5.3 条件语句

C++语言提供了两种按条件执行的语句，一种是if语句，它根据条件决定控制流；另外一种是switch语句，它计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条。

#### 5.3.1 if语句

if语句的作用是：判断一个指定的条件是否为真，根据判断结果决定是否执行下一条语句。if语句包括两种形式：一种含有else分支，另外一种没有。

```c++
// 简单if语句的语法形式
if (condition)
    statement;
// if else语句的语法形式
if (condition)
    statement;
else
    statement2;
```

在这两个版本的if语句中，condition都必须用圆括号包围起来。condition可以是一个表达式，也可以是一个初始化了的变量声明。不管是表达式还是变量，其类型都能转换成布尔类型。通常情况下，statement是块语句。

使用if else语句

```c++
const vector<string> scores = {'F','D','C','B,','A','A++'};
// 如果grade小于60，对应的字母时F，否则计算其下标
string lettergrade;
if (grade < 60)
    lettergrade = scores[0];
else
    lettergrade = scores[(grade - 50)/10]; 
```

嵌套if语句

```c++
// 如果grade合格，对合格的成绩后添加一个加号或减号
if (grade < 60)
    lettergrade = scores[0];
else {
    lettergrade = scores[(grade - 50)/10];  // 获得字母形式的成绩
    if (grade != 100) // 只要不是A++, 就考虑添加减号
        if (grade % 10 > 7)
            lettergrade += '+';
    	else if (grade % 10 < 3)
            lettergrade += '-';
}
```

注意使用花括号

悬垂else

当一个if语句嵌套在另一个if语句内部时，很可能if分支会多余else分支。事实上，之前那个成绩转换的程序就有4个if分支，而只有2个else分支。这时候问题出现了，我们怎么知道某个给定的else和哪个if匹配呢？

这个问题通常被称为悬垂else，在那些既有if语句又有if else语句的变成语言中是个普遍存在的问题。不同语言解决该问题的思路也不同，就C++而言，它规定else与离它最近的未匹配的if匹配，从而消除了程序的二义性。

当代码中if分支多余else分支时，程序员有时会感觉比较麻烦。举个例子：

```c++
// 错误：实际的执行并非像缩进格式显示的那样；else分支匹配的是内层if语句
if (grade % 10 >= 3)
    if (grade % 10 > 7)
        lettergrade += '+';
else
    lettergrade += '-';
```

从代码的缩进格式来看，程序的初衷应该是希望else和外层的if匹配，也就是说，我们希望当grade小于3时执行else分支。然而，不管我们什么意图，也不管程序如何缩进，这里的else分支其实是内层if语句的一部分。最终，上面的代码将在末位大于3小于7的成绩后面添加减号。它的执行过程实际上等于如下形式：

```c++
// 缩进格式与执行过程相符，但不是程序员的意图
if (grade % 10 >= 3)
    if (grade % 10 > 7)
        lettergrade += '+';
    else
        lettergrade += '-';
```

使用花括号控制执行路径

要想使else分支与外层的if语句匹配起来，可以在内层if语句的两端家伙加上花括号，使其称为一个块：

```c++
if (grade % 10 >= 3) {
    if (grade % 10 > 7)
        lettergrade += '+';
} else
    lettergrade += '-';
```

语句属于块，意味着语句一定在块的边界之内，因此内层if'语句在关键字else前面的那个花括号处已经结束了。else不会再作为内层if的一部分。此时，最近的尚未匹配的if是外层if，也就是我们希望else匹配的那个。

#### 5.3.2 switch语句

switch语句提供了一条遍历的途径使得我们能够在若干固定选项中做出选择。举个例子，统计一段文本中各个元音出现的次数：

```c++
// 为每个原因字母初始化计数值
unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
char ch;
while (cin >> ch) {
    switch (ch) {
        case 'a':
            ++aCnt;
            break;
        case 'e':
            ++eCnt;
            break;
        case 'i':
            ++iCnt;
            break;
        case 'o':
            ++oCnt;
            break;
        case 'u':
            ++uCnt;
            break;
    }
}
```

switch语句首先对括号里的表达式进行求值，该表达式紧跟在关键字switch后面，可以是一个初始化的变量声明。表达式的值转换成整数类型，然后与每个case标签的值比较。如果表达式和某个case标签的值匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或者遇到一条break语句为止。

简而言之，break语句的作用就是终端当前的控制流。此例中，break语句将控制权转移到switch语句外面。因为switch是while循环体内唯一的语句，所以从while语句中终端出来以后，程序的控制权将移到while语句的右花括号处。此时while语句内部没有其他语句要执行，所以while会返回去再判断条件是否满足。

如果一个switch条件也没满足，则直接跳到下一条语句。

case关键字和它对应的值一起被称为case标签。case标签必须是整型常量表达式

```c++
char ch = getVal();
int ival = 23;
switch (ch) {
    case 3.14: // 错误，case标签不是一个整数
    case ival: // 错误，case标签不是一个整数
}
```

任何两个case标签的值都不能相同，否则就会引发错误。另外，default也是一种特殊的case标签。

switch内部的控制流

如果某个case标签匹配成功，将从改标签开始往后顺序执行所有case分支，除非程序显示的中断了这一过程，否则直到switch的结尾处才会停下来。要想避免执行后续case分支的代码，我们必须显示的告诉编译器终止执行过程。大多数情况下，在下一个case标签开始之前应该有一个break语句。

然而有时候默认的switch行为才是程序真正需要的。每个case标签只能对应掉一个值，但是有时候我们希望两个或更多个值共享同一组操作。此时我们就故意省略掉break语句，使得程序能够连续执行若干个case标签。

例如，也许我们想统计的是所有元音字母出现的总次数：

```c++
switch (ch) {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        ++vowelCnt;
        break;
}
```

在上面的代码中，几个case标签连写在一起，中间没有break语句。因此只要ch是元音字母，不管到底是哪个，都执行相同的代码。

C++程序比较自由，所以case标签之后不一定非得换行。把几个case标签写在一行里，强调这些case代表的是某个范围的值：

```c++
switch (ch) { // 另一种合法的书写形式
    case 'a': case 'e': case 'i': case 'o': case 'u':
        ++vowelCnt;
        break;
}
```

> 一般不要省略case分支最后的break语句。如果没写break语句，最好加一段注释说清楚逻辑

漏写break容易引发缺陷

有一种常见的错觉就是以为程序只执行匹配成功的哪个case分支的语句。

default标签

如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后的语句。例如，可以添加一个统计非元音字母的数量，只需要加一个default分支即可：

```c++
switch (ch) { // 另一种合法的书写形式
    case 'a': case 'e': case 'i': case 'o': case 'u':
        ++vowelCnt;
        break;
    default:
        ++otherCnt;
        break;
}
```

> 即使不准备在default标签下做任何工作，定义一个default语句也是有用的。其目的在与告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做

标签不应该孤零零的出现，它后面必须跟上一条语句或者另外一个case标签。如果switch结构以一个空的default标签作为结束，则该default标签后必须跟上一个空语句或者空块。

switch内部的变量定义

如前所述，switch的执行流程有时可能会跨过某些case标签。如果程序跳转到了某个特定的case，则switch结构中该case之前的部分会被忽略掉。这部分代码的行为引出了一个有趣的问题：被忽略过的代码中含有变量的定义怎么办？

答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳到后一处的行为是非法行为

```c++
case true:
	// 因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不合法
	string file_name; // 错误：控制流绕过一个隐式初始化的变量
	int ival = 0; // 错误：控制流绕过一个显式初始化的变量
	int jval; // 正确：因为jval没有初始化
	break;
case false:
	// 正确：jval虽然在作用域内，但是它没有被初始化
	jval = next_num(); //正确，给jval赋一个值
	if (file_name.empty()) // file_name在作用域内，但是没有被初始化
        // ...
```

假设上述代码合法，则一旦控制流直接跳到false分支，也就同时略过了变量file_name和ival的初始化过程。此时这两个变量在作用域之内，跟在false之后的代码试图在尚未初始化的情况下使用他们，这显然是行不通的。因此C++规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。

如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的case标签都在变量的作用域之外。

```c++
case true:
	{
        // 正确，声明语句位于语句块内部
    	string file_name;
	}
	break;
case false:
	if (file_name.empty()) // 错误：file_name不在作用域内
```

### 5.4 迭代语句

迭代语句通常称为循环，它重复执行操作直到满足某个条件才停下来。while和for语句在执行循环体之前检查条件，do while语句先执行循环体，然后再检查条件。

#### 5.4.1 while语句

只要条件为真，while语句就重复执行循环体。它的语法形式是

```c++
while (condition)
    	statement
```

在while循环结构中，只要condition的求值结果是true就一直执行statement，通常是一个块。condition不能为空，如果condition第一次求值就得false，statement一次都不执行。

while条件部分可以是一个表达式或者一个带初始化的变量声明。通常来说，应该由条件本身或者是循环体设法改变表达式的值，否则循环可能无法终止。

> 定义在while条件部分或者while循环体内的变量每次迭代都经历创建到销毁的过程。

使用while循环

当不确定要迭代多少次时，使用while循环比较合适，比如读取输入的内容就是如此。还有一种情况也应该使用while循环，这就是我们想在循环结束后访问循环控制变量。例如

```c++
vector<int> v;
int i;
// 重复读入数据，直至到达文件末尾或者遇到其他输入问题
while (cin >> i)
    v.push_back(i);
auto beg = v.begin();
// 寻找第一个负值元素
while (beg !- v.end() && *beg >= 0)
    ++ beg;
if (beg == v.end())
    // 此时我们知道v中所有元素都大于等于0
```

第一个循环从标准输入中读取数据，我们一开始不清楚循环要执行多少次，当cin读取到无效数据、遇到一些输入错误或者是到达文件末尾时循环条件失效。第二个循环重复执行直到遇到一个负值为止，循环终止后，beg或者等于v.end(),或者指向v中的一个小于0的元素。可以在while循环外继续使用beg的状态以进行其他处理。

#### 5.4.2 传统的for语句

for语句的语法形式是

```c++
for (init-statement; condition; expression)
    statement
```

关键字for以及括号里的部分称作for语句头。

init-statement必须是以下三种形式的一种：声明语句、表达式语句或者空语句，因为这些语句都以分号作为结束，所以for语句的语法形式也可以看做：

```c++
for (initializer; condition; expression)
    statement
```

一般情况下，init-statement负责初始化一个值，这个值随着循环的进行而更改。condition作为循环控制的条件，只要condition为真，就执行一次statement。如果condition第一次的求值结果就是false，则statement一次也不会执行。expression负责修改init-statement初始化后的变量，这个变量刚好就是condition检查的对象，修改发生在每次循环迭代之后。statement可以是一条单独的语句也可以是一条复合语句。

传统for循环的执行流程

```c++
for (decltype(s.size()) index = 0;
     index != s.size() && !isspace(s[index]); ++index)
    s[index] = toupper(s[index])
```

求值的顺序如下：

1. 循环开始时，首先执行一次init-statement。此例中，初始化index为0
2. 接下来判断condition。如果condition为真，则执行循环体，大写当前字母。否则退出循环。
3. 执行完循环体后，最后执行expression，index加1

> 牢记for语句头中定义的对象只在for循环体内可见。结束后index就不可用了。

for语句头中的多重定义

和其他的声明一样，init-statement也可以定义多个对象，但是init-statement只能有一条声明语句，因此，所有变量的基础类型必须相同。举个例子，我们用下面的循环把vector的元素拷贝一份添加到原来的元素后面。

```c++
// 记录下v的大小 当到达最后一个元素后结束循环
for (decltype(v.size() i = 0, sz = v.size(); i != sz; ++i)
     v.push_back(v[i])
```

省略for语句头的某些部分

for语句头能省略掉init-statement、condition和expression中的任何一个(或者全部)。

如果无需初始化，则我们可以用一条空语句作为init-statement。例如，对于在vector对象中寻找第一个负数的程序，完全可以使用for循环改写：

```c++
auto beg = v.begin();
for (/*空语句*/;beg != v.end() && *beg >= 0; ++beg)
    ;// 什么也不做
```

注意：分号必须保留以表示我们省略了init-statement。说的准确一点，分号表示的是一个空的init-statement。在这个循环中，因为所有要做的工作都在for语句头的条件和表达式部分完成了，所以for循环体也是空的。其中没条件部分决定何时停止查找，表达式部分递增迭代器。

省略condition的效果等价于在条件部分写了一个true。因为条件的值永远是true，所以在循环体内必须有语句负责退出循环，否则循环就会无休止的执行下去：

```c++
for (int i = 0; /*条件为空*/; ++i)
    // 对i进行处理，循环内部的代码必须负责终止迭代过程
```

我们也能省略掉for语句头的expression，但是在这样的循环过程中就要求条件部分或者循环体必须改变迭代变量的值。举个例子，之前有一个将整数读入vector的while循环，我们使用for语句改写它：

```c++
vector<int> v;
for (int i; cin >> i; /*表达式为空*/)
    v.push_back(i);
```

因为条件部分能改变i的值，所以这个循环无需表达式部分。其中，条件部分不断检查输入流的内容，只要读完所有的输入或者遇到一个输入错误就终止循环。

#### 5.4.3 范围for语句

C++11引入一种更简单的for语句，这种语句可以遍历容器或其他序列的所有元素。范围for语句的语法形式是：

```c++
for (declaration : expression)
    statement
```

expression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组、或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。

declaration定义一个变量，序列中的每个元素都得能转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符。这个关键字可以令编译器帮助我们指定何时的类型。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。

每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行statement。像往常一样，statement可以是一条单独的语句也可以是一个块。所有元素都处理完毕之后循环终止。

之前我们已经接触过几个这样的循环。接下来的例子将把vector对象的每个元素都翻倍，它涵盖了范围for语句几乎所有的语法特征：

```c++
vector<int> v = {0,1,2,3,4,5,6,7,8,9};
// 范围变量必须是引用类型，这样才能对元素执行写操作
for (auti &r : v)
    r *= 2;
```

for语句头声明了循环控制变量r，并将它与v关联在一起，我们使用auto令编译器为r指定正确的类型。由于准备修改v的元素的值，因此将r声明成引用类型。此时，在循环体内给r赋值，即改变了r所绑定的元素的值。

范围for语句的定义来源于与之等价的传统for语句:

```c++
for (auto beg = v.begin(), end = v.end(); beg != end; ++beg) {
    auto &r = *beg;
	r *= 2;
}
```

学习了范围for语句的原理之后，我们就不难理解为什么强调不能通过范围for语句增加vector对象的元素了。在范围for语句中，预存了end()的值。一旦在序列中添加(删除)元素，end()函数的值可能就会变得无效了。关于这一点，将在9.3.6节做更详细的介绍。

#### 5.4.4 do while语句

do while语句和while语句非常相似，唯一的区别是，do while语句先执行循环体后检查条件。不管条件的值如何，我们都至少执行一次循环。do while的语法形式如下：

```c++
do 
   statement
while (condition);
```

> do while循环应该在括号包起来的条件后面用一个分号表示语句结束。

在do语句中，求condition的值之前首先执行一次statement，condition不能为空。如果condition结果为假，终止循环。否则，重复循环过程。condition使用的变量必须定义在循环体之外。

我们可以用do while循环不断的执行加法运算

```c++
// 不断提示用户输入一对数，然后求其和
string rsp; // 作为循环条件，不能定义在do的内部
do {
    cout << "please enter two values: ";
    int val1 = 0, val2 = 0;
    cin >> val1 >> val2;
    cout << "The sum of " << val1 << " and " << val2
         << " = " << val1 + val2 << "\n\n"
         << "More? Enter two values: ";
    cin >> rsp;
} while (!rsp.empty() && rsp[0] != 'n');
```

如果用户没有回答或者用户的回答以字母n开始，循环都将终止。否则循环继续。

因为对于do while循环来说，先执行语句或块，后判断条件，所以不允许在条件部分定义变量：

```c++
do {
    // ...
    mumble(foo);
} while (int foo = get_foo()); // 错误 将声明放在了do的条件部分
```

如果允许在条件部分定义变量，则变量的使用出现在定义之前，这显然不合常理！

### 5.5 跳转语句

跳转语句中断当前的执行过程。C++语言提供了4中跳转语句：break、continue、goto和return。本章介绍前三中跳转语句，return语句将在6.3节进行介绍

#### 5.5.1 break语句

break语句负责终止离他最近的while、do while、for或switch语句，并从这些语句之后的一条语句开始继续执行。

break语句只能出现在迭代语句或者switch语句内部，包括嵌套在此类循环里的语句或块的内部。break语句的作用范围仅限于最近的循环或者switch：

```c++
string buf;
while (cin >> buf && !buf.empty()) {
    switch(buf[0]) {
        case '-':
            // 处理到第一个空白位置
            for (auto it = buf.begin()+1; it != buf.end(); ++it) {
                if (*it == ' ')
                    break; // #1 离开for循环
                // ...
            }
            // break #1 将控制权转移到这里
            // 剩余的'-'处理：
            break; // #2 离开switch
        case '+':
            // ...
    } // 结束switch
    // 结束switch: break #2 将控制权转移到这里
} // 结束while
```

标记为\#1的break语句负责终止连字符case标签后面的for循环。它不断不会终止switch语句，甚至连当前的case分支都终止不了。接下来程序继续执行for循环之后的第一条语句，这条语句可能连接这处理连字符的情况，也可能是另一条用于终止当前分支的break语句。

标记\#2的break语句负责终止switch语句，但是不能终止while循环。执行完这个break后，程序继续执行while的条件部分。

#### 5.5.2 continue语句

continue语句终止最近的循环中的当前迭代并立即开始下一次迭代。continue语句只能出现在for、while和do while循环的内部，或者嵌套在此类循环里的语句或块的内部。和break语句相似的是，出现在嵌套循环中的continue也仅作用于离他最近的循环。和break不同的是，只有当switch语句嵌套在迭代语句里的时候，才能在switch语句内部使用continue。

continue语句中断当前的迭代，但是仍然继续执行循环。对于while或do while语句来说，继续判断条件的值；对于传统的for循环来说，继续执行for语句头的expression，对于范围for语句来说，则是用序列的下一个元素初始化循环控制变量。

例如，下面的程序每次从标准输入中读取一个单词。循环只对那些以下划线开头的单词感兴趣，其他情况下，我们直接中止当前的迭代并获取下一个单词：

```c++
string buf;
while (cin >> buf && !buf.empty()) {
    if (buf[0] != '_')
        continue;// 接着读取下一个输入
    // 程序执行到了这里？说明当前输入时以下划线开头的；接着处理buf
}
```

#### 5.3.3 goto语句

goto语句的作用是从goto语句无条件跳转到同一函数内的另一条语句。

> 不要再程序中使用goto语句，因为它使得程序既难理解又难修改。

goto语句的语法形式是：

```c++
goto lable; // 带标签语句，可以作为goto的目标
```

标签标示符独立于变量或其他标识符的名字，因此标签标示符可以和程序中的其他实体的标示符使用同一个名字而不会互相干扰。goto语句和控制权转向的那条带标签的语句必须位于同一个函数内。

和switch语句类似，goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。

```c++
// ...
	goto end;
	int ix = 10; //错误：goto语句绕过了一个带初始化的变量定义
end:
	//错误，此处的代码需要使用ix，但是goto绕过了它的声明。
	ix = 42;
```

向后跳过一个已经执行的定义时合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：

```c++
//向后跳过一个已经初始化的变量定义时合法的
begin:
	int sz = get_size();
	if (sz <= 0) {
        goto begin;
    }
```

上述代码中，goto执行后销毁sz，因为跳回到begin的动作跨过了sz的定义语句，所以sz将重新定义并初始化。

### 5.6 try语句块和异常处理

异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。

当程序的某部分检测到一个它无法处理的问题是，需要用到异常去处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障，无法继续下去了，而且信号的发出方无需知道故障将在何处得到解决。一旦发出信号，检测出问题的部分也就完成了任务。

如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，则会发出报警信息。

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++语言中，异常处理包括：

- throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发(raise)异常。
- try语句块，异常处理部分使用try语句处理异常。try语句库常以关键字try开始，并以一个或多个catch子句处理。因为catch子句“处理”异常，所以他们也被称为异常处理代码。
- 一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。

在本节的剩余部分，我们将粉笔而介绍异常处理的这三个组成部分。在18.1节还将介绍更多关于异常的只是。

#### 5.6.1 throw表达式

程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。

举个简单的例子，1.5.2节把两个Sales_item对象相加的程序。这个程序检查它读入的记录是否是关于同一种书籍的，如果不是，输出一条信息然后退出。

```C++
Sales_item item1,item2;
cin >> item1 >> item2;
// 首先检查item1和item2是否表示同一种书籍
if (item1.isbn() == item2.isbn()) {
    cout << item1 + item2 << endl;
    return 0; // 表示成功
} else {
    cerr << "Data must refer to same ISBN" << endl;
    return -1; // 表示失败
}
```

在真实的程序中，应该把对象相加的代码和用户交互的代码分离开来。此例中，我们改写程序使得检查完成后不在直接输出一条信息，而是抛出一个异常

```c++
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
cout << item1 + item2 << endl; // 如果程序走到这里，代表两个ISBN相同，否则走的是抛出异常
```

类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。关于标准库异常类型更多的只是将在5.6.3节介绍。我们必须初始化runtime_error的对象，方式是提供给他一个string对象或者一个C风格的字符串，这个字符串中有一些关于异常的辅助信息。

#### 5.6.2 try语句块

try语句块的通用语法是

```c++
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // ...
```

try语句块的一开始是关键字try，随后紧跟着一个块，这个块就想大多数时候那样是花括号括起来的语句序列。

跟在try块之后的是一个或多个catch语句。catch语句包括三个部分：关键字catch、括号内一个(可能未命名的)对象的声明(称作异常声明)以及一个块。当选中了某个catch子句处理异常后，执行与之对于的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。

try语句中的program-statements组成程序正常逻辑，像其他任何块一样，program-statements可以有包括声明在内的任意C++语句。一如往常，try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问。

编写处理代码

在之前的例子里，我们使用了一个throw表达式以便面把两个代表不同书籍的Sales_item相加。我们假设执行Sales_item对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常，它的形式可能如下所示：

```c++
while(cin >> item1 >> item2) {
    try{
        // 执行添加两个Sales_item对象的代码
        // 如果添加失败，代码抛出一个runtime_error异常
    } catch (runtime_error err) {
        // 提醒用户两个ISBN必须一直，询问是否重新输入
        cout << err.what()
             << "\nTry Again? Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break; // 跳出while循环
    }
}
```

程序本来要执行的任务出现在try语句块中，这是因为这段代码可能会抛出一个runtime_error类型的异常。

try语句块对应一个catch子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch子句块内的语句。

给用户的提示信息输出了err.what()的返回值。我们知道err的类型是runtime_error，因此what是runtime_error的一个成员函数。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回的是C风格字符串)即(const char\*)。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。如果上一节编写的代码抛出异常，则本届的catch子句输出

```
Data must refer to same ISBN
Try Again? Enter y or n
```

函数在寻找处理代码的过程中退出

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个语句块的函数，新的try语句块可能又包含了有一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还没有找到任何匹配的catch子句，程序将转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，程序会调用terminate函数并终止当前程序的执行。

> 编写好异常安全的代码非常困难
>
> 要好好理解这句话：异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分则没完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。那些在异常发生期间正确执行了"清理"工作的程序被称作异常安全的代码。然而经验表明，编写异常安全的代码非常困难，这部分只是也远远超出了本书的范围
>
> 对于一些程序来说，当异常发生时只是简单的终止程序。此时，我们不需要担心异常安全的问题。但是对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们必须时刻清楚异常何时发生，异常发生后的程序该如何确保对象有效、资源无泄漏、程序处于合理状态，等等。

### 5.6.3 标准异常

C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以用在用户编写程序里，他们分别定义在4个头文件中：

- exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息
- stdexcept头文件定义了几种最常用的异常类，详细信息见表5.1
- new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节介绍
- type_info头文件定义了bad_cast异常类型，这种类型将在19.2节介绍

表5.1 \<stdexcept\>定义的异常类

```c++
// 表5.1 <stdexcept>定义的异常类
exception;			// 最常见的问题
runtime_error;		// 只有在运行时才能检测出的问题
range_error;		// 运行时错误：生成的结果超出了有意义的值域范围
overflow_error;		// 运行时错误：计算上溢
underflow_error;	// 运行时错误：计算下溢
logic_error;		// 程序逻辑错误
domain_error;		// 逻辑错误：参数对于的结果值不存在
invalid_argument;	// 逻辑错误：无效参数
length_error;		// 逻辑错误：试图创建一个超出该类型最大长度的对象
out_of_range;		// 逻辑错误：使用一个超出有效范围的值
```

标准库异常类只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。

我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值

其他异常类型的行为刚好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化方式。当穿件此类对象时，必须提供初始值，该初始值含有错误相关的信息。

异常类型只定义了一个名为what的成员函数，该函数没有任何类型，返回值是一个指向C风格字符串的const chart\*。该字符串的目的是提供关于异常的一些文本信息。

what返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。

## 6 函数

函数是一个命名了的代码块。我们通过调用函数执行相应的代码。函数可以有0个或者多个参数，而且通常会产生一个结果。可以重载函数，也就是说，同一个名字可以对应几个不同的函数。

### 6.1 函数基础

一个典型的函数定义包括以下部分：返回类型、函数名字、由0个或多个形参组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号之内。函数执行的操作在语句块中说明，该语句块称为函数体。

我们通过调用运算符来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数返回的类型。

编写函数

举个例子，编写一个求数的阶乘的程序。n的阶乘是从1到n所有数字的成绩，例如5的阶乘是120.

```c++
1 * 2 * 3 * 4 * 5 = 120
```

程序如下：

```c++
int fact(int val)
{
    int ret = 1;
    while (val > 0)
        ret *= val--;
    return ret;
}
```

函数的名字是fact，作用于一个整型参数没防御土匪整型值。return语句负责结束fact并返回ret的值。

调用函数

要调用fact函数，必须提供一个整数值，调用得到的结果也是一个整数：

```c++
int main()
{
    int j = fact(5);
    cout << "!5 = " << j << endl;
    return 0;
}
```

函数的调用完成两项工作：一是用实参初始化函数对于的形参，二是将控制权转移给被调用函数。此时，主调函数的执行暂时被终端，被调函数开始执行。

执行函数的第一步是隐式的定义并初始化它的形参。因此，当调用fact函数时，首先创建一个名为val的int变量，然后将它初始化为调用时所用的实参5.

当遇到一条return语句时函数结束执行过程。和函数调用一样，return语句也完成两项工作，一是返回return语句中的值(如果有的话)，二是将控制权从背调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。因此我们对fact的调用等价于如下形式

```c++
int val = 5;
int ret = 1;
while (val > 1)
    ret *= val--;
int j = ret;
```

形参和实参

实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求职顺序。编译器能以任意可能的顺序对实参求值。

实参的类型必须与对应的形参匹配，这一点与之前的规则是一致的，在初始化过程中初始值的类型也必须与初始化对象的类型匹配。函数有几个形参，就必须提供相同数量的实参。因为函数的调用规定实参应于形参数量一致，所以形参一定会被初始化。

在上面的例子中，fact函数只有一个int型的形参，所以我们每次调用它的时候，都必须提供一个能转换成int的实参:

```c++
fact("hello");		// 错误：实参类型不正确
fact();				// 错误：实参数量不足
fact(42, 10, 0);	// 错误：实参数量过多
fact(3.14);			// 正确：该实参能转换成int类型
```

因为不能将const char* 转换成int，所以第一个调用失败。执行调用的时候，实参会有隐式类型转换发生。

函数的形参列表

函数的形参列表可以为空，但是不能省略。要想定义一个不带形参的函数，最常用的办法就是书写一个空的形参列表。不过为了与C兼容，也可以用关键void表示函数没有形参

```c++
void f1() {} //隐式的定义空形参列表
void f2(void) {} //显示的定义空形参列表
```

形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参类型一样，也必须把两个类型都写出来

```c++
int f3(int v1, v2){} // 错误
int f4(int v1, int v2) {} // 正确
```

任意两个形参都不能同名，而且函数最外层作用域的局部变量也不能使用与函数形参一样的名字。

形参名是可选的，但是由于我们无法使用未命名的形参，所以形参一般都应该有个名字。偶尔，函数确实有个别形参不会被用到，则此类型餐通常不命名以表示在函数体内不会使用它。不管怎样，是否设置未命名的形参不影响调用时提供的实参数量。及时某个形参不被函数调用，也必须给他一个实参。

