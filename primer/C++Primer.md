# C++ Primer

## 1 开始

### 1.1 编写一个简单的C++程序

每个C++程序都包含一个或多个函数，其中一个必须命名为mian。

一个函数的定义包含四部分：返回类型、函数名、一个括号保卫的形参列表以及函数体。

main函数的返回值必须是int类型。int是一种内置类型，即语言自身定义的类型。

函数定义的最后一部分是函数体，它是一个以左花括号开始，以右花括号结束的语句块。

大多数C++语句以分号表示结束。如果忘记写分号会导致莫名其妙的编译错误。

在大多数系统中，main函数的返回值被用来指示状态。返回值0表示成功，非0的返回值由系统定义，通常用来指出错误类型。

#### 1.1.1 编译、运行程序

编译好程序后，我们就需要编译它。

程序源文件命名约定

​	程序文件通常被称为源文件。在大多数系统中，源文件的名字以一个后缀为结尾，后缀是由一个句点后接一个或多个字符组成的。后缀告诉系统这个文件是一个C++程序。不同的编译器使用不同的后缀命名约定。最常见的包括.cc、.cxx、.cpp、.cp以及.C。

从命令行运行编译器

```shell
$ cc prog1.cc
```

cc是编译器的名字，$是系统提示符。编译器生成一个可执行文件。windows会将这个可执行文件命名为prog1.exe，UNIX系统中的编译器通常会将可执行程序命名为a.out。

windows中查看状态:

```powershell
$ echo %ERRORLEVEL%
```

其他编译器：

GUN编译器的命令是g++：

```shell
$ g++ -o prog1 prog1.cc
```

为方便在机器内编译，编辑了一个脚本用于根据文件编译二进制到指定的文件夹内：

```shell
# /usr/bin/primer
filename=$1
build=$(echo $1 | awk -F'\.' '{print $1}' 2>/dev/null)

g++ -o ../build/$build $filename
```

### 1.2 初识输入输出

C++语言并未定义任何输入输出(IO)语句，取而代之，包含了一个全面的标准库(standard library)来提供IO机制(以及很多其他设施)。

iostream库，包含两个基础类型istream和ostream，分别表示输入流和输出流。一个流就是一个字符序列，是从IO设备读出或写入IO设备的。术语 流 想要表达的是，随着时间的推移，字符是顺序生成和消耗的。

标准输入输出对象

​	标准库定义了4个IO对象。为了处理输入，我们采用一个名为cin的istream类型的对象，这个对象也被称为标准输入。对于输出，我们使用一个名为cout的ostream类型的对象，这个对象也被称为标准输出。标准库还定义了其他两个ostream对象，名为cerr和clog。通常用cerr来输出警告和错误消息，也被称为标准错误。而clog被用来输出程序运行时的一般性信息。

系统通常将程序所运行的窗口和这些对象关联起来。因此我们读取cin，数据将从正在运行的窗口读入，当我们向cout、cerr、clog写入数据时，将会写到同一个窗口

一个使用IO库的程序

```c++
// prog2.cc
#include <iostream>

int main()
{
    std::cout << "Enter two numbers: ";
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2
              << " is " << v1 + v2 << "." << std::endl;
    return 0;
}
```

程序的第一行告诉我们想要使用iostream库，尖括号的名字指出了一个头文件。每个使用标准库设施的程序都必须包含相应的头文件。#include指令和头文件的名字必须写在同一行中，通常情况下，#include执行必须出现在所有函数之外。一般将一个程序的所有#include指令放在源文件的开始位置。

向流写入数据

​	C++ 中，一个表达式产生一个计算结果，它由一个或多个运算对象和通常是一个运算符组成。

​	输出运算符(<<)，接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值。词运算符将给定的值写入到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象。即：计算结果就是我们写入给定值的哪个ostream对象。

我们输出语句使用两次<<运算符，因为此运算符返回其左侧的运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。这样我们就可以将输出请求连接起来。

endl，被称为一个操作符的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。

使用标准库中的名字

​	std::cout中std::指出cout是定义在名字为std的命名空间中的。命名空间可以帮助我们避免在不经意的名字定义冲突。::是作用域运算符。

从流中读取数据

​	>> 输入运算符，类似于输出运算符

### 1.3 注释简介

C++中注释的种类

​	C++中有两种注释：单行注释和界定符对注释。单行注释以双斜线(//)开始，以换行符结束。当前行双斜线右侧的所有内容都会被编译器忽略，这种注释可以包含任何文本，包括额外的双斜线

​	另一种注释使用继承自C语言的两个界定符/\*和\*/。这种注释以/\*开始，以\*/结束，可以包含除\*/之外的任意内容，包括换行符。编译器将落在/\*和\*/之间的任意内容都当做注释。、

​	使用注释界定符注释时，建议朱市内的每行都以一个\*号开头，从而指出整个范围都是多行注释的一部分。

注释错误：

![image-20210616170224000](C:\Users\wangqiwei\AppData\Roaming\Typora\typora-user-images\image-20210616170224000.png)

### 1.4 控制流

#### 1.4.1 while语句

while语句反复执行一段代码，直至给定条件为假为止。

```c++
while (condition)
    statement
```

while语句的执行过程是交替的 检测condition条件和执行statement语句，直到condition语句为假时停止。所谓条件(condition)就是一个产生真或假的结果的表达式。只要condition为真，statement就会被执行。

#### 1.4.2 for语句

每个for语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：一个初始化语句(init-statement)、一个循环条件(condition)、以及一个表达式(expression)。

```c++
for (init-statement; condition; expression) {
    statement;
}
```



#### 1.4.3 读取数量不定的输入数据

当我们使用一个istream对象作为循环的条件condition时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或遇到一个无效的输入时(如接收一个int类型却收到一个字符串)，istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。

从键盘输入文件结束符

​	当从键盘想程序输入数据时，对于如何指出文件结束，不同操作系统有不同的约定，windows中输入文件结束符的方法是ctrl + z，然后按Enter或Return键。在UNIX系统中，包括Mac OS X系统中，文件结束符输入是用ctrl + d。

#### 1.4.4 if语句

```c++
if (condition)
    statement;
```

### 1.5 类简介

在C++中，我们通过定义一个类(class)来定义自己的数据结构。一个类定义了一个一个类型，以及与其关联的一组操作，类机制是C++最重要的特性之一。实际上C++最初的一个设计焦点就是能定义使用上像内置类型一样自然的类类型(class type)。

如前所见，为了使用标准库，我们必须包含相关的头文件。类似的，我们也需要使用头文件来访问为自己的应用程序所定义的类。习惯上，头文件根据其中定义的类的名字来命名。我们通常使用.h作为头文件的后缀名。但也有一些程序员习惯.H、.hpp、.hxx。标准库头文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定的要求。

使用文件重定向

```shell
# 从infile读取输入，输出结果到outfile
$ addItems <infile >outfile
```

#### 1.5.2 成员函数

成员函数是定义为类的一部分的函数，有时也被称为方法。我们常用一个类对象的名义来调用成员函数。如：`item.isbn()`。使用`.`点运算符来表达我们需要“名为item的对象的isbn成员”。点运算符只能用于类类型的对象。其左侧必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。

当用点运算符访问一个成员函数时，通常我们是想(效果也确实是)调用该函数。我们使用调用运算符(())来调用一个函数。调用运算符是一对圆括号，里面放置实参列表(可能为空)。

## 2 变量和基本类型

### 2.1 基本内置类型

C++定义了一套包括算术类型(arithmetic type)和空类型(void)在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如当函数不返回任何值时使用空类型作为返回类型。

#### 2.1.1 算术类型

算术类型分为两类：整型(integral type，包括字符和布尔类型在内)和浮点型。

算术型的尺寸(也就是该类型数据所占的比特数)在不同机器上有所差别。

<table>
    <tr>
        <th colspan="3" style="text-align:center;">表2.1：C++：算术类型</th>
    </tr>
    <tr>
        <th>类型</th>
        <th>含义</th>
        <th>最小尺寸</th>
    </tr>
    <tr>
        <td>bool</td>
        <td>布尔类型</td>
        <td>未定义</td>
    </tr>
    <tr>
        <td>char</td>
        <td>字符</td>
        <td>8位</td>
    </tr>
    <tr>
        <td>wchar_t</td>
        <td>宽字符</td>
        <td>16位</td>
    </tr>
    <tr>
        <td>char16_t</td>
        <td>Unicode字符</td>
        <td>16位</td></td>
    </tr>
    <tr>
        <td>char32_t</td>
        <td>Unicode字符</td>
        <td>32位</td>
    </tr>
    <tr>
        <td>short</td>
        <td>短整型</td>
        <td>16位</td>
    </tr>
    <tr>
        <td>int</td>
        <td>整型</td>
        <td>16位</td>
    </tr>
    <tr>
        <td>long</td>
        <td>长整型</td>
        <td>32位</td>
    </tr>
    <tr>
        <td>long long</td>
        <td>长整型</td>
        <td>64位</td>
    </tr>
    <tr>
        <td>float</td>
        <td>单精度浮点数</td>
        <td>6位有效数字</td>
    </tr>
    <tr>
        <td>double</td>
        <td>双精度浮点数</td>
        <td>10位有效数字</td>
    </tr>
    <tr>
        <td>long double</td>
        <td>拓展精度浮点数</td>
        <td>10位有效数字</td>
    </tr>
</table>



布尔类型(bool)类型的取值是真(true)或假(false)。

C++提供了几种字符类型，其中大多数支持国际化。基本字符类型是char，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节一样。

其他字符类型用于拓展字符集，如wchar_t、char16_t、char32_t。wchar_t类型用于确保可以存放机器最大拓展字符集中的任意一个字符，类型char16_t和char32_t则为Unicode字符集服务(Unicode是用于表示所有自然语言中字符的标准)。

除字符和布尔类型之外，其他整型用于表示(可能)不同尺寸的整数。C++语言规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中心定义的。

>内置类型的机器实现
>
>------
>
>计算机以比特序列存储数据，每个bit非0即1，例如101010101...
>
>大多数计算机以2的整数次幂个bit作为块处理，可寻址的最小内存块称为“字节(byte)”，存储的基本单位称为”字(word)“，它通常由几个字节组成。C++中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由8比特构成，字则由32或64bit构成，也就是4或8字节。
>
>大多数计算机将内存中的每个字节与一个数字(被称为“地址(address)”)关联起来，在一个字节为8比特，字为32比特的机器上，我们可能看到一个字的内存区域如下：
>
>736424	00111011
>
>736425	00011000
>
>736426	01110001
>
>736427	01100100
>
>其中，左侧是字节的地址，右侧是字节中8比特的具体内容。
>
>我们能够使用某个地址来表示从这个地址开始的大小不同的比特串，例如，我们可能会说地址736424的那个字或者地址736427的那个字节，为了赋予内存中某个地址明确的含义，必须首先知道存储在改地址的数据的类型。类型决定了数据所占的比特数以及该如何解释这些比特的内容。
>
>如果736424处的数据类型是float，并且该机器中float以32比特存储，那么我们就可以知道这个对象的内容占满了整个字。这个float数的实际值是依赖于该机器是如何存储浮点数的。

浮点数可以表示单精度、双精度和拓展精度值。C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，float以1个字(32bit)来表示，double以2个字(64bit)来表示，long double以3或4个字(即96或128bit)来表示。一般来说，类型float和double分别有7或16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。

带符号类型和无符号类型

除去布尔值和拓展的字符型之外，其他整型可以划分为带符号的(signed)和无符号的(unsigned)两种。带符号类型可以表示正数、负数和0，无符号类型则仅能表示大于等于0的值。

类型int、short、long和long long都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型，例如unsigned long。类型unsigned int可以缩写为unsigned。

与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要主义的是：类型char和类型signed char并不一样。尽管字符型有三中，但是字符的表现形式却只有两种：带符号的和无符号的，类型char实际上会表现为上述两种形式的一种，具体是哪种由编译器决定。

无符号类型中所有比特都用来存储值，例如8bit的unsigned char可以表示0-255区间内的值。C++标准并没有规定带符号类型的应如何表示，但是约定了在表示范围内正值和负值的量应平衡。因此，8bit的signed char理论上可以表示-127至127区间内的值，大多数现代计算机将十几秒的表示范围定位-128至127.

#### 2.1.2 类型转换

对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型转换(convert)为另一种相关类型。

这里说明一些当给某种类型的对象强行服了另一种类型的值时，到底会发生什么。

```c++
bool b = 42;			// b的值是1
int i = b;				// i的值是1
i = 3.14;				// i的值是3
double pi = i;			// pi的值是3.0
unsigned char c = -1;	// 假设char占8bit，c的值为255
signed char c2 = 256;	// 假设char占8bit，c的值是未定义的
```

类型所能表述的值的范围决定了转换的过程：

- 当我们把一个非布尔类型的算术值赋给布尔类型，初始值为0则结果为false，其他为true
- 当我们把一个布尔类型的算术值赋给非布尔类型，初始值为false则结果为0，true为1
- 浮点型赋给整数类型，进行了近似处理。结果将仅保留浮点数中小数点之前的部分
- 整数型赋给浮点型，小数部分记为0。如果改正数所占空间超过了浮点类型的容量，精度可能会有损失
- 当我们赋给无符号类型一个超出他范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。比如8bit大小的unsigned char表示0-255之间，那么-1就是对256取模后的余数255
- 当我们赋值给带符号类型一个超过它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能会产生垃圾数据。

含有无符号类型的表达式

当一个算术表达式中既有无符号数又有int值时，那个int值会被转换成无符号数。把int转换成无符号的过程和把int直接赋值给无符号变量一样。

```c++
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出-84
std::cout << u + i << std::endl; // 如果int占32位，输出4294967264
```

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：

```c++
unsigned u1 = 42, u2 =10;
std::cout << u1 - u2 << std::endl; // 32
std::cout << u2 - u1 << std::endl; // 4294967264
int a = 1, b = -1;
std::cout << u1 - a << std::endl; // 41
std::cout << u1 - b << std::endl; // 43
```

> 提示：切勿混用带符号类型和无符号类型

#### 2.1.3 字面值常量

一个形如42的值被称作字面值常量(literal)，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

整型和浮点型字面值

我们可以将整型字面值写作十进制数、八进制数或十六进制数。以0开头的整数代表八进制数，以0x或0X开头的代表16进制数。例如：

> 20 /\*十进制\*/			024  /\*八进制\*/			0x14  /\*十六进制\*/

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面值，那个符号并不在字面值之内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识:

> 3.14159	3.14159E0	0.	0e0	.001

字符和指腹从字面值

由单引号括起来的一个字符称为char型字面值，双括号括起来的零个或者多个字符则构成字符串型字面值

```c++
char a = 'a';	// 'a' 字符字面值
char b[] = "a";	// "a" 字符串字面值
```

字符串字面值的类型实际上是由常量字符构成的数组(array)。编译器在每个字符串结尾处添加一个空字符('\\0')，因此，字符串字面值的实际长度比它的内容多1。

如果一个字符串字面值过长，写成一行不太合适时，就可以采取分开书写的方式：

```c++
std::cout << "a really, really long string literalm "
          << "that spans two lines" << std::endl;
```

转义序列

有两类字符程序员不能直接使用：一类是不可打印(nonprintable)的字符，如退格或其他控制字符，因为他们没有可视的图符；另一类是C++语言中有特殊含义的字符(单引号、双引号、问号、反斜线)。这些情况下需要用到转义序列(escape sequence)，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：

> 换行符			\n	横向制表符	\t	报警(响铃)符	  \a
>
> 纵向制表符	\v	退格符			\b	双引号				\\"
>
> 反斜线			\\\	问号				\?	单引号				 \\'
>
> 回车符			\r	进纸符			\f

也可以用泛化的转义字符，其形式是\x后紧跟一个或多个十六进制数字，或者\后紧跟1-3个八进制数字，其中数字部分表示的是字符对应的数值。八进制后只能跟3个数字，超过的算作字符，\x后用到所有紧跟的数字。

指定字面值的类型

通过添加如表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型

```c++
wchar_t a = L'a';				// 宽字符型字面值
char b[] = u8"hi！";				// utf-8字符串字面值(utf-8用8位编码一个Unicode字符)
unsigned long long c = 42ULL;	// 无符号整型字面值
float d = 1E-3F;				// 单精度浮点型字面值
long double e = 3.14159L;		// 扩展精度浮点型字面值
```

<table>
    <tr style="text-align: center;">
        <th colspan="4">表2.2：指定字面值的类型</th>
    </tr>
    <tr style="text-align: center;">
        <th colspan="4">字符和字符串字面值</th>
    </tr>
    <tr>
        <th>前缀</th>
        <th colspan="2">含义</th>
        <th>类型</th>
    </tr>
    <tr>
        <td>u</td>
        <td colspan="2">Unicode 16字符</td>
        <td>char16_t</td>
    </tr>
    <tr>
        <td>U</td>
        <td colspan="2">Unicode 32字符</td>
        <td>char32_t</td>
    </tr>
    <tr>
        <td>L</td>
        <td colspan="2">宽字符</td>
        <td>wchar_t</td>
    </tr>
    <tr>
        <td>u8</td>
        <td colspan="2">UTF-8(仅用于字符串字面常量)</td>
        <td>char</td>
    </tr>
    <tr style="text-align: center;">
        <th colspan="2">整型字面值</th>
        <th colspan="2">浮点型字面值</th>
    </tr>
    <tr>
        <th>后缀</th>
        <th>最小匹配类型</th>
        <th>后缀</th>
        <th>类型</th>
    </tr>
    <tr>
        <td>u or U</td>
        <td>unsigned</td>
        <td>f or F</td>
        <td>float</td>
    </tr>
    <tr>
        <td>l or L</td>
        <td>long</td>
        <td>l or L</td>
        <td>long double</td>
    </tr>
    <tr>
        <td>ll or LL</td>
        <td>long long</td>
        <td colspan="2"></td>
    </tr>
</table>



如果后缀有U，则该字面值为无符号类型，那么根据字面值的大小按能匹配类型空间最小的一个作为其数据类型。

布尔字面值和指针字面值

true和false是布尔类型的字面值

nullptr是指针字面值

### 2.2 变量

#### 2.2.1 变量定义

变量定义的基本形式是：首先是类型说明符(type specifier)，随后紧跟一个或多个变量名组成的列表，其中变量名以逗号分开，最后以分号结束。列表中每个变量名的类型都有类型说明符指定，定义式还可以为一个或多个变量赋初值。

```c++
int sum = 0, value, //sum,value和units_sold都是int
	units_sold=0;	//sum和units_sold初值为0
Sales_item item;	//item的类型是Sales_item
//string是一种库类型，表示一个可变长的字符序列
std::string boox("0-201-78345-X"); //book通过一个sting字面值初始化
```

初始值

当对象在创建时获得了一个特定的值，我们说这个对象被初始化了；

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，赋值的含义是把对象的当前值擦除，而以一个新值来替代

列表初始化

初始化一个变量：

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，这种初始化的形式被称为列表初始化。现在，无论是初始化对象还是某些时候为对象赋新值，都可以用这样一组由花括号括起来的初始值。

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器会报错：

```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在精度丢失
int c{ld}, d = ld; // 正确：转换执行，丢失了精度
```

默认初始化

如果定义变量时没有指定初值，则变量被默认初始化，此时变量被赋予了"默认值"。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

如果是内置类型的变量未被显示初始化他，它的值由定义的位置决定。定义于函数体外的变量被初始化为0，但定义在函数体内部的内置类型变量**不被初始化**。一个未初始化的内置类型变量的值是未定义的，如果试图拷贝或者以其他形式访问此类值将引发错误。

每个类各自决定其初始化对象的方式，而且，是否允许不经过初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么。

#### 2.2.2 变量声明和定义的关系

为了允许程序拆分成多个逻辑部分来写，C++支持分离式编译机制，该机制允许程序分割为若干个文件，每个文件可被独立编译。

为了支持分离式编译，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明，而定义负责创建于名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：

```c++
extern int i; //声明i而非定义i
int j; //声明并定义j	
extern double pi = 3.14159;	//定义
```

任何包含了显示初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但这么做也就抵消了extern的作用。extern语句如果包含初始值就不是声明而是定义了。

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

变量能且只能被定义一次，但是可以被多次声明

#### 2.2.3 标识符

C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但对大小写字母敏感：

```c++
//定义4个不同的int变量
int somename, someName, SomeNmae, SOMENAME;
```

C++保留了一些名字供语言本身使用，这些名字不能用作标识符。同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下划线，同时也不能以下划线紧连大写字母开头。此外，定义在函数体之外的标识符不能以下划线开头。

变量命名规范

- 标识符要能体现实际含义
- 变量名一般用小写字母，如index，不要使用Index或INDEX
- 用户自定义的类名一般以大写字母开头，如Sales_items.
- 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan，不要使用studentloan。

<table>
  <tr>
    <th colspan="5" style="text-align: center;">表 2.3: C++关键字</th>
  </tr>
  <tr>
    <td>alignas</td>
    <td>continue</td>
    <td>fruebd</td>
    <td>register</td>
    <td>true</td>
  </tr>
  <tr>
    <td>alignof</td>
    <td>decltype</td>
    <td>goto</td>
    <td>reinterpret_case</td>
    <td>try</td>
  </tr>
  <tr>
    <td>asm</td>
    <td>default</td>
    <td>if</td>
    <td>return</td>
    <td>typedef</td>
  </tr>
  <tr>
    <td>auto</td>
    <td>delete</td>
    <td>inline</td>
    <td>short</td>
    <td>typeid</td>
  </tr>
  <tr>
    <td>bool</td>
    <td>do</td>
    <td>int</td>
    <td>signed</td>
    <td>typename</td>
  </tr>
  <tr>
    <td>break</td>
    <td>double</td>
    <td>long</td>
    <td>sizeof</td>
    <td>union</td>
  </tr>
  <tr>
    <td>case</td>
    <td>dynamic_cast</td>
    <td>mutable</td>
    <td>static</td>
    <td>unsigned</td>
  </tr>
  <tr>
    <td>catch</td>
    <td>else</td>
    <td>namespace</td>
    <td>static_assert</td>
    <td>using</td>
  </tr>
  <tr>
    <td>char</td>
    <td>enum</td>
    <td>new</td>
    <td>static_cast</td>
    <td>virtual</td>
  </tr>
  <tr>
    <td>char16_t</td>
    <td>explicit</td>
    <td>noexcept</td>
    <td>struct</td>
    <td>void</td>
  </tr>
  <tr>
    <td>char32_t</td>
    <td>export</td>
    <td>nullptr</td>
    <td>switch</td>
    <td>volatile</td>
  </tr>
  <tr>
    <td>class</td>
    <td>extern</td>
    <td>operator</td>
    <td>template</td>
    <td>wchar_t</td>
  </tr>
  <tr>
    <td>const</td>
    <td>false</td>
    <td>private</td>
    <td>this</td>
    <td>while</td>
  </tr>
  <tr>
    <td>constexpr</td>
    <td>float</td>
    <td>protected</td>
    <td>thread_local</td>
    <td></td>
  </tr>
  <tr>
    <td>const_cast</td>
    <td>for</td>
    <td>public</td>
    <td>throw</td>
    <td></td>
  </tr>
</table>



<table>
  <tr>
    <th style="text-align: center;" colspan=6>表 2.6: C++操作符替代名</th>
  </tr>
  <tr>
    <td>and</td>
    <td>bitand</td>
    <td>compl</td>
    <td>not_eq</td>
    <td>or_eq</td>
    <td>xor_eq</td>
  </tr>
  <tr>
    <td>and_eq</td>
    <td>bitor</td>
    <td>not</td>
    <td>or</td>
    <td>xor</td>
    <td></td>
  </tr>
</table>



#### 2.2.4 名字的作用域

不论是在程序的什么位置，使用到的名字都会指向一个特定的实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向不同的实体。

作用域(scope)是程序的一部分，在其中名字有其特定的含义。C++大多数作用域都以或括号分隔。同一个名字在不同作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。

名字main定义于所有花括号之外，它和其他大多数定义在函数体之内的名字一样拥有全局作用域(global scope)。一旦声明之后，全局作用域内的名字在整个程序范围内都可使用。

嵌套的作用域

作用域能彼此包含，被包含(或者说被嵌套)的作用域叫内层作用域(inner scope)，包含着别的作用域的作用域被称为外层作用域(outer scope)。

作用域一旦声明了某个名字，它所嵌套的所有作用域中都可以访问该名字，同时，允许在内层作用域中重新定义外层作用域中已有的名字。

```c++
#include <iostream>

// 该程序仅用于说明：函数内部不宜定义于全局变量同名的新变量
int reused = 42;
int main()
{
    int unique = 0; // unique拥有块作用域
    // 输出#1: 使用全局变量reused；输出42 0
    std::cout << reused << " " << unique << std::endl;
    int reused = 0; // 新建局部变量reused，覆盖了全局变量reused
    // 输出#2: 使用局部便令reused， 输出0 0
    std::cout << reused << " " << unique << std::endl;
    // 输出#3: 显示的访问全局变量reused；输出42 0
    std::cout << ::reused << " " << unique << std::endl;
    return 0;
}
```

由于全局作用域本身没有名字，所以当作用域操作符左侧为空时，向全局作用域请求获取作用域操作符右侧名字对应的变量。

### 2.3 复合类型

复合类型是指基于其他类型定义的类型。C++有几种复合类型，本章介绍两种：指针和引用。

前面提到，一条简单的声明语句是有一个数据类型和紧跟其后的一个变量名列表组成。其实更通用的描述是，一条声明语句由一个基本数据类型(basic type)和紧随其后的一个声明符(declarator)列表组成。每个声明符命名了一个变量并指定该变量与基本数据类型有关的某种类型。

目前为止我们接触到的声明符就是变量名，此时变量的类型也就是声明的基本数据类型。其实还有更复杂的声明符，它基于基本数据类型得到更复杂的类型，并把它指定给变量。

#### 2.3.1 引用

> C++11 新增了一种引用：所谓的右值引用(rvalue reference)，这种引用主要用于内置类。严格来说，我们使用术语引用时，值的其实是左值引用(lvalue reference)

引用(reference)为对象起了另一个名字，引用类型引用(refers to)另外一种类型，通过将声明符携程&d的形式来定义引用类型，其中d是声明的变量。

```c++
int ival = 1024;
int &refVal = ival; // refVal指向ival，是ival的另一个名字
int &refVal2; // 报错：引用必须被初始化
```

一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序吧引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

引用即别名

> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

定义引用之后，对引用进行的所有操作都是在与之绑定的对象上进行的。

```c++
refVal = 2; // 把2赋值给refVal绑定的对象上，即赋给了ival
int ii = refVal; //与ii = ival指定结果一样
```

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作初值，实际上是以与引用绑定的对象作为初始值。

```c++
int &refVal3 = refVal; //正确，refVal3绑定到了与refVal绑定的对象上，而不是对引用做引用
```

因为引用本身不是一个对象，所以不能定义引用的引用。

引用的定义

允许在一条语句中定义多个引用，其中每个引用标识符都必须以&符开头。

除了两种例外情况意外，其他所有引用的类型必须和与之绑定的对象严格匹配。而且引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。

#### 2.3.2 指针

指针(pointer)是指向(point to)另外一种类型的复合类型。与引用相似，指针也是实现了对其他对象的间接访问。然而指针和引用相比又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无需再定义时赋初值，和其他类型一样，在块作用域定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法将声明符写成\*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号\*。

获取对象的地址

指针存放某个对象的地址，想要获取该地址，需要使用取地址符(操作符&)。

```c++
int ival = 42;
int *p = &ival;//p存放ival的地址 或者说p是指向变量ival的指针
```

第二条语句把p定义为一个指向int的指针，随后初始化p令其指向名为ival的int对象，因为引用不是对象， 没有实际地址，所以不能定义指向引用的指针。

除了两种例外情况意外，其他所有指针的类型必须和与它指向的对象匹配。否则会发生错误。

指针值

指针的值（即地址）应属下列4种状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值

试图拷贝或以其他方式访问无效指针的值都将引发错误、编译器并不负责检查此类错误，这一点和试图使用未初始化的变量是一样的。访问无效指针的后果无法预计，因此必须清楚任意给定的指针是否有效。

尽管第2、3种形式的指针是有效的，但其使用同样收到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针(假定的)对象的行为不被允许。

利用指针访问对象

如果指针指向了一个对象，则允许使用解引用符(操作符*)来访问该对象：

```c++
int ival = 42;
int *p = &ival;
cout << *p; // 由符号*得到指针p所指向的对象 输出42
```

对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：

```c++
*p = 0; //由*得到指针p所指向的对象，即可由p为变量ival赋值
cout << *p;//输出0
```

空指针

空指针(null pointer)不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。列出几个生成空指针的方法：

```c++
int *p1 = nullptr;	//等价于int *p1 = 0;
int *p2 = 0; // 直接将p2初始化为字面常量0
//首先需要#include cstdlib
int *p3 = NULL;//等价于int *p3 = 0;
```

得到空指针最直接的方法就是用字面值nullptr来初始化指针，这也是C++11新标准引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。另一种就是和对p2的定义一样，直接将指针初始化为字面值0来生成空指针。

过去的程序还会用到一个名为NULL的预处理变量(preprocessor variable)来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是0。

预处理变量不属于std命名空间，它直接由预处理器负责管理，因此我们可以直接使用预处理变量而无需在前面加上std::。

当用到一个预处理变量时，预处理器会自动地将其替换成实际值，因此用NULL初始化指针和用0初始化指针是一样的。在新标准下，现在的C++程序最好用nullptr，同时应尽量避免用NULL。

把int变量直接赋给指针是错误的操作，即使int变量的值恰好是0页不行。

建议：**初始化所有指针，如果不知道该指向哪儿就初始化为空指针**

赋值与指针

指针和引用都能提供对其他对象的简介访问，然而在具体实现细节上二者有很大不同，其中最重要的一点是引用本身非一个对象。一旦定义了引用，就无法再令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：

```c++
int i = 42;
int *pi = 0;	// pi被初始化为空指针
int *pi2 = &i;	// pi2被初始化，存有i的地址
int *pi3;		// 如果pi3被定义与块内，无法确定值

pi3 = pi2;		// pi3指向pi2指向的对象
pi2 = 0;		// pi2指向空
```

有时候想要搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左边对象。

```c++
pi = &val; // pi的值被改变，现在pi指向了val
*pi = 0; // 由*得到指针pi所指向的对象,所以val的值变为0
```

其他指针操作

只要指针拥有一个合法值，就可以将它用在条件表达式中 。和采用算术值作为条件遵循的规则类似。如果指针的值是0，条件取false：

```c++
int ival = 1024;
int *p = 0;			// pi合法 是一个空指针
int *pi2 = &ival;	// pi2合法，存放这ival的地址
if (pi)		// 空指针， 条件值为false
    // ... 
if (pi2)	// pi2指向ival，值非0，为true
    // ...
```

任何非0指针对应的条件值都是true

对于两个类型相同的合法指针，可以用相等操作符(==)或不相等操作符(!=)来比较他们，比较的结果是布尔值。如果两个指针存放的地址值相同(两个指针相等)，有三种可能：它们都为空、都指向同一个对象、或者指向了同一个对象的下一个地址。需要注意的是，一个指针指向某对象，另一个指针指向另外对象的下一地址，此时也可能出现两个指针相等。

因为上述操作需要用到指针的值，因此所有指针必须是合法指针。

void\* 指针

void\*指针是一种特殊的指针类型，可用于存放任意对象的地址。一个void\*指针存放着一个地址，这一点和其他指针相似。不同的是，我们对这个指针存放对象是什么类型并不了解：

```c++
double obj = 3.14, *pd = &obj;
void *PV = &obj; // 正确，void*可以存放任何类型的对象地址
pv = pd; // pv可以存放任何类型的指针
```

利用void\*指针能做的事儿比较有限：拿他和别的指针做比较、作为函数的输入或输出、或者赋给另外一个指针。不能直接操作void\*所指的对象，因为我们并不知道这是个什么类型的对象，也就无法确定能在这个对象上做些什么操作。

概括来说，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。

#### 2.3.3 理解复合类型的声明

如前所述，变量的定义包括一个基本数据类型和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是说一条定义语句可能定义出不同类型的变量：

```c++
//i是一个int型证书，p是一个int型指针，r是一个int型引用
int i = 1024, *p = &i; &r = i;
```

指向指针的指针

一般来说，声明符中的修饰符的个数没有限制。当有多个修饰符连写在一起时，按照其逻辑关系解释即可。以指针为例，指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再放入另一个指针当中。

通过\*的个数可以区分指针的级别。也就是说\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```c++
int ival = 1;
int *pi = &ival;	// pi指向int类型整数
int **ppi = &pi;	// ppi指向int类型指针
```

使用指针的指针同样的，也需要解两次引用

```c++
std::cout << **ppi << std::endl; // 相当于ival
```

指向指针的引用

引用本身不是对象，因此不能定义指向引用的指针，但指针是一个对象，所以存在对指针的引用。

```c++
int i = 11;
int *p;			// 指针
int *&r = p;	// 指针的引用

r = &i;	// 赋值给引用指向的指针，即p指向i
*r = 0;	// 解引用，*p=0, 即i=0
```

要理解r的类型是什么，最简单的办法是从右往左阅读r的定义。离变量名最近的符号，本例中为&，对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，本例*&r表示r引用的是一个指针。

### 2.4 const 限定符

const对变量的类型加以限定之后，就定义了一个常量，可以随时警惕防止程序对变量的类型加以限定：

```c++
const int bufSize = 512;
bufSize = 111; // 错误，试图向const对象写值
```

任何试图向const对象赋值的行为都将引发错误，因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化，初始值可以是任意复杂的表达式、

初始化和const

const主要的限制就是只能在const类型的对象上执行不改变其内容的操作。

默认状态下，const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样。编译器将在编译过程中将用到该变量的地方全部换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。

为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须能访问到它的初始值才行，要做到这一点，就必须在每个用到变量的文件中都有对他的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象设定为仅在文件内有效。当多个文件中出现了同名的const对象时，其实等同于不同文件中分别定义了独立的变量。

某些时候有这样一种const变量，它的初始值不是一个常量表达式，但有确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的const变量，相反，我们想让这类const对象像其他(非常量)对象一样工作，也就是说，只在一个文件中定义const，而在多个文件中声明并使用它。

解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需要定义一次就够了：

```c++
// file1.cc定义并初始化了一个常量，该常量能够被其他文件访问
extern const int bufSize = fcn();
// file1.h头文件
extern const int bufSize;
```

如上述程序所示，file1.cc定义并初始化了bufSize。因为这条语句包含了初始值，因此它显然是一次定义，然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用

file1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件独有，它的定义也将在别处出现。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

#### 2.4.1 const的引用

可以把引用绑定到const对象上，称之为对常量的引用。与普通引用不同，对常量的引用不能被用作修改它所绑定的对象。

> 引用的对象是常量还是非常量可以决定其所能参与的操作，却不会影响引用和对象的绑定关系本身。

初始化和对const的引用

2.3.1提到，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式。

```c++
int i = 23;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上
const int &r2 = 23;// 正确
const int &r3 = r1 * 2’;// 正确
int &r4 = r1 * 2;//错误，r4是一个普通的非常量引用
```

要想理解这种情况的原因，最简单的办法就是弄清楚当一个常量引用被绑定到另外一种类型上时发生了什么：

```c++
double dval = 3.14;
const int &ri = dval;
```

此处ri引用了一个int型的数。对ri的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让ri绑定一个整数，编译器把上述代码变成了如下形式：

```c++
const int temp = deval;//由双精度浮点数生成一个临时的整型常量
const int &ri = temp; // 让ri绑定这个临时常量
```

在这种情况下，ri绑定了一个临时量对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求职结果时临时创建的一个未命名的对象。C++程序员常常把临时量对象简称为临时量。

接下来探讨ri不是常量时，如果执行了类似于上述初始化的过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值，注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则为什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。

对const的引用可能引用一个并未const的对象

必须认识到，**常量引用仅对引用可参与的操作做出了限定**，对于引用对象本身是不是一个常量未做限定。因为这个对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 23;
int &r1 = i;
const int &r2 = i; // r2也绑定i，但不允许通过r2修改i的值
r1 = 0; // 正确  r1非常量
r2 = 0; // 错误，常量引用
```

#### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：

```c++
const double pi = 3.14;
double *ptr = &pi; // 错误，ptr是一个普通指针
const double *ptr2 = &pi; // 正确，ptr2可以指向一个双精度常量
*ptr2 = 23; // 错误，不能给*ptr2赋值
```

2.3.2节提到，指针的类型必须与其所指对象的类型一致，但是有个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：

```c++
double dval = 3.14;
prt2 = &dval; // 正确 但是不能通过ptr2改变dval的值
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓**指向常量的指针仅仅要求不能通过该指针改变对象的值**，而没有规定那个对象的值不能通过其他途径改变。

const指针

指针是对象而引用不是，因此就想其他对象类型一样，允许把指针本身定义为常量。常量指针必须初始化，而且一旦初始化完成，则它的值，即存放在指针中的那个地址就不能再改变了。把\*放到const之前用以说明指针是一个常量，这样的书写形式隐含这一层意味，即不变的是指针本身而非指向的那个值：

```c++
int errNumb = 0;
int *const curErr = &errNumb; // curErr将一直指向errNumb
const double pi = 3.14;
const double *const pip = &pi; // pip是一个指向常量对象的常量指针
```

要想弄清楚这些声明的含义罪行之有效的方法就是从右向左读。此例中，例curErr最近的符号是const，意味着curErr本身是一个常量对象，对象的类型由其他部分决定，下一个符号是\*，意思是一个常量指针。最后，该声明语句的基础数据类型部分确定了常量指针指的是一个int对象。与之相似，pip是一个常量指针，它指向的对象时一个双精度浮点型常量。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于对象的类型，例如pip是一个指向常量的常量指针，则不论pip所指的对象的值还是自己本身存储的地址都不能改变。相反的，curErr指向的一个一般的非常量整数，那么久完全可以用curErr去修改errNumb的值。

#### 2.4.3 顶层const

如前所述，指针本身是一个对象，它又可以指向另一个对象。因此指针本身是不是常量以及指针所指的对象是不是常量就是两个独立的问题。用名词顶层const(top-level const)表示指针本身是个常量，而用名词底层const(low-level const)表示指针所指的对象是一个常量。

更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是指针类型既可以是顶层const，也可以是底层const，这一点和其他类型相比区别明显：

```c++
int i = 0;
int *const p1 = &i;// 不能改变p1的值，这是一个顶层const(指针常量
const int ci = 1; // 不能改变ci的值，这是一个顶层const(int常量
const int *p2 = &ci;// 允许改变p2的值，这是一个底层const(常量指针
const int *const p3 = p2; // 右边const为顶层，左边const为底层
const int &r = ci; // const引用 都是底层
```

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响：

```c++
i = ci; // 正确，拷贝ci的值，ci是一个顶层const，对此操作无影响
p2 = p3; //正确，p2、p3指向对象类型相同，p3顶层const的部分不影响
```

执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。

另一方面，底层const的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

```c++
int *p = p3; //错误，p3包含底层const的定义，p没有
p2 = p3;// 正确，p2和p3都是底层const
p2 = &i;// 正确int*可以转换成const int*
int &r = ci; // 错误，普通的int&不能绑定到int常量上
const int &r2 = i;// 正确，const int& 可以绑定到一个普通int上
```

p3既是顶层const又是底层const，拷贝p3是可以不在乎它是一个顶层const，但是必须清楚它指向的对象是一个常量，因此不能用p3去初始化p，因为p指向的是一个普通的非常量整数。另一方面，p3的值可以赋给p2，因为这两个指针都是底层const，尽管p3同时也是一个常量指针(顶层const)，仅就这次赋值而言不会有什么影响。

> 个人总结：
>
> 常量指针表示  指针自己是个常量  顶层const
>
> 指针常量表示  指针指向常量 底层const
>
> 指针常量要被赋给其他某变量【底层const的拷贝操作】，这个变量本身也得是个指针常量或引用常量【该对象也得具有底层const的资格】，或者两个对象的数据类型必须能够转换【int i = 1;conts int \*p2 = &i; 这里就是**将指针变量赋给指针常量**，没问题】

#### 2.4.4 constexpr和常量表达式

常量表达式是指值不会改变并在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。后面将会提到，C++语言中有几种情况下是要用到常量表达式的。

一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：

```c++
const int max_files = 20; // max_files是常量表达式
const int limit = max_files + 1; // limit是常量表达式
int staff_size = 27; // staff_size不是常量表达式
const int sz = get_size(); // sz不是常量表达式
```

尽管staff_size的初始值是个字面值表达式，但由于它的数据类型只是一个普通变量而非const int，所以它不是个常量表达式。尽管sz是一个常量，但它的具体指知道运行时才能获取到所以它也不是常量表达式。

constexpr变量

在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个const变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。可以这么说，在这种情况下，对象的定义和使用根本就是两回事儿。

C++11新标准规定，允许将变量生命为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：

```c++
constexpr int mf = 20; // 20是常量表达式
constexpr int limit = mf + 1;// mf+1是常量表达式
constexpr int sz = size(); //只有当size是一个constexpr函数时才是一个正确的声明语句
```

尽管不能使用普通函数作为constexpr变量的初始值，但是正如6.2.5将要介绍的，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量到了。

一般来说，如果你认定变量是一个常量表达式，那么就把它声明成constexpr类型。

字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见，容易得到，就把他们称为“字面值类型“

到目前为止接触过的数据类型汇总，算数类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。其他的一些字面值类型将在7.5.6节和19.3节介绍

尽管指针和引用都能定义成constexpr，但他们的初始值却受到严格的限制。一个constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象。

6.1.1节将要提到，函数体内定义的变量一般来说并未存放在固定地址中，因此constexpr指针不能指向这样的变量。相反，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。同样在6.1.1节中害将提到，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量

指针和constexpr

必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针指向的对象无关。

```c++
const int *p = nullptr;// p是一个指向整型常量的指针 (底层const
constexpr int *q = nullpr;// q是一个指向整型的常量指针(顶层const
```

p和q的类型相差甚远，p是一个指向常量的指针，q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。

与其他常量指针相似，constexpr指针既可以指向常量也可以指向一个非常量。

```c++
constexpr int *np = nullptr; // np是一个常量指针
int j = 0;
constexpr int i = 23;
// i和j都必须定义在函数体之外
constexpr const int *p = &i; //p是常量指针，指向常量i
constexpr int *p1 = &j; // p1是常量指针，指向i
```

### 2.5 处理类型

#### 2.5.1 类型别名

类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚的知道使用该类型的真实目的

有两种方法可用于定义类型别名。传统的方法是使用关键字typedef。

```c++
typedef double wages; //wages是double的同义词
typedef wages base, *p; //base是double的同义词，p是double*的同义词
```

其中，关键字typedef作为声明语句中的基本数据类型的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。

新标准规定了一种新的方法，使用别名名称来定义类型的别名：

```c++
using SI = Sales_item;
```

这种方法用关键字using作为别名的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名：

```c++
wages hourly, weekly; // 等价于doubel hourly, weekly;
SI item; // 等价于Sales_item item;
```

指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型pstring，它实际上是类型char*的别名：

```c++
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char的常量指针
const pstring *ps; // ps是一个指针，它的对象是指向char的常量指针
```

上述两条声明语句基本数据类型都是const pstring ，和过去一样，const是对给定类型的修饰。pstring实际上是指向char的指针，因此，const pstring 就是指向char的常量指针，而非指向常量字符的指针

遇到一条使用了类型别名的声明语句是，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义。

```c++
const char *cstr = 0； // 是对const pstring cstr的错误理解
```

再强调一遍，这种理解是错误的。声明语句中用到pstring时，该基本数据类型是指针。可是char\*重写了声明语句后，数据类型就变成了char，*称为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

#### 2.5.2 auto类型说明符

C++新标准引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来哪些只对应一种特定类型的说明符(比如double)不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值。

```c++
// 由val1和val2相加的结果可以推断出item的类型
auto item = val1 + val2;
```

此处编译器将根据val1和val2相加的结果来推断item的类型。如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item；如果这两个对的类型都是double，则item的类型就是double，以此类推

使用auto也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。

```c++
auto i = 0; *p = &i; // 正确，i是整型。p是整型指针
auto sz = 0; pi = 3.14// 错误，sz和pi类型不一致
```

复合类型、常量和auto

编译器推断出来的auto类型有时候和初始值类型并不完全一样，编译器会适当的改变结果类型使其更符合初始化规则。

首先，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的起始是引用对象的值。此时编译器以引用对象的类型作为auto的类型：

```c++
int i = 0, &r = i;
auto a = r; // a是一个整数 r是i的别名，而i是一个整数
```

其次，auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：

```c++
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数(ci的顶层const特性被忽略)
auto c = cr; // c是一个整数(cr是ci的别名，ci本身是一个顶层const)
auto d = &i; // d是一个整型指针
auto e = &ci;// e时一个指向整型常量的指针，属于底层const
```

如果希望推断出的auto是一个顶层const，需要明确指出

```c++
const auto f = ci;
```

还可以将引用的类型设为auto，此时原来的初始化规则仍然适用

```c++
auto &g = ci; // g是一个常量引用，绑定到ci
auto &h = 23; // 错误，不能为非常量引用绑定字面值
const auto &j = 23; //正确 可以为常量引用绑定字面值
```

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。

要在一条语句中定义多个变量，切记，符号&和符号\*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：

```c++
auto k = ci , &l = i; //k是整数，l只是整型引用
auto &m = ci, *p = &ci;// m是引用，p是指向常量的指针
// 错误 i的类型是int而&ci的类型是const int
auto &n = i, *p2 = &ci;
```

#### 2.5.3 decltype类型指示符

有时候 遇到这种情况：希望从表达式的类型判断出想要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并获取到它的类型，却不实际计算它的值：

```c++
decltype(f()) sum = x; // sum的类型就是函数f的返回类型
```

编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的哪个类型。

decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)：

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;// x的类型是const int(ci的类型
decltype(cj) j = x; // y的类型是const int&(cj的类型
decltype(cj) z; // 错误，const int&，引用类型必须初始化
```

需要指出的是，引用从来都作为其所指对象的同义词出现，只有在decltype处是一个例外。

decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节将要介绍的，有些表达式将想decltype返回一个引用类型。一般来说这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值。

```c++
// decltype的结果可以是引用类型
int i = 23, *p = &i, &r = i;
decltype(r+0) b; // 正确，加法的结果是int，所以b是int类型(未初始化)
decltype(*p) c; // 错误: *p即解引用的结果是&i，即int&，必须初始化
```

decltype与auto的另一重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况应当注意对于decltype所用的表达式来说，如果变量名加了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果类型就是改变量的类型；如果给变量加上了一层或多层括号，编译器会把它当成一个表达式。变量时一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：

```c++
// decltype的表达式如果是加上了括号的变量，结果将是引用、
decltype((i)) d; // 错误，d是引用类型，必须初始化
decltype(i) e; // 正确，e是一个int类型
```

切记：decltype((variable))双层括号的结果永远是引用，而decltype(variable)单层括号只有当variable本身是一个引用的时候结果才是引用。

赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。如果i是int类型，则 i=x 的类型是int&。

#### 2.6 自定义数据结构

从最基本的层面理解，数据结构是把一组相关的数据元素组织起来，然后使用他们的策略和方法。举一个例子，我们的Sales_item类把书本的ISBN编号、售出量及销售收入等数据组织在了一起，并提供诸如isbn函数、>>、<<、+、+=等运算在内的一系列操作，Sales_item类就是一个数据结构。

C++允许用户以类的形式自定义数据类型，而库类型string、istream、ostream等也都是以类的形式定义的，就想第1张的Sales_item类型一样。C++语言对类的支持甚多，事实上本书的第III部分和第IV部分都将大篇幅地介绍与类有关的知识。尽管Sales_item类非常简单，但是要想给出它的完整定义可在第14章介绍自定义运算符之后。

#### 2.6.1 定义Sales_data类型

尽管我们还写不出玩完整的Sales_item类，但是可以尝试着把那些数据元素组织到一起行程一个简单点儿的类。初步的想法是用户能直接访问其中的数据元素，也能实现一些基本的操作。

既然我们筹划的这个数据结构不带有任何运算功能，不妨把它命名为Sales_data类以示与Sales_item的区别。Sales_data初步定义如下：

```c++
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}
```

我们的类以struct关键字开始，紧跟着类名和类体(其中类体部分可以为空)。类体由花括号包围形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。

类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。

```c++
struct Sales_data { /** */ } accum, trans, *salesptr;
// 与上一语句等价，但可能更好一些
struct Sales_data { /** */ };
Sales_data accum, trans, *salesptr;
```

分号表示声明符的结束。一般来说，最好不要把对象的定义和类的定义放在一起，这么做无异于把两种不同的实体定义混在了一条语句里，一会儿定义类，一会儿又定义变量，显然这是一种不被建议的行为。

类数据成员

类体定义类的成员，我们的类只有数据成员。类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他Sales_data的对象。

定义数据成员的方法和定义普通变量一样：首先说明一个基本类型，然后紧跟一个或多个声明符。我们的类有3个数据成员：一个名为bookNo的string成员，一个名为units_sold的unsigned成员和一个名为revenue的double成员。每个Sales_data的对象都将包含着3个数据成员。

C++11新标准规定，可以为数据成员提供一个类内初始值。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。因此当定义Sales_data的对象时，units_sold和revenue都将初始化为0，bookNo将初始化为空字符串。

对类内初始值的限制与之前介绍的类似：或放在或括号里，或者放在等号右边，记住不能使用圆括号。

#### 2.6.2 使用Sales_item类

和Sales_item类不同的是，我们自定义的Sales_data类没有提供任何操作，Sales_data的使用者如果想执行什么操作必须自己手动实现。

```c++
// 两个相加
void add_same()
{
    Sales_data data_all, data;
    if (std::cin >> data.bookNo >> data.units_sold >> data.revenue) {
        data_all = data;
        while (std::cin >> data.bookNo >> data.units_sold >> data.revenue){
            if (data.bookNo == data_all.bookNo) {
                data_all.units_sold += data.units_sold;
                data_all.revenue += data.revenue;
            } else {
                std::cout << "两个不一样" << std::endl;
                return;
            }

        }
    }
    std::cout << "BookNo: " << data_all.bookNo
              << "\nUnits Sold: " << data_all.units_sold
              << "\nRevenue: " << data_all.revenue
              << std::endl;
}
// 多个相加
void add_all()
{
    Sales_data data_all, data;
    if (std::cin >> data.bookNo >> data.units_sold >> data.revenue) {
        data_all = data;
        while (std::cin >> data.bookNo >> data.units_sold >> data.revenue){
            if (data.bookNo == data_all.bookNo) {
                data_all.units_sold += data.units_sold;
                data_all.revenue += data.revenue;
            } else {
                std::cout << "BookNo: " << data_all.bookNo
                          << "\tUnits Sold: " << data_all.units_sold
                          << "\tRevenue: " << data_all.revenue
                          << "\tAvg: " << data_all.revenue / data_all.units_sold
                          << std::endl;
                data_all.bookNo = data.bookNo;
                data_all.units_sold = data.units_sold;
                data_all.revenue = data.revenue;
            }

        }
    }
    std::cout << "BookNo: " << data_all.bookNo
              << "\tUnits Sold: " << data_all.units_sold
              << "\tRevenue: " << data_all.revenue
              << "\tAvg: " << data_all.revenue / data_all.units_sold
              << std::endl;
}
```

#### 2.6.3 编写自己的头文件

尽管如19.7所讲可以在函数体内定义类，但是这样的类毕竟受到了一些限制。所以，类一般都不定义在函数体内。当在函数体外部定义类时，在各个指定的源文件中可能只有一处该类的定义。而且，如果要在不同文件中使用同一个类，类的定义就必须保持一致。

为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样。例如库类型string在名为string的头文件中定义。又如，我们应该把Sales_data定义在名为Sales_data.h的头文件中。

头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量等。头文件也经常用到其他头文件的功能，例如我们的Sales_data类包含一个string成员，所以Sales_data.h必须包含string.h头文件。同时，使用Sales_data类的程序为了能操作bookNo成员需要再一次包含string,h头文件。

这样，事实上使用Sales_data类的程序就先后包含了两次string.h头文件：一次是直接包含的，另有一次是随着包含Sales_data.h被隐式地包含进来的。有必要在书写头文件时做适当处理，使其遇到多次包含的情况下也能安全和正常的工作。

> 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明

预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器，它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分的改变我们所写的程序。之前已经用到一项预处理器的功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。

C++程序还会用到的一项预处理功能是头文件保护符，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指令的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**#ifndef**当且仅当变量未定义时为真。一旦结果检查为真，则执行后续操作直至遇到**#endif**为止。

使用这些功能就能有效的防止重复包含的发生：

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif
```

第一次包含Sales_data.h时，#ifndef的检查结果为真，预处理器将顺序执行后面的操作直至遇到endif为止。此时预处理变量SALES_DATA_H的值将变为已定义，而且Sales_data.h也会被拷贝到我们的程序中来。后面如果再一次包含Sales_data.h，则ifndef的结果为假，编译器将忽略ifndef到endif之间的部分

> 预处理器变量无视C++语言中关于作用域的规则

整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中其他实体发生名字冲突，一般把预处理变量的名字全部大写。

> 头文件及时(目前还)没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只需要习惯性的加上就可以了，没必要太在乎你的程序到底需不需要

## 3 字符串、向量和数组

第2章介绍的内置类型是由C++语言直接定义的。这些类型，比如数字或字符，体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型，他们尚未直接实现到计算机硬件中。

本章将介绍两种最重要的标准库类型：string和vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类型，和其他内置类型一样，数组的实现与硬件密切相关，因此相较于标准库类型string和vector，数组在灵活性上稍显不足。

在开始介绍标准库类型之前，先来学习一种访问库中名字的简单方法。

### 3.1 命名空间的using声明

std::cin中是用作用域操作符::的含义是：编译器从左侧名字所示的作用域中寻找右侧那个名字。因此，std::cin的意思就是要使用命名空间std中的名字cin。更简单的最安全办法就是使用using。

有了using声明就无需专门的前缀(形如命名空间::)也能使用所需的名字了。using声明具有如下的形式:

```c++
using namespace::name;
```

一旦声明了上述语句，就可以直接访问命名空间终端名字

```c++
#include <iostream>
// using声明，当我们使用名字cin时，从std命名空间中获取它
using std::cin;
int main()
{
    int i;
    cin >> i; // 正确
    cout << i; // 错误
    std::cout >> i; //正确
    return 0;
}
```

每个名字都需要独立的using声明

按照规定，每个using声明引入命名空间中的一个成员。例如，可以把要用到的标准库中的名字都以using声明的形式表示出来：

```
#include <iostream>
using std::cin;
using std::cout; using std::endl;
int main()
{
    int i;
    cin >> i;
    cout << i << endl; 
    return 0;
}
```

C++的形式比较自由，因此既可以一行只放一条声明语句，也可以一行放多条。不过要注意，用到的每个名字都必须要有自己的声明语句，而且每个名字都得以分号结束。

头文件不应包含using声明

位于头文件的代码，一般来说不用管使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件中有某个using声明，那么每个使用了该头文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能会产生始料未及的名字冲突。

### 3.2 标准库类型string

标准库类型string表示可变长的字符序列，使用string类型必须首先包含string头文件。作为标准库的一部分，string定义在命名空间std中。接下来的示例都假定已包含了以下代码：

```c++
#include <string>
using std:;string;
```

本节描述最常用的string操作，9.5节还有将介绍另外一些

C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。

#### 3.2.1 定义和初始化string对象

如何初始化类的对象是由类本身决定的。一个类可以定义很多初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。表3.1列出了初始化string对象最常用的一些方式，下面是几个例子。

```c++
string s1;// 默认初始化，是个空字符串
string s2 = s1;	// s2是s1的副本
string s3 = "helloworld"; // s3是字符串字面值的副本
string s4(10, 'c');// s4的内容是cccccccccc
```

可以通过默认的方式初始化一个string对象，这样就会得到一个空的string，也就是说，该string对象没有任何字符。如果提供了一个字符串字面值，则该字面值中除了最后那个空字符外其他所有的字符都被拷贝到新创建的string对象中去。如果提供的是一个数字和一个字符，则string对象的内容是给定字符连续重复若干次后得到的序列。

表3.1 初始化string对象的方式

```c++
string s1;				// 默认初始化，s1是个空串
string s2(s1);			// s2是s1的副本
string s3 = s1;			// 等价于s2(s1),s3是s1的副本
string s4("value");		// s4是字面值value的副本，除最后的空字符
string s5 = "value";	// 同上一行，s5是字面值value的副本
string s6(n, 'c');		// 把s6初始化为由连续n个字符c组成的字符串
```

直接初始化和拷贝初始化

C++语言有几种不同的初始化方式，通过string我们可以看到这些初始化方式之间有什么区别和联系。如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把右侧的初始值拷贝到右侧新创建的对象中区。与之相反，如果不使用等号，则执行的是直接初始化。

当初始值只有一个时，使用直接初始化或者拷贝初始化都行，如果像s6那样初始化要用到的值由多个，一般来说只能使用直接初始化的方式。

```c++
string s7 = "hello"; // 拷贝初始化
string s8("hello"); // 直接初始化
string s9(10, 'c'); // 直接初始化
```

对于用多个值初始化的情况，非要用拷贝初始化的方式处理也不是不可以，不过需要显示的创建一个(临时)对象用于拷贝：

```c++
string s10 = string(10, 'c'); // 拷贝初始化, ’cccccccccc‘
```

这里实际上是先创建了一个string对象，然后拷贝给s10。本质上等于下面的两条语句：

```c++
string temp(10, 'c');
string s10 = temp;
```

其实我们可以看到，尽管初始化s10的语句合法，但和初始化s9的方式比起来可读性较差，也没有任何补偿优势。

#### 3.2.2 string对象上的操作

一个类除了要规定初始化其对象的方式外，还要定义对象上所能执行的操作。其中，类既能定义通过函数名调用的操作，就像Sales_item类的isbn函数那样，也能定义<<、+等各种运算符在该类对象上的新含义。表3.2中列举了string上的大多数操作。

表3.2 string的操作

```c++
os << s;		// 将s写到输出流os中，返回os
is >> s;		// 从is中读取字符串赋给s，字符串以空白分隔，返回is
getline(is, s);	// 从is中读取一行赋给s，返回is
s.empty();		// s为空返回true，否则false
s.size();		// 返回s中字符的个数
s[n];			// 返回s中第n个字符的引用，位置n从0计起
s1+s2;			// 返回s1和s2连接后的结果
s1=s2;			// 用s2的副本代替s1中原来的字符
s1==s2;			// 如果s1和s2字符完全一样，则相等，对字母大小写敏感
s1!=s2;			// 字符不完全一样，则不相等
<,<=,>,>=		// 利用字符在字典中的顺序进行比较，且对大小写字符敏感
```

读写string对象

使用标准库中的iostream来读写int、double等内置类型的值，同样，也可以使用IO操作来读取string对象。

```c++
int main()
{
    string s1, s2;
    cin >> s1 >> s2;
    cout << s1 << s2 << endl;
    return 0;
}
```

在执行读取操作时，string对象会自动忽略开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符读起，知道遇见下一处空白为止。

和内置类型的输入输出操作一样，string对象的此类操作也是返回运算符左侧的运算对象作为其结果。因此，多个输入或者多个输出可以连写到一起。

读取未知数量的string对象

```c++
string s;
while(cin >> s)
    cout << s << endl;
```

使用getline读取一整行

有时我们希望能在最终得到的字符串中保留输入时的空白符，这时应该用getline函数替代原来的>>运算符。getline函数的参数是一个输入流合一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存在换行符)。getline只要一遇到换行符就结束读取操作并返回结果，哪怕一开始就是换行符也是如此，那么所得的结果是个空string

和输入运算一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件，我们也能用getline作为条件。例如，我们可以通过改写之前的程序让他一次输出一整行，而不是每行输出一个词了：

```c++
string s;
while(getline(cin, s))
    cout << s << endl;
```

因为s中不包含换行符，所以我们手动的加上换行操作符。和往常一样，使用endl结束当前行并刷新显示缓冲区。

触发getline函数返回的哪个换行符实际上被丢弃掉了，得到的string对象中并不包含该换行符。

string的empty和size操作

顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值。和Sales_item类的isbn成员一样，empty也是string的一个成员函数。调用该函数的方法很简单。只需要使用点操作符指明是哪个对象执行了empty函数就可以了。

通过改写之前的程序，可以做到只输出非空的行：

```c++
string s;
while(getline(cin, s))
    if (!s.empty())
        cout << s.size() << "\t" << s << endl;
```

在上面的程序中，if语句的条件部分使用了逻辑非运算符(!)，它返回与其运算对象相反的结果。此例中，如果str不为空则返回真。

size函数返回string对象的长度(即string对象中字符的个数。)

string::size_type类型

对于size函数来说，返回一个int或者如前面2.1.1节所述的那也返回一个unsigned似乎都是合情合理的。但其实size函数返回的是一个string::size_type类型的值，下面就对这种新的类型稍作解释。

string类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体现了标准库类型与机器无关的特性。类型size_type即是其中一种。具体使用的时候，通过作用域操作符表明名字size_type是在类string中定义的。

尽管我们不太清楚string::size_type类型的细节，但有一点是肯定的：它是一个无符号类型的值而且能够放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string::size_type类型的。

过去，string::size_type这种类型有点儿神秘，不太容易理解和使用。在C++11新标准中，允许编译器通过auto或者decltype来推断变量的类型:

```c++
auto len = line.size();
```

由于size函数返回的是一个无符号整形数，切记如果表达式中混用了带符号数和无符号数将可能产生意想不到的后果。例如，假设n是一个具有负值的int，则表达式s.size()<n的判断几乎肯定是true。这是因为负值n会自动转换成一个比较大的无符号值。

> 如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。

比较string对象

string类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较string对象中的字符，并且对大小写敏感，也就是说，在比较时同一个字母的大小写是不同的。

相等性运算符(==和!=)分别检验两个string对象相等或不相等。string对象相等意味着它们的长度相等而且包含的字符也完全相同。关系运算符<，<=，>，>=分别检验一个string对象是否小于、小于等于、大于、大于等于另外一个对象。上述这些运算符都依照大小写敏感的字典顺序：

1. 如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象
2. 如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一队相异字符比较的结果

```c++
string str = "Hello";
string phrase = "Hello world";
string slang = "Hiya";
```

根据规则1判断，对象str小于对象phrase，根据规则2判断，slang大于phrase也大于str。

为string对象赋值

一般来说，在设计标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类型都支持赋值操作。对于string而言，允许把一个对象的值赋给另一个对象：

```c++
string st1(10, 'c'), st2;
st1 = st2; // 赋值，用st2的副本替换st1的内容，此时，两者皆为空
```

两个string对象相加

两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象拼接而成。也就是说，对string对象使用加法运算符(+)的结果是一个新的string对象，它所包含的字符是由两部分组成：前半部分是加号左侧string对象所含的字符、后半部分是加号右侧string对象所含的字符。另外，复合赋值运算符(+=)负责把右侧string对象的内容追加到左侧string对象的后面：

```c++
string s1 = "hello, ", s2 = "wirld\n";
string s3 = s1 + s2; // s3的内容是hello, world\n
s1 += s2; // s1的内容同s3
```

字面值和string对象相加

及时一种类型并非所需，我们也可以使用它，不过前提是该种类型可以自动转换成所需的类型。因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。利用这一点将之前的形式改写为以下形式：

```c++
string s1 = "hello", s2 = "world"; // s1,s2都没有标点符号
strinfg s3 = s1 + ", " + s2 + "\n";
```

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须缺包每个加法运算符(+)的两侧的运算对象至少有一个是string:

```c++
string s4 = s1 + ", "; // 正确
string s5 = "hello" + ", "; // 错误，两个运算对象都不是string
// 正确，每个加法运算符都有一个运算对象是string
string s6 = s1 + ", " + "world";
string s7 = "hello" + ", " + s2; // 错误，不能将字面值直接相加
```

s6的初始化形式之前没有出现过，但其实它的工作机理和连续输入连续输出是一样的。

> 由于历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。

#### 3.2.3 处理string对象中的字符

表3.3 cctype头文件中的函数

```c++
isalnum(c);		// c是字母或数字时为真
isalpha(c);		// c是字母时为真
iscntrl(c);		// c是控制字符时为真
isdigit(c);		// c是数字时为真
isgraph(c);		// c不是空格但可打印时为真
islower(c);		// c是小写字母时为真
isprint(c);		// c是可打印字符时为真(c是空格或可视形式)
ispunct(c);		// c是标点符号时为真(c不是控制字符、数字、字母、可打印空白中的一种)
isspace(c);		// c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)
isupper(c);		// c是大写字母时为真
isxdigit(c);	// c是十六进制数字时为真
tolower(c);		// 如果c是大写字母，输出对应的小写字母，否则原样输出
toupper(c);		// 如果c是小写字母，输出对应的大写字母，否则原样输出
```

> 建议：使用c++版本的c标准库头文件
>
> ------
>
> C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，c++则将这些文件命名为cname，也就是去掉了.h后缀，而在name前面添加了字母c，这里的c表示这是一个属于C语言标准库的头文件
>
> 因此cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合c++语言的要求，特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然
>
> 一般来说C++程序应该使用cname的头文件而不使用name.h形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记那些是从c语言来的，那些是c++所独有的。

处理每个字符？使用基于范围的for语句

如果想对string的每个字符做点儿什么操作，目前最好的办法是使用c++11新标准提供的范围for语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：

```c++
for (declaration : expression)
    statement
```

其中expression部分是一个对象，用于表示一个序列。declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量都会被初始化为expression部分的下一个元素值。

一个string对象表示一个字符的序列，所以string对象可以作为范围for语句的expression部分。举一个简单的例子，我们可以吧string对象中每一个字符按行输出出来。

```c++
string str("Hello, world!");
for (auto c : str)
    cout << c << endl;
```

auto关键字自动推断c的类型，这里c是char。该循环可以读做对于字符串str中的每个字符c，执行某某操作。

```c++
string s;
getline(cin, s);
decltype(s.size()) punct_count = 0;
for (auto c : s){
    if (ispunct(c))
        punct_count++;
}
cout << "标点符号数量：" << punct_count << endl;
```

使用范围for语句改变字符串中的字符

想要改变string对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变他绑定的字符。

新的例子，将字符串改写为大写字母的形式。为了做到这一点，我们使用库函数toupper，该函数接受一个字符，输出其大写形式。这样，为了把整个string对象全部转换成大写，只要对其中每个字符调用toupper函数并将结果赋给原字符即可。

```c++
string str("Hello, world!");
for (auto &c : str)
    c = toupper(c);
```

只处理一部分字符？

如果要处理string对象中的每一个字符，使用范围for是个好主意。然而，有时我们需要访问的只是其中一个字符，或者访问多个字符但遇到某个条件就要停下来。例如，同样是将字符改为大写，不过新的要求不再是对整个字符串都这样做，而仅仅是把string对象中第一个字母或单词大写。

要想访问string对象中的单个字符有两种方式：一种是使用下标，另外一种是迭代器，其中关于迭代器的内容将在3.4节和第9章介绍。

下标运算符\[\]接收的参数是string::size_type类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。

string对象的下标从0计起，最后一个是string.size()-1。string对象的下标必须大于等于0而小于string.size()。使用超出范围的下标会引发不可预知的结果。

下标的值乘坐下标或索引，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。

下面的程序使用下标运算符输出string对象的第一个字符：

```c++
if (!s.empty)
    cout << s[0] << endl;
```

在访问指定字符前，首先检查s是否为空。其实不管什么时候只要对string对象使用了下标，都要确定那个位置上有值。如果s为空，则s[0]的结果是未定义的。

只要字符串不是常量，就能为下标运算符返回的字符赋新值。

使用下标执行迭代

```c++
for (decltype(s.size()) index = 0;
     index != s.size() && !isspace(s[index]);
     ++index)
    s[index] = toupper(s[index]);
```

逻辑与运算符：最重要的一点是,C++语言规定只有当左侧为真时才会检测右侧运算对象的情况。

> 注意下标的合法性
>
> 使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0而小于字符串的size()的值。一种简便易行的办法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时，代码只需要保证下标小于size()的值就可以了。

使用下标执行随机访问

一段程序将0-15转换成16进制：

```c++
string hex="0123456789abcdef";
decltype(hex.size()) index;
while (cin >> index) {
    if (index >=0 && index < 16)
        cout << hex[index];
    else
        cout << "Error, number(0-15)."
}
cout << endl;
```

### 3.3 标准库类型vector

标准库类型表示对象的集合，其中所有对象的类型都相同。集合中对每个对象都有一个与之相对于的索引，索引用于访问对象。因为vector容纳着其他对象，所以它常被称作容器。

要想使用vector，必须包含合适的头文件，在后续的例子中都将假设做了如下using声明：

```c++
#include <vector>
using std::vector;
```

C++语言既有类模板，也有函数模板，其中vector是一个类模板。只有对C++有了相当深入的理解才能写出模板。事实上，我们到第16章菜户学习如何自定义模板。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一堆尖括号，在括号内放上信息。

以vector为例，提供的额外信息是vector内存放对象的类型：

```c++
vector<int> ivec; // ivec保存int类型的对象
vector<Sales_item> Sales_ivec; // 保存Sales_item类型的对象
vector<vector<string>> file; // 该向量保存的是vector对象
```

> vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector对象，甚至组成vector的元素也可以是vector。

需要指出的是，在早期版本的C++标准中如果vector的元素还是vector(或者是其他模板类型)，需要在外层vector对象的右尖括号与其元素之间添加一个空格。如vector\<vector\<string\>\>应写成vector\<vector\<string\> \>。

#### 3.3.1 定义和初始化vector对象

和任意类型一样，vector模板控制着定义和初始化向量的方法。

表3.4：初始化vector对象的方法

```c++
vector<T> v1;			// 空vector，元素T类型，默认初始化
vector<T> v2(v1);		// 包含有v1所有元素的副本
vector<T> v2 = v1;		// 等价于v2(v1)
vector<T> v3(n, val);	// 包含n个T类型元素，值都为val
vector<T> v4(n);		// 包含n个T类型元素，元素值初始化
vector<T> v5{a,b,c};	// 包含了初始值个数的元素，每个元素赋初值
vector<T> v5 = {a,b,c};	// 等价于v5{a,b,c}
```

可以默认初始化vector对象，这样可以创建一个指定类型的空vector。最长间的办法即是如此，然后再逐一添加需要的元素。

```c++
vector<T> v1; // 默认初始化，svec不含任何元素
```

当然也可以在定义vector对象时指定元素的初始值。例如把一个vector对象的元素拷贝给另一个vector对象。此时，新vector对象的元素就是原vector对象的副本。注意两个副本的对象必须相同。

```c++
vector<int> ivec; // 初始状态为空
// 在此处给ivec添加一些值
vactor<int> ivec2(ivec);//把ivec的元素拷贝给ivec2
vector<int> ivec3 = ivec;//把ivec的元素拷贝给ivec3
vector<string> svec(ivec);//错误，类型不同
```

列表初始化vector对象

C++11新标准提供列表初始化。此用花括号括起来的0个或多个初始元素值被赋给vector对象。（必须是花括号

```c++
vector<T> v5 = {a,b,c};
```

在大多数情况下C++初始化vector对象的方法可以相互等价的使用，不过也并非一直如此。目前已经介绍的两种例外情况是：其一，使用拷贝初始化时(即使用=时)，只能提供一个初始值。其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值放在花括号里进行列表初始化，不能放在圆括号里。如

```c++
vector<int> v1{1,2,3};//正确 列表初始化
vector<int> v1(1,2,3);//错误
```

创建指定数量的元素

```c++
vector<T> v3(n, val);
```

值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

如果vector对象的元素是内置类型，如int，则元素初始值为0，如果元素是某种类类型，比如string，则元素由类默认初始化。

```c++
vector<T> v4(n);
```

对这种初始化的方式有两个特殊限制，其一，有些类要求必须明确的提供初始值。其二，如果值提供了元素的数量而没有设定初始值，只能使用直接初始化，而不是拷贝初始化。

列表初始值还是元素数量？

在某些情况下，初始值的真实含义依赖于传递初始值时用的是花括号还是圆括号。例如

```c++
vector<int> v1(10);		// 初始化10个元素，每个元素都是0
vector<int> v1{10};		// 初始化1个元素，值为10

vector<int> v2(10, 11);	// 初始化10个元素，每个元素都是11
vector<int> v2{10, 11};	// 初始化2个元素，值为10和11
```

如果是用的是圆括号，可以说提供的值是用来构造vector对象的。如果用的是花括号，可以表述成我们想列表初始化该vector对象。

另一方面，如果初始化时使用了花括号的形式但提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。

```c++
vector<string> v5{"hi"}; //列表初始化，1个元素
vector<string> v6("hi"); //错误，字符串字面值不能初始化vector
vector<string> v7{10};	 //v7有10个默认初始化的元素
vector<string> v8{10, "hi"};//v8有10个初始值为hi的元素
```

#### 3.3.2 向vector对象中添加元素

对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个vector对象的副本、所有元素的初始值都一样。然而更常见的情况是，创建一个vector对象时并不清楚实际所需元素个数，元素的值也经常无法确定。还有些时候即使元素初值已知，但如果这些值总量较大而且各不相同，那么在创建vector对象的时候执行初始化操作也会咸的过于繁琐。

可以创建一个空vector，然后再使用vector的成员函数push_back向其中天机暗元素。push_back负责把一个值当成vector对象的尾元素push到vector对象的尾端back。

```c++
vector<int> ivec;
for (int i=0; i< 100;++i)
    ivec.push_back(i);
// 结束后ivec内存在100个值，0-99
```

> 关键概念：vector对象能高效增长
>
> C++标准要求vector应该能在运行时高效的快速添加元素。因此既然vector对象能高效的增长，那么在定义vector对象的时候设定其大小也就没什么必要了，事实上如果这么做可能性能会更差。只有一张例外情况，就是所有元素的值都一样。一旦元素的值有所不同，更有效的办法就是先定义一个空的vector对象，在运行时向其中添加具体值。此外，9.4节还将介绍，vector害提供了方法，允许我们进一步提升动态添加元素的可能

向vector对象添加元素蕴含的编程假定

必须要保证确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。

如果循环体内部包含有vector对象添加元素的语句，则不能使用范围for循环，今天原因在5.4.3详细解释。

> 范围for循环语句体内不应该改变其所遍历序列的大小

#### 3.3.3 其他vector操作

除了push_back外，vector还提供了其他几种操作，大多数都和string的相关操作类似，表3.5列出了部分重要的一些。

表3.5：vector支持的操作

```c++
v.empty();	// 如果v不含有任何元素，返回真，否则返回假
v.size();	// 返回v中元素的个数
v.push_back(t);// 向v的尾端添加一个值为t的元素
v[n];		// 返回v中第n个位置上元素的引用
v1 = v2;	// 用v2中元素的拷贝替换v1的元素
v1 = {a,b,c...};// 用列表的元素的拷贝替换v1的元素
v1 == v2;	// v1和v2相等当且仅当他们元素数量相同且对应位置的元素相同
v1 != v2;	// 
<,<=,>,>=	// 顾名思义，以字典顺序进行比较
```

访问vector对象中元素的方法和访问string对象中字符的方法差不多，也是通过元素在vector对象中的位置。例如，可以使用范围for语句处理vector对象中的所有元素：

```c++
vector<int> ivec{1,2,3,4,5};
for(auto &i:ivec)
    i *= i
```

vector的empty和size两个成员与string的同名成员功能完全一致：empty返回vector对象是否包含元素然后返回一个布尔值；size则返回vector对象中元素的个数，返回值的类型是由vector定义的size_type类型

> 要是用size_type，需首先指定它是由那种类型定义的。vector对象的类型总是包含着元素的类型
>
> vector\<int\>::size_type //正确
>
> vector::size_type //错误

各个相等性运算符和关系运算符也与string的相应运算符功能一致。只有当元素的值可比较时，vector对象才能被比较。

计算vector内对象的索引

使用下标运算符可以获取到指定的元素。和string一样，vector的下标也是从0开始，下标的类型是相应的size_type类型。只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。也能通过计算得到vector内对象的索引，然后直接获取到索引位置上的元素。

```c++
// 以10分为一个分数段统计成绩的数量：0-9,10-19,...,90-99,100
vector<unsigned> score(11,0);//11个分数段，全部初始化为0
unsigned grade;
while(cin >> grade)
    if (grade <= 100)	//只处理有效的成绩
        ++score[grade/10];//将计数值+1
```

需要注意的是，我们要确认下标计算后在范围之内。

不能用下标形式添加元素。只能使用push_back。

> vector对象(以及string对象)的下标运算符可用于访问已存在的元素，而不能用于添加元素

> 切记，只能对确切已存在的元素执行下标操作
>
> 试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。这个也叫缓冲区移除(buffer overflow)，这也是导致PC以及其他设备上应用出现安全问题的一个重要原因。
>
> 规避的一种有效手段就是尽可能使用范围for语句

### 3.4 迭代器介绍

我们已经知道可以使用下标运算符来访问string和vector对象的字符或元素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器。在第II部分将要介绍，除了vector之外，标准库还定义了其他几种容器。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。严格来说，string对象不属于容器类型，但是string指出很多和容器类型类似的操作。vector支持下标运算符，这点和string一样；string支持迭代器，这也和vector是一样的。

类似于真类型，迭代器也提供了对对象的间接访问。就是迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也可以从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器组尾元素的下一位置；其他情况都属于无效。

#### 3.4.1 使用迭代器

 和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为begin和end的成员，其中begin成员负责返回指向第一个元素(或第一个字符)的迭代器，如有下述语句：

```c++
// 由编译器决定b和e的类型
// b表示v的第一个元素，e表示v尾元素的下一位置
auto b = v.begin(), e = v.end();// b和e的类型相同
```

end成员则负责返回指向容器(或string对象)尾元素的下一位置的迭代器，也就是说，该迭代器指示的是容器一个本不存在的尾后元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称为尾后迭代器或者简称为尾迭代器。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。

一般来说，我们不清楚(不在意)迭代器准确的类型是什么。例子就是用auto定义关键字b和e。

迭代器运算符

表3.6列举了迭代器支持的一些运算，使用==和!=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等，反之不等。

表3.6：标准容器迭代器的运算符

```c++
*iter; // 返回迭代器iter所指元素的引用
item->mem; // 解引用iter并获取该元素名为mem的成员=(*item).men
++iter;	// 令iter指向容器中下一个元素
--iter;	// 令iter指向容器中上一个元素 
iter1 == iter2;// 如果两个迭代器指向的元素相同或者都是同一个容器的尾
iter1 != iter2;// 后迭代器，则他们相等，反之不等。
```

和指针相似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指向某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。

将迭代器从一个元素移动到另一个元素

迭代器使用++递增运算符来从一个元素一动都爱下一个元素，从逻辑上来说，迭代器的递增和整数的递增类型，整数的递增是在整数值上加1，迭代器的递增则是将迭代器向前移动一个位置。

> 因为尾迭代器并不指向某个元素，所以不能对齐进行递增或解引用的操作，
>
> 泛型编程：**for循环中更适用!=，因为!=运算符在所有容器中都适用。**

迭代器类型

就想不知道string和vector的size_type成员到底是什么类型一样，一般来说我们也不知道(其实是无需知道)迭代器的精确类型。而实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：

```c++
vector<int>::iterator it; // it能读写vector<int>的元素
string::iterator it2; // it2能读写string对象中的字符

vector<int>::const_iterator it3; // it3只能读元素，不能写元素
string::const_iterator it4; // it4只能读字符，不能写字符
```

const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既可以使用iterator也能使用const_iterator。

> 迭代器和迭代器类型
>
> 迭代器这个名字有三个不同的含义：可能是迭代器概念本身，也可能指容器定义的迭代器类型，还可能指某个迭代器对象
>
> 重点是理解存在一组概念上相关的类型，我们认定某个类型是迭代器当且仅当它支持一套操作，这套操作使得我们能访问容器的元素或者从某个元素移动到另一个元素。
>
> 每个容器类定义了一个名叫iterator的类型，该类型支持迭代器概念所规定的一套操作。

begin和end运算符

begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，那么返回const_iterator；如果不是常量则返回iterator。

```c++
vector<int> v;
const vector<int> cv;
auto iv1 = v.begin();//it1的类型是vector<int>::iterator
auto iv2 = cv.begin();//it2的类型是vector<int>::const_iterator
```

有时候这种默认的行为并非我们所要，在6.2.3节中将会看到，如果对象只需读操作而无需写操作的话最好使用常量类型const_iterator，为了便于专门得到const_iterator类型的返回值，c++11引入了两个新函数，cbegin和cend：

```c++
auto it3 = v.cbegin();
```

类似begin和end，新函数也是返回指示容器的第一个元素或最后元素下一位置的迭代器。有所不同的是，不论vector或string对象本身是否是常量，返回值都是const_iterator。

结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，就有可能希望进一步访问它的成员。例如，对于一个由字符串组成的vector对象来说，想要检查其元素是否为空，令it是该对象的迭代器，只需检查it所指字符串是否为空就可以了，其代码如下所示：

```c++
(*it).empty()
```

其中\*it的圆括号必不可少。该表达式先对it进行解引用，再访问解引用后的对象的成员。如果不加圆括号，则点运算符由it来执行，迭代器没有empty成员，则报错。

为了简化上述表达式，C++定义了箭头运算符(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说`it->mem`和`(*it).mem`是一个意思。

某些对vector对象的操作会使迭代器失效

3.3.2节曾经介绍过，虽然vector对象可以动态增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，不如push_back，都会使该vector对象的迭代器失效。9.3.6节将详细解释迭代器是如何失效的。

#### 3.4.2 迭代器运算

迭代器的递增运算令迭代器每次移动一个元素。所有标准库容器都有支持递增运算的迭代器。类似的，也能用==和!=对任意标准库类型的两个有效迭代器进行比较。

string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。所有这些运算被称作迭代器运算。

表3.7: vector和string迭代器支持的运算

```c++
iter + n; // 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的元素，或者指示容器尾元素的下一位置
iter - n; // 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的元素，或者指示容器尾元素的下一位置
iter1 += n; // 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1
iter1 -= n; // 迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1
iter1 - iter2; // 两个迭代器相减的结果是他们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须是指向同一个容器中的元素或者尾元素的下一位置
>、>=、<、<=; // 迭代器的关系运算符，如果某迭代器指向的容器位置在另一迭代器所指的位置之前，则说前者小于后者。参与运算的两个迭代器必须是指向同一个容器中的元素或者尾元素的下一位置
```

迭代器的算术运算

计算最接近vi中间位置的一个迭代器

```c++
auto mid = vi.begin() + vi.size() / 2
```

两个迭代器之间的所谓距离，指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可负可正，所以difference_type是带符号的。

使用迭代器运算

使用迭代器运算的一个经典算法是二分搜索。二分搜索从有序序列中寻找某个给定的值。

```c++
// 二分搜索(二分查找法
int two_search(vector<int> *v, int number)
{
    auto beg = v->cbegin(), end = v->cend();
    auto mid = beg + v->size()/2;
    while (mid != end && *mid != number) {
        if (*mid > number)
            end = mid; // 正常思维是mid-1，但end本身指向下一个元素，所以正确应该是mid-1+1即mid
        else
            beg = mid + 1;
        mid = beg + (end - beg)/2;//因为是迭代器，所以不能beg+end,这样就超过vector容量了
    }
    if (mid == end) {
        cout << "没有该元素" << endl;
        return -1;
    }
    return mid - v->cbegin();
}
```

### 3.5 数组

数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。与vector相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但也相应的损失了一些灵活性。

> 如无法确定元素的个数，请使用vector

#### 3.5.1 定义和初始化内置数组

数组是一种复合类型。数组的声明形如a[d]，其中a是数组名字，d是数组的维度，维度说明了数组中元素的个数，因此必须大于0。数组中元素的个数也是属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式：

```c++
unsigned cnt = 23;
constexpr unsigned sz = 34;
int arr[10]; // 含有10个整数的数组
int *parr[sz]; // 含有23和整型指针的数组；
string bad[cnt]; // 错误，cnt不是常量表达式
string strs[get_size()]; // 当get_size()是constexpr时正确
```

默认情况下，数组的元素会被初始化

> 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组必须指定数组的类型，不允许使用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

显示的初始化数组元素

可以对数组元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，初始值的总数量不能超过。如果维度比提供的元素数量大，则提供的初始值初始化靠前的元素，后面的元素还是采用默认初始化。

```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; // 含有3个元素的数组,初始值为0,1,2
int a2[] = {0,1,2}; // 含有3个元素的数组,初始值为0,1,2
int a3[5] = {0,1,2}; // 等价于a3={0,1,2,0,0}
string a4[3] = {"hi", "bye"}; // 等价于a4={"hi", "bye", ""}
int a5[2] = {0, 1, 2};//错误，初始值过多
```

字符数组的特殊性

字符数组有一种额外的初始化形式，我们可以使用字符串字面值对此类数组进行初始化。当使用这种形式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

```c++
char a1[] = {'C','+','+'}; //列表初始化，没有空字符
char a2[] = {'C','+','+','\0'}; //列表初始化，含有显式的空字符
char a3[] = "C++"; // 自动添加表示字符串结束的空字符
const char a4[4] = "ahan"; // 错误，没有空间存放空字符
```

不允许拷贝和负值

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```c++
int a[] = {0, 1, 2}; // 含有3个整数的数组
int a2[] = a; //错误：不允许使用一个数组初始化另一个数组
a2 = a;//错误，不允许把一个数组直接赋值给另一个数组
```

> 一些编译器支持数组的赋值，这就是所谓的编译器拓展。但一般来说，最好避免使用非标准特性，因为有非标准特性的程序很可能在其他编译器上无法工作

理解复杂的数组声明

和vector一样，数组能存放大多数类型的对象。例如可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：

```c++
int *ptrs[10]; // ptrs数组含有10个整型指针
int &refs[10] = /* ? */; // 错误，不存在引用的数组
int (*parray)[10] = &arr; // 指向一个含有10个整型元素的数组
int (&arrRef)[10] = arr; // 引用一个含有10个整型元素的数组
```

默认情况下，类型修饰符从右到左依次绑定。对于ptrs来说，从右到左理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字时ptrs，然后知道数组中存放的是指针。

但是对于parray来说，从右往左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读比从右向左阅读要合理多了。从内向外的顺序可帮助我们更好的理解parray的含义：首先是圆括号括起来的部分，*parray意味着parray是一个指针，接下来看右边，可知parray是个指向大小为10的数组的指针，最后看左边，可知数组的元素是int。

当然，对修饰符的数量没有限制：

```c++
int *(&array)[10] = ptrs; // array是数组的引用，引用10个指针元素的数组
```

#### 3.5.2 访问数组元素

与标准库类型vector和string一样，数组的远古三也能使用范围for语句或下标运算符来访问。数组的索引从0开始。

使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计的足够大一遍能表示内存中任意对象的大小，在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的c++语言版本。

数组除了大小固定这一特点外，其他用法与vector基本类似。

与vector和string一样，当需要便利数组的所有元素时，最好的办法也是使用范围for语句。因为维度是数组类型的一部分，所以系统知道数组中有多少个元素，使用范围for语句可以减轻人为控制遍历过程的负担

检查下标的值

数组的下标是否在合理范围之内由程序员负责检查，合理即下标应该大于等于0且小于数组的大小。

#### 3.5.3 指针和数组

在C++语言中，指针和数组有非常紧密的关系。就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。

通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：

```c++
string nums[] = {"one", "two", "three"};//数组的元素是string
string *p = &nums[0];//p指向nums的第一个元素
```

然而，数组还有一个特性，在个很多用到数组名字的地方，编译器会自动将其特换为一个指向数组首元素的指针：

```c++
string *p2 = nums; // 等价于&nums[0]
```

> 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐藏的意义。其中一层是当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组：

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
auto ia2(ia); //ia2是指向第一个元素的指针
ia2 = 23;//错误，ia2是一个指针
```

使用数组作为初始值时，编译器实际上执行的初始化过程类似：

```c++
auto ia2(&ia[0]);// 即ia2是一个int *类型
```

必须要指出的是，当使用decltype关键字时不会发生上述过程，该是数组就还是数组。

```c++
decltype(ia) ia3 = {0,1,2,3,4};//ia3是一个int数组
```

指针也是迭代器

与2.3.2节介绍的内容相比，指向数组元素的指针拥有更多功能。vector和string的迭代器支持的运算，数组的指针全部支持。例如。允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```c++
int arr[] = {0,1,2,3,4,5};
int *p = arr;
++p;// 将指针从arr[0]指向arr[1]
```

就像迭代器遍历vector对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先获取到指向数组第一个元素的指针和数组尾元素的下一位置的指针。之前已经介绍过，通过数组名字或者数组中首元素的地址都能得到指向首元素的指针，不过获取尾后指针就需要用到数组的另外一个特殊性质了。我们可以设法获取到数组尾元素之后的哪个并不存在的地址：

```c++
int *e = &arr[5];
```

arr一共5个元素，尾元素索引为4，往后一个不存在的元素就是提供其地址用于初始化e。就想尾后迭代器一样，尾后指针也不指向具体的元素。因此不能对尾后指针进行解引用或递增的操作。

```c++
for(int p = arr; p != e; ++p)
    cout << *p << endl;
```

标准库函数begin和end

尽管能计算得到尾后指针。为了让指针的使用更简单、更安全，c++11引用了两个名为begin和end的函数。这两个函数与容器中的两个同名成员函数功能类似，但数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数。

```c++
int ia[] = {1,2,3,4,5};
int *beg = begin(ia);
int *last = end(ia); // 尾后指针
```

循环例子，找出数组中的负数

```c++
int *pbeg = begin(arr), *plast = end(arr);
while (pbeg != plast && *plast >= 0)
    ++pbeg;
```

指针运算

指向数组元素的指针可以执行表3.6和表3.7列出的所有迭代器运算。这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。

两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。

只要两个指针指向同一个数组的元素，或者是该数组的尾后指针，就能利用关系运算符进行比较：

```c++
int *b = arr, *e = arr + sz;
while (b < e)
    ++b
```

如果两个指针分别指向不同对象，则不能比较他们。

必须说明：上述指针运算同样适用于空指针和所指对象并非数组的指针。在后一种情况下，两个指针必须指向同一个对象或该对象的下一位置。如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。俩个空指针也允许彼此相减，结果当然是0.

解引用和指针运算的交互

指针加上一个整数所得的结果还是指针。假设结果指针指向了一个元素，则允许解引用这个结果指针。

```c++
int ia[] = {0,2,4,6,8};
int last = *(ia+4); // 正确，ia+4 即ia[4]=8
```

3.4.1节介绍过，如果表达式含有解引用运算符和点运算符，最好在必要的地方加上圆括号。类似的，此例中加法的括号也不可缺少。

```c++
int last2 = *ia + 4;// 那么*ia=0，结果last2就是0+4=8
```

下标和指针

如前所述，在很多情况下使用数组的名字只是使用数组首元素的指针。一个典型的例子是当对数组使用下标运算时，编译器会自动执行上述转换操作，给定

```c++
int ia[] = {0,2,,4,6,8};
```

此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算实际上是对指向数组元素的指针执行下标运算。

```c++
ing i = ia[2]; // ia转换为首元素指针，ia[2]得到(ia+2)所指的元素
int *p = ia;// p指向ia的首元素
i = *(p+2);// i=4，即ia[2]
```

只要指针指向的是数组中的元素(或数组尾元素的下一位置)，都可以执行下标运算。

```c++
int *p = &ia[2];//p指向索引为2的元素
int j = p[1]; // p[1]等价于*(p+1),即ia[2+1].ia[3]
int k = p[-2]; // p[-2]是ia[2-1]即ia[0]的元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组和他们相比还是有所不同。标准库类型限定使用下标必须是无符号类型，而内置的下标运算无此要求，可以是负数。当然，结果的地址必须指向原来的同一数组的同一元素或同一数组的尾元素的下一指针。

### 3.5.4 C 风格字符串

> 尽管c++支持C风格字符串，但在C++程序中最好还是不要使用他们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

字符串字面值是一种通用结构的实例，这种结构是C++由C继承而来的C风格字符串。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串放在字符数组中并以空字符结束。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符'\0'。一般利用指针来操作这些字符串。

C标准库String函数

表3.8列举了C语言标准库提供的一组函数，这些函数可以操作C封哥字符串，它们定义在cstring头文件中，cstring是c语言头文件string.h的C++版本。

表3.8: C风格字符串的函数

```c++
strlen(p);		// 返回p的长度，空字符不计算在内
strcmp(p1, p2);	// 比较p1和p2的相等性，p1==p2，返回0，大于返回正值，小于返回负值
strcat(p1, p2);	// 将p2附加到p1之后，返回p1
strcpy(p1, p2);	// 将p2拷贝给p1在，返回p2
```

> 表3.8所列的函数不负责验证其字符串参数

传入此类函数的指针必须包含以空字符作为结束的数组

```c++
char ca[] = {'C', '+', '+'};
cout << strlen(ca) << endl; // 错误，没有空字符结束
```

此例中，ca虽然也是一个字符数组，但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下来。

比较字符串

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。比较标准库string对象的时候，用的是普通的关系运算符和相等性运算符：

```c++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 > s1
```

如果把这些运算用在两个c风格字符串上，实际比较的将是指针而非字符串本身：

```c++
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (s1 < s2) // 未定义的：试图比较两个无关地址
```

当使用数组的时候实际真真使用的是指向数组首元素的指针。因此上述的if条件比较的实际上是两个const char\*的值，这两个指针指向的非同一个对象，所以将得到未定义的结果。

想要比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。如果两个字符串相等，则返回0，如果前面的字符串比较大，则返回正值，否则返回负值。

```c++
if (strcmp(s1, s2) < 0) // 和两个string对象的比较s1 < s2的效果一样
```

目标字符串的大小由调用者指定

连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大。例如，要想把刚刚定义的两个string对象s1和s2连接起来，可以直接写成如下的形式：

```c++
string largeStr = s1 + " " + s2;
```

同样的操作放在ca1和ca2这两个数组身上就会产生错误了。表达式ca1+ca2的意思是两个指针相加，显然这样的操作没什么意义也肯定是非法的。

正确的方法是使用strcat函数和strcpy函数。不过要想使用这两个函数，还必须提供一个用于存放结果字符串的数组，该数组必须足够大以便容纳下结果字符串及末尾空字符。下面的代码虽然很常见，但充满了安全风险，极易引发严重错误:

```c++
// 如果计算largestr的大小将引发严重错误
strcpy(largeStr, ca1); // 将ca1拷贝给largeStr
strcat(largeStr, " "); // 空格追加给largeStr
strcat(largeStr, ca2); // ca2追加给largeStr
```

一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr所存的内容一旦改变，就必须检查其空间是否足够，不幸的是，这样的代码到处都是，程序员没法儿照顾周全。这类代码充满了风险而且经常导致严重的安全泄露。

> 对大多数应用来说，使用标准库string要比C风格字符串更安全，更高效

#### 3.5.5 与旧代码的接口

很多C++程序在标准库出现之前就已经写成了，他们肯定没用到string和vector类型。而且，有一些程序实际上是与C语言或其他语言的程序接口，当然也无法使用C++标准库。因此，现代的c++程序不得不与那些充满了数组和C风格字符串的代码衔接，为了使这一工作的简单易行，C++专门提供了一组功能。

混用string对象和C风格字符串

3.2.1节介绍过允许使用字符串字面值来初始化string对象：

```c++
string s("ahanwhite");
```

更一般的情况是，任何出现字符串字面值的地方都可以用空字符结束的字符串数组来替代：

- 允许使用以空字符结束的字符数组来初始化，string对象或为string对象赋值
- 在string对象的加法运算中允许以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是)；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象

上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法使用string对象来替代它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数。

```c++
char *str = s;//错误，不能用string对象初始化char*
const char *str = s.c_str();//正确
```

顾名思义，c_str函数的返回值是一个c风格的字符串，所以说，函数的返回值又是一个指针，该指针指向一个以空字符结尾的字符数组，而这个数组所存的数据恰好与那个string对象的一样，结果指针的类型是const char*，从而确保我们不会改变字符数组的内容。我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失效

> 如果执行完c_str函数后程序像一直都能使用其返回的数组，最好将该数组重新拷贝一份

使用数组初始化vector对象

3.5.1节介绍过不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。要实现这一目的，只需要指明要拷贝区域的首元素地址和尾后地址就可以了：

```c++
int int_arr[] = {0,1,2,3,4,5,6};
// ivec有7个元素，分别是int_arr中对应元素的副本
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向带拷贝区域尾元素的下一位置。此例中，使用标准库函数begin和end来分别计算int_arr的首指针和尾后指针。在最终的结果中ivec将包含7个元素，他们的次序都和int_arr完全一样

用于初始化vector对象的值也可仅是数组的一部分

```c++
// 3个元素，int_arr[1],int_arr[2],int_arr[3]
vector<int> subVec(int_arr+1, int_arr+4);
```

这条初始化语句用3个元素创建了对象subVec，3个元素的值分别来自int_arr[1],int_arr[2],int_arr[3]

> 建议：尽量使用标准库类型而非数组
>
> 使用指针和数组很容易出错，一方面是概念上的问题：指针常用于底层操作，因此容易引发一些与繁琐细节相关的错误。其他问题则源于语法错误，特别是声明指针时的语法错误。

### 3.6 多维数组

严格来说，C++中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点。

当一个数组的元素仍然是数组时，通过使用两个维度来定义它，一个表示数组本身大小，另一个维度表示其元素大小。

```c++
int ia[3][4];//大小为3，每个元素有4个整数的数组
int arr[10][20][30] = {0};// 所有元素初始化为0
```

按照由内而外的顺序阅读此类定义有助于理解其真实含义。

对于二维数组来说，常把第一个元素称作行，第二个元素称为列。

多维数组的初始化

允许使用花括号括起来的一组值初始化多为数组，这点和普通的数组一样。下面的初始化形式中，多维数组的每一行分别用花括号括起来：

```c++
int ia[3][4] = { // 3个元素，每个元素都是大小为4的数组
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
}
```

其中内层嵌套的花括号并非必须的，例如下面的初始化语句，形式上更为简洁，完成的功能与上面代码一样

```c++
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表中，如果仅仅想初始化每一行的第一个元素：

```c++
int ia[3][4] = {{0},{4},{8}};
```

其他未列出的元素执行默认初始化，这个过程和一维数组一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了

```c++
int ia[3][4] = {0,1,2,3};
```

这里初始化的是第一行的四个元素。

多维数组的下标引用

可以使用下标来访问多维数组的元素，此时数组的每个维度都对应一个下标运算符。

如果表达式含有的下标预算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：

```c++
ia[2][3] = arr[0][0][0];// 用arr的首元素为ia最后一行的最后一个元素赋值
int (&row)[4] = ia[1];// 把row绑定到ia的第二个4元素的数组上
```

再举一个例子，程序中经常会用到两层嵌套的for循环来处理多维数组的元素：

```c++
constexpr size_t rowCnt = 3, colCnt = 4;
int ia[rawCnt][colCnt];// 12个未初始化的元素
for (size_t i = 0; i != rowCnt; ++i) {
    for (size_t j = 0; j != colCnt; ++j) {
        ia[i][j] = i * colCnt + j;
    }
}
```

使用范围for语句处理多维数组

```c++
size_t cnt = 0;
for (auto &row : ia) {
    for (auto &col : row) {
        col = cnt;
        ++cnt;
    }
}
```

在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子：

```c++
for (const auto &row: ia) {
    for (auto col : row) {
        cout << col << endl;
    }
}
```

这个循环中没有任何写操作，我们还是将外层循环的控制变量声明成了引用类型，这是为了避免数组被自动转换指针。假设不用引用类型，则循环如下形式：

```c++
for (auto row : ia)
    for (auto col : row)
```

程序无法通过编译，因为row不是引用类型，系统在初始化row时会自动讲这些数组形式的元素转换成指向该数组内首元素的指针。这样得到的row类型就是int *，显然内层的循环就不合法了，编译器试图在int *内遍历，这显然与程序的初衷相去甚远

> 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针

> 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组

因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：

```c++
int ia[3][4];
int (*p)[4] = ia; // p指向有4个整数的数组
p = &ia[2]; // p指向ia尾元素
```

首先明群*p是一个指针，再看右边是一个4元素的数组，在看左边，是一个int类型，所以p是一个指向含有4个元素的整型数组的指针

> 在上述声明中，圆括号必不可少
>
> ```c++
> int *p[4];		// 整型指针的数组(右->左)
> int (*p)[4];	// 指向含有4个整数的数组(内—>外->右->左)
> ```

使用auto或decltype就能尽可能的避免数组前面加上一个指针类型了

```c++
// 输出ia中每个元素的值，每个内层数组各占一行
// p指向含有你4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
    // q指向4个整数数组的首元素买也就是说 q指向一个整数
    for (auto q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```

类型别名简化多维数组的指针

读、写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名能让这一工作简单点儿。

```c++
using int_array = int[4];
typedef int int_array[4]; // 等价于上一行
// 输出ia中每个元素的值，每个内层数组各占一行
for (int_array *p = ia; p != ia + 3; ++p) {
    for (int *q = *p; q != *p + 4; ++q)
        cout << *q << ' ';
    cout << endl;
}
```

## 4 表达式

表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式

### 4.1 基础

有些基础概念对表达式求值过程有影响，本节先简要介绍

### 4.1.1 基本概念

C++定义了一元运算符和二元运算符。作用于一个运算对象的是一元运算符，如取地址符&和解引用福\*；作用于两个运算对象的运算符是二元运算符，如相等运算符==和乘法运算符*。除此之外，还有一个作用于三个运算符的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。

一些符号既可以作为一元运算符又可以作为二元运算符。以\*号为例，作为一元运算符时执行解引用操作，作为二元运算符时执行乘法操作。一个符号到底是一元还是二元运算符由它的上下文决定。对于这类符号来说，它的两种用法毫不相干，完全可以当成两种不同的符号。

组合运算符和运算对象

对于含有多个运算符的复杂表达式来说，想要理解它的含义首先要理解运算符的优先级、结合律以及运算对象的求值顺序，例如，下面这条表达式的求值结果依赖于表达式中运算符和运算对象的组合方式

```c++
5 + 10 * 20/2
```

 乘法运算符是一个二元运算符，它由四种可能，10和20,10和20/2,15和20,20/2，下一节将介绍如何理解这样一条表达式

运算对象转换

在表达式求值的过程中，运算对象常常由一种类型转换成另外一种类型。例如，尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候及时运算对象的类型不同也没有关系，只要他们能够被转换成同一种类型即可。

类型转换的规则虽然有些复杂，但大多数都合乎情理，容易理解。例如，整数能转换成浮点数，浮点数也能转换成整数，但是指针不能转换成浮点数。让人稍微有点意外的是小整数类型(如bool、char、short等)通常会被提升成较大的整数类型，主要是int。4.11节将详细介绍类型转换的细节。

重载运算符

C++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作，当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以被称之为重载运算符。IO库的>>和<<运算符以及string对象、vector对象和迭代器使用的运算符都是重载的运算符。

我们使用重载运算符是，其包括运算对象的类型和返回值的类型，都是由该运算符定义的，但是运算对象的个数、运算符的优先级和结合律都是无法改变的。

左值和右值

C++的表达式要不然是右值，要不然就是左值。这两个名词都是从C语言继承而来，原本是为了帮助记忆：左值可以位于赋值语句的左侧，右值则不能。

在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但他们是右值而非左值。可以做一个简单的归纳：**当一个对象被用作右值的时候，用的是对象的值(内容)，当对象被用作左值的时候，用的是对象的身份(在内存中的位置)**。

不同的运算符对运算对象的要求各不相同，有的需要左值运算对象、有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。一个重要的原则(参考13.6节，将介绍一种例外情况)是在需要右值的地方可以用左值代替。但是不能把右值当做左值来用。【意思是位置可以当做对象来用，对象不能当做位置用】当一个左值被当成右值用，，实际上使用的是它的内容。到目前位置，已经有几种我们熟悉的运算符是要用到左值的。

- 赋值运算符需要一个非常量的左值作为其左侧运算对象，得到的结果也依然是一个左值
- 取地址符作用域一个左值运算对象，返回一个指向该运算对象的指针，该指针是一个右值
- 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果都是左值
- 内置类型和迭代器的递增递减运算符作用于左值对象，其前置版本所得的结果也是左值。

接下来介绍运算符的时候，也会注明该运算符的运算对象是否必须是左值以及其返回结果是否是左值。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值decltype作用域该表达式(不是变量)得到一个引用类型。举个例子，假定p的类型是int\*，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址符生成右值，所以decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针

#### 4.1.2 优先级与结合律

复合表达式是指含有两个或多个运算符的表达式，求复合表达式的值需要首先将运算符和运算对象合理的组合在一起，优先级与结合律决定了运算对象组合的方式。也就是说，他们决定了表达式中每个运算符对应的运算对象来自表达式的那一部分。表达式中的括号无视上述规则，程序员可以使用括号将表达式某个局部括起来使其得到优先运算。

一般来说，表达式最终的值依赖于其子表达式的组合方式。高优先级运算符的运算对象要比低优先级运算符更为紧密的组合在一起。如果优先级相同，则其组合规则由结合律决定。例如，乘法和除法的优先级相同且高于加法的优先级。因此，成啊和除法的运算对象会首先组合到一起，然后才轮到加法和减法的运算对象。算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从左至右的顺序组合运算对象

- 根据运算符的优先级，表达式3+4*5的值是23不是35
- 根据运算符的结合律，表达式20-15-3的值是2不是8

举一个稍微复杂一点的例子，如果完全按照从左至右的顺序求值，下面的表达式将得到20：

```c++
6 + 3 * 4 / 2 + 2
```

也有一些人会计算得到9、14或者36，然而在C++语言中真实的计算结果应该是14。这是因为这条表达式事实上与下述表达式等价：

```c++
((6 + ((3 * 4) / 2)) + 2)
```

括号无视优先级与结合律

括号无视普通的组合规则，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。

优先级和结合律有何影响

优先级会影响程序的正确性。结合律对表达式产生影响

#### 4.1.3 求值顺序

优先级规定了运算对象的组合方式，但没有说明运算对象按什么顺序求值，多数情况下，不会明确求值顺序，对于如下的表达式：

```c++
int i = f1() + f2();
```

我们知道f1和f2一定会执行乘法之前被调用，因为毕竟相乘的是两个函数的返回值，但是我们无法知道是f1在f2之前被调用还是f2在f1之前被调用，

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。举个简单的例子，<<运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的。

```c++
int i = 0;
cout << i << " " << ++i << endl; //未定义的
```

因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求++i的值再求i的值，此时输出的结果是1 1；也可能先求i的值再求++i的值，这时候输出0 1；甚至编译器还可能做出完全不同的操作。因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。

有4种运算符明确规定了运算对象的求职顺序，第一种是逻辑与(&&)运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧对象的值。另外三种是逻辑或(||)运算符、条件(?:)运算符和逗号(,)运算符

求值顺序、优先级、结合律

运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中：

- 优先级规定，g的返回值和h的返回值相乘
- 结合律规定，f的返回值先与g和h的返回值的乘积相加，所得结果与j的返回值相加
- 对于这些函数的调用顺序没有明确规定

如果f、g、h和j是无关函数，他们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。

> 建议：处理复合表达式
>
> 1. 拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求
> 2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象
>
> 第2点有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。比如，在表达式*++iter中，递增运算符改变iter的值，iter(已经改变)的值又是解引用运算符的运算对象。此时或者类似情况下，求值的顺序不会成为问题，因为递增运算(即改变运算对象的子表达式)必须先求值，然后才轮到解引用运算。

