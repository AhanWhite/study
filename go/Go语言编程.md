# Go语言编程

## 1 初识Go语言

### 1.1 语言特性

这里罗列以下G哦语言最主要的特性

- 自动垃圾回收
- 更丰富的内置类型
- 函数多返回值
- 错误处理
- 匿名函数和闭包
- 类型和接口
- 并发编程
- 反射
- 语言交互性

## 1.2 第一个Go程序

```go
// hello.go 
package main
import "fmt"
func main() {
 fmt.Println("Hello, world. 你好，世界！")
}
```

每个Go源代码文件的开头都是一个package声明，表示该Go代码所属的包。包是Go语言里最基本的分发单位，也是工程管理中依赖关系的体现。要生成Go可执行程序，必须建立一个名字为main的包，并且该包中包含一个叫main()的函数(该函数是Go可执行程序的执行起点)。

Go语言的main()函数不能带参数，也不能定义返回值，命令行传入的参数在os.Args变量中保存。如果需要支持命令行开关，可使用flag包。

在包声明之后，是一系列的import语句，用于导入该程序所依赖的包。由于本示例程序使用到了Println()函数，所以需要导入该函数所属的fmt包。

有一点需要注意，不得包含在源代码文件中没有用到的包，否则编译器回报编译错误。这与下面提到的强制左花括号{的放置位置以及之后会提到的函数名的大小写规则，均体现了Go语言在语言层面解决软件工程问题的设计哲学。

所有Go函数(包括在对象编程中会提到的类型成员函数)以关键字func开头。一个常规的函数定义包含以下部分：

```go
func 函数名(参数列表) (返回值列表) {
    // 函数体
}
```

对于的实例如下：

```go
func Compute(value1 int, value float64) (result float64, err error) {
    // 函数体
}
```

Go支持多个函数返回值。以上的实力函数Compute()返回了两个值，一个叫result，一个是err。并不是所有返回值都必须赋值。在函数返回时没有被明确赋值的返回值都会被设置为默认值，比如result会被设为0.0， err会被设为nil。

Go程序的代码注释与C++保持一致，即同时支持以下两种用法：

```go
/**
 * 块注释
 */

// 行注释
```

Go程序不要求开发者在每个语句后面加上分号表示语句结束。

有些读者可能会自然地把左花括号{另起一行放置，这样做的后果是Go编译器报告编译错误，这点需要特别注意：

```go
syntax error: unexpected semicolon or newline before {
```

## 2 顺序编程

### 2.1 变量

从根本上来说，变量相当于是对一块数据存储空间的命名，程序可以通过定义一个变量来申请一块数据存储空间，之后可以通过引用变量名来使用这块存储空间。

#### 2.1.1 变量声明

对于纯粹的变量声明，go语言引入了关键字var，而类型信息放在变量名之后，示例如下：

```go
var v1 int
var v2 string
var v3 [10]int	// 数组
var v4 []int 	// 数组切片
var v5 struct {
    f int
}
var v6 *int		// 指针
var v7 map[string]int	// map，key为string类型，value为int类型
var v8 func(a int) int
```

变量声明语句不需要使用分号作为结束符。与C相比，Go摒弃了语句必须以分号作为语句结束标记的习惯。

var关键字的另一种用法是可以将若干个需要声明的变量放置在一起，避免程序员需要重复写var关键字

```go
var {
    v1 int
    v2 string
}
```

#### 2.1.2 变量初始化

对于声明变量时需要进行初始化的场景，var关键字可以保留，但不再是必要的元素，如下所示：

```go
var v1 int = 10	// 正确1
var v2 = 10		// 正确2 编译器自动推导类型
v3 := 10		// 正确3 编译器自动推导类型
```

以上三种用法效果完全一样(除了第三种不能用于声明全局变量)。与第一种用法相比，第三种用法需要输入的字符数大大减少。冒号和等号(:=)用于明确表达同事进行变量声明和初始化的工作。

指明类型已不再是必须的，Go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让Go看起来有点像动态类型语言，尽管Go语言实际上是不折不扣的强类型语言(静态类型语言)。

当然，出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误，比如下面这个写法

```go
var i int
i := 2
```

会导致如下错误

> no new variables on left side of :=

#### 2.1.3 变量赋值

在Go语法中，变量初始化和变量赋值是两个不同的概念。下面为声明一个变量之后的赋值过程

```go
var v10 int
v10 = 22
```

Go的变量赋值与多数语言一致，但Go提供了多重赋值功能，比如下面这个交换i和j变量：

```go
i, j = j, i
```

在不支持多重变量赋值的语言中，需要引入一个中间变量

```go
t = i, i = j, j = t
```

多重赋值的特性在Go语言库的实现中也被使用的相当充分，在介绍函数的多重返回值时，将对其进行更深入的介绍

#### 2.1.4 匿名变量

我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数是为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量，在Go中这种情况可以通过结合使用多重返回和匿名变量来避免这种丑陋的写法

假设GetName()函数定义如下，它返回3个值，分别是firstName，lastName，nickName

```go
func GetName() (firstName, lastName, nickName string) {
    return "Ahan", "White", "Bai"
}
```

如果只想获得nickName，则可如下

```go
_, _, nickName = GetName()
```

### 2.2 常量

在Go语言中，常量是指编译期间就已知且不可改变的值。常量可以是数值类型(包含整型、浮点型和复数类型)、布尔类型、字符串类型等

#### 2.2.1 字面常量

所谓字面常量，是指程序中硬编码的常量

```go
12
3.14159265358979323846	// 浮点类型的常量
3.2+12i					// 复数类型的常量
true					// 布尔类型的常量
"foo"					// 字符串常量
```

在其他语言中，常量通常有特定的类型，比如-12在C语言中会被认为是一个int类型的常量。如果要指定一个值为-12的long类型常量，需要写成-12l，这有点违反人们的直观感受。Go语言的字面常量更接近我们自然语言中的常量概念，它是无类型的。只要这个常量在相应类型的值域范围内，就可以作为该类型的常量，比如上面的-12，它可以赋给int、uint、int32、int64、float32、float64、complex64、complex128等类型的变量。

#### 2.2.2 常量定义

通过const关键字，你可以给字面常量指定一个友好的名字：

```go
const PI float64 = 3.14159265358979323846
const zero = 0.0		// 无类型浮点常量
const (
	size int64 = 1024
    eof = -1			// 无类型整型常量
)
const u, v, float32 = 0, 3
const a, b, c = 3, 4, "foo" // u = 0.0, v= 3.0常量的多重赋值
```

Go的常量定义可以限定常量类型，但不是必须的。如果定义常量时没有指定类型，那么它和字面常量一样是无符号常量。

常量定义的右值也可以是一个在编译期运算的常量表达式，比如

```go
const mask = 1 << 3
```

由于常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达式，比如试图以如下方式定义常量就会导致编译错误

```go
const Home = os.GetEnv("HOME")
```

原因很简单，os.GetEnv()只有在运行期才能知道返回结果，在编译器并不能确定，所以无法作为常量定义的右值

#### 2.2.3 预定义常量

Go预定义了这些常量：true、false和iota。

iota比较特殊，可以被认为是一个可被编译器修改常量，在每一个const关键字出现时被重置为0，然后再下一个const出现之前，每出现一次iota，其所代表的数字户自动增1.

从以下的例子可以基本理解iota的用法：

```go
const (	// iota重置为0
	c0 = iota	// c0 == 0
    c1 = iota	// c1 == 1
    c2 = iota	// c2 == 2
)
const ( // iota重置为0
	a = 1 << iota	// a = 1 << 0 = 1
    b = 1 << iota	// b = 1 << 1 = 2
    c = 1 << iota	// c = 1 << 2 = 4
)
const ( // iota重置为0
	u			= iota * 42 // u = 0  	// iota = 0
    v	float64	= iota * 42 // v = 42.0	// iota = 1
    w			= iota * 42 // w = 84	// iota = 2
)
const x = iota	// x = 0 // const重置
const y = iota	// y = 0 // 又重置了
```

如果两个const的赋值语句的表达式是一样的，那么可以省略掉后一个赋值表达式：

```go
const (
	c0 = iota	// c0 = 0
    c1			// c1 = 1
    c2			// c2 = 2
)
const (
	a = 1 << iota	// a = 1
    b				// b = 2
    c				// c = 4
)
```

#### 2.2.4 枚举

枚举指一系列相关的常量，比如下面关于一个星期中每天的定义。通过上一节的例子，我们看到可以在const后跟一对圆括号的方式定义一组常量，这种定义法在Go语言中通常用于定义枚举值。Go语言并不支持众多其他语言明确支持的enum关键字

下面是一个常规的枚举表示法，其中定义了一系列整型常量

```go
const (
	Sunday = iota
    Monday
    Tuesday
    Wendnesday
    Thursday
    Friday
    Saturday
    numberOfDays //这个常量没有导出
)
```

同Go语言的其他符号一样，以**大写字母开头的常量在包外可见**。

以上例子中numberOfDays为包内私有，其他符号则可被其他包访问。

### 2.3 类型

Go语言内置以下这些基础类型

- 布尔类型  bool
- 整型 int8、byte、int16、int、uint、uintptr
- 浮点类型 float32、float64
- 复数类型 complex64、complex128
- 字符串 string
- 字符类型 rune
- 错误类型 error

此外，Go语言也支持以下这些复合类型

- 指针pointer
- 数组array
- 切片slice
- 字典map
- 通道channel
- 结构体struct
- 接口interface

#### 2.3.1 布尔类型

Go语言中的布尔类型与其他语言基本一致，关键字也为bool，可赋值为预定义的true和false。

```go
var v1 bool
v1 = true
v2 := (1==2) // v2也会被推导为bool类型
```

布尔类型不能接收其他类型的赋值，不支持自动或强制的类型转换，以下错误示例

```go
var b bool
b = 1 // 错误
b = bool(1) // 编译错误
```

以下的用法才是正确的

```go
var b bool
b = (1!=0) // 编译正确
fmt.Println("Result:", b) // 打印结果： Result: true
```

#### 2.3.2 整型

整型是所有编程语言里最基础的数据类型

1、类型表示

需要注意的是 int和int32在Go语言里被认为是两种不同的类型，编译器也不会帮你自动做类型转换，比如

```go
var value2 int32
value := 64	// value会被自动推导为int类型
value2 = value // 编译错误
```

编译错误类似于

> cannot use value (type int) as type int32 in assignment

用强制类型转换可以解决这个问题

```go
value2 = int32(value) // 编译通过
```

在做强制类型转换时要注意数据精度损失和值溢出

2、数值运算

Go支持下面的常规整数运算：+ - \* \\ 和%。%和c语言中一样是求余运算，比如

```go
5 % 3
```

3、比较运算

Go语言支持以下几种比较运算符： >、<、==、>=、<=和!=。

```go
i, j := 1, 2
if i == j {
    fmt.Println("i and j are equal.")
}
```

两个不同类型整型数不能直接比较，比如int8和int类型的数不能直接比较，但各种类型都可以直接和字面常量比较。

```go
var i int32
var j int64
i, j = 1, 2
if i == j { // 编译错误
    fmt.Println("i and j are equal.")
}
if i == 1 || j == 2 { // 编译通过
    fmt.Println("i == 1 or j == 2.")
}
```

4、位运算

Go语言支持 x << y(左移) x >> y(右移) x ^ y(异或) x & y(与) x | y(或)  ^x(取反) 

#### 2.3.3 浮点型

浮点型用于表示包含小数点的数，比如1.234就是一个浮点型数据。Go语言中的浮点类型采用IEEE-754标准的表达方式。

1、浮点数表示

Go语言定义了两个类型float32和float64，其中float32等价于C语言的float类型，float64等价于C语言的double类型。

在Go语言里，定义一个浮点数变量的代码如下：

```go
var fvalue1 float32
fvalue1 = 12
fvalue2 := 12.0 //如果不加小数点，会被推导为整型而不是浮点型
```

fvalue2将被自动设为float64，而不管给他的数值是否用32位长度表示的。因此对于以上的例子，下面的赋值将导致编译错误

```go
fvalue1 = fvalue2
```

而必须使用这样的强制类型转换

```go
fvalue1 = float32(fvalue2)
```

 2、浮点数比较

因为浮点数不是一种精确的表达方式，所以像整型那样直接用==来判断两个浮点数是否相等是不可行的，这可能会导致不稳定的后果

下面是一种推荐的替代方案

```go
import "math"

// p为用户自定义的比较精度，比如0.00001
func IsEqual(f1, f2, p float64) bool {
    return math.Abs(f1-f2) < p
}
```

#### 2.3.4 复数类型

复数实际上由两个实数(在计算机中用浮点数表示)构成，一个表示实部，一个表示虚部。如果了解了数学上的复数是怎么回事，那么Go语言的复数就非常容易理解了。

1、复数表示

```go
var value1 complex64 //由两个float32构成的复数类型
value1 = 3.2 + 12i
value2 := 3.2 + 12i // value2是complex128的类型
value3 := complex(3.2, 12) // value3结果同value2
```

2、实部与虚部

对于一个复数z = complex(x, y)，就可以通过Go语言内置函数real(z)获得该复数的实部，也就是x，通过imag(z)获取该复数的虚部，也就是y

#### 2.3.5 字符串

在Go语言中，字符串也是一种基本类型。相比之下，C/C++中并不存在原生的字符串类型，通常用字符数组来表示，并以字符指针来传递。

Go语言中字符串的声明和初始化非常简单，

```go
var str string // 声明一个字符串变量
str = "Hello World"
ch := str[0] // 取字符串的第一个字符
fmt.Printf("The length of \"%s\" is %d \n", str, len(str))
fmt.Printf("The firtst character of \"%\" is %c.\n", str, ch)
```

输出结果为

```go
The length of "Hello World" is 11
The first character of "Hello World" is H
```

字符串的内容可以用类似于数组下标的方式获取，但与数组不同，字符串的内容不能再初始化后被修改。举个例子

```go
str := "Hello World" // 字符串也支持声明时进行初始化的做法
str[0] = 'X'	// 编译错误
```

编译器会报如下的错误

```go
cannot assign to str[0]
```

在这个例子中我们使用了一个Go语言内置的函数len()来获取字符串的长度。这个函数非常有用，我们在实际开发过程中处理字符串、数组、切片时常会用到。

Printf()函数与C语言运行库中的一模一样。

Go编译器支持UTF-9的源代码文件格式。这意味着源代码中的字符串可以包含非ANSI的字符，比如"Hello world. 你好，世界！"可以出现在Go代码中。但需要注意的是，如果你的Go代码需要包含非ANSI字符，保存源文件时请注意编码格式必须选择UTF-8.特别是Windows下一般编辑器都默认存为本地编码，比如中国地区可能是GBK编码而不是UTF-8，如果没注意这点在编译和运行时就会出现一些意料之外的情况

字符串的编码转换是处理文本文档(比如TXT、XML、HTML)非常常见的需求，不过可惜的是Go语言仅支持UTF-8和Unicode编码。对于其他编码，Go语言标准库并没有内置的编码转换支持。不过所幸的是，我们可以很容易基于iconv库用Cgo包装一个。这里有个开源项目: https://github.com/xushiwei/go-iconv

1、字符串操作

```go
x, y := "hello", "world"
x + y // 字符串连接"hello wrold"
len(x) // 求长度 5
x[0] // 取字符 h
```

更多操作，参考标准库strings包

2、字符串遍历

Go支持两种方式遍历字符串。一种是以字节数组的方式遍历

```go
str := "hello, 世界"
n := len(str)
for i := 0; i < n; i++ {
    ch := str[i] // 依据下标取字符串中的字符，类型为byte
    fmt.Println(i, ch)
}
```

输出

>0 104
>1 101
>2 108
>3 108
>4 111
>5 44
>6 32
>7 228
>8 184
>9 150
>10 231
>11 149
>12 140

可以看出，字符串长度为13，尽管直接看上去只有9个字符。这是因为每个中文字符在UTF-8中占3个字节，而不是1个字节

另一种是以Unicode字符遍历：

```go
str := "hello, 世界"
for i, ch := range str {
    fmt.Println(i, ch)
}
```

输出

> 0 104
> 1 101
> 2 108
> 3 108
> 4 111
> 5 44
> 6 32
> 7 19990
> 10 30028

以Unicode字符方式遍历时 每个字符的类型是rune(早起的Go语言用int表示Unicode字符)，而不是byte

#### 2.3.6 字符类型

在Go语言中指出两个字符类型，一个是byte(实际上是unit8的别名)代表UTF-8字符串的单个字节的值；另一个是rune，代表单个Unicode字符。

关于rune的操作，可查阅Go标准库的unicode包。另外unicode/utf8包也提供了UTF8和Unicode之间的转换。

出于简化语言的考虑，Go语言的多数API都假设字符串为UTF-8编码。尽管Unicode字符在标准库中有支持，实际很少使用

#### 2.3.7 数组

数组是Go语言编程中最常用的数据结构之一。顾名思义，数组就是一系列同一类型数据的集合。数组中包含的每个数据被称为数组元素，一个数组包含的元素个数被称为数组的长度。

以下为一些常规的数组声明方法:

```go
[32]byte					// 长度为32的数组，每个元素为一个字节
[2*N] struct {x, y int32}	// 复杂类型数组
[1000]*float64				// 指针数组
[3][5]int					// 二位数组
[2][2][2]float64			// 等同于[2]([2]([2]float64))
```

从以上类型也可以看出，数组是多维的。在Go语言中，数组长度定义后就不可再更改，在声明时长度可以为一个常量或者一个常量表达式(常量表达式是指在编译期就可计算结果的表达式)。数组的长度是该数组类型的一个内置常量，可以用Go语言的内置函数len()来获取。下面是一个获取数组arr元素个数的写法

```go
arrLength := len(arr)
```

1、元素访问

可以使用数组下标来访问数组中的元素。与C语言相同，数组下标从0开始，len(array)-1则表示最后一个元素的下标。下面是示例遍历整型数组并诸葛打印元素内容

```go
for i := 0; i < len(array); i++ {
    fmt.Println("Element", i, "of array is", array[i])
}
```

Go语言还提供了一个关键字range，用于便捷的遍历容器中的元素。当然数组也是range的支持范围。上面的遍历过程可以简化为如下的写法

```go
for i, v := range array {
    fmt.Println("Element", i, "of array is", array[i])
}
```

range具有两个返回值，第一个返回值是元素的数组下标，第二个返回值是元素的值。

2、值类型

在Go语言中数组是一个值类型。所有值类型变量在赋值和作为参数传递时都将产生一次赋值动作。如果将数组作为函数的参数类型，则在函数调用时该参数会发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是传入数组的一个副本。

```go
package main

import "fmt"

func modify(array [5]int) {
    array[0] = 10 // 试图修改数组的第一个元素
    fmt.Println("In modify(), array values:". array)
}

func main() {
    array := [5]int{1,2,3,4,5} // 定义并初始化一个数组
    modify(array) // 传递给一个函数并试图在这个函数内修改这个数组内容
    fmt.Println("In main(). array values:". array)
}
```

输出

>In modify(), array values: [10 2 3 4 5]
>In main(). array values: [1 2 3 4 5]

函数modify()内操作的数组跟main()传入的数组是两个不同的实例。

#### 2.3.8 数组切片

数组的特点：数组的长度在定义之后无法再次修改，数组是值类型，每次传递都将产生一份副本。显然这种数据结构无法完全满足开发者的真实需求。

Go提供了数组切片(slice)来满足数组的不足。

初看起来，slice就想一个指向数组的指针，实际上它拥有自己的数据结构，而不仅仅是个指针。数组切片的数据结构可以抽象为以下3个变量：

- 一个指向原生数组的指针
- 数组切片中的元素个数
- 数组切片已分配的存储空间

从底层实现的角度看，数组切片依然使用数组来管理元素，因此它们之间的关系很容易联想起STL中std::vector和数组的关系。基于数组，数组切片添加了一系列管理功能，可以随时动态扩充存放空间，并且可以随意传递而不会导致所管理的元素被重复复制。

1、创建数组切片

创建数组切片的方法主要有两种——基于数组和直接创建。